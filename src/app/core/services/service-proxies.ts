//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AssetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    asset_CreateAsset(body: AssetDto | undefined): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/Asset/Asset_CreateAsset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsset_CreateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsset_CreateAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAsset_CreateAsset(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    asset_GetAssetById(id: string): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/Asset/Asset_GetAssetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsset_GetAssetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsset_GetAssetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAsset_GetAssetById(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    asset_GetAllAssets(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/Asset/Asset_GetAllAssets?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsset_GetAllAssets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsset_GetAllAssets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAsset_GetAllAssets(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    asset_UpdateAsset(id: string, body: AssetDto | undefined): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/Asset/Asset_UpdateAsset/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsset_UpdateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsset_UpdateAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAsset_UpdateAsset(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    asset_DeleteAsset(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Asset/Asset_DeleteAsset/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsset_DeleteAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsset_DeleteAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAsset_DeleteAsset(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AssetManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    assetManagement_GetAll(): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAssetManagement_GetAll(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetById(id: string): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAssetManagement_GetById(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetByType(assetType: AssetType): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetByType/{assetType}";
        if (assetType === undefined || assetType === null)
            throw new globalThis.Error("The parameter 'assetType' must be defined.");
        url_ = url_.replace("{assetType}", encodeURIComponent("" + assetType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAssetManagement_GetByType(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetByStatus(status: AssetStatus): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetByStatus/{status}";
        if (status === undefined || status === null)
            throw new globalThis.Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetByStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetByStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAssetManagement_GetByStatus(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetAvailable(): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetAvailable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAssetManagement_GetAvailable(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_Create(body: CreateAssetDto | undefined): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAssetManagement_Create(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_Update(body: UpdateAssetDto | undefined): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAssetManagement_Update(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssetManagement_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetStats(): Observable<AssetStatsDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetStatsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetStatsDto>;
        }));
    }

    protected processAssetManagement_GetStats(response: HttpResponseBase): Observable<AssetStatsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetStatsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_Checkout(body: CheckoutAssetDto | undefined): Observable<AssetCheckoutDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_Checkout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_Checkout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_Checkout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto>;
        }));
    }

    protected processAssetManagement_Checkout(response: HttpResponseBase): Observable<AssetCheckoutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetCheckoutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_Checkin(body: CheckinAssetDto | undefined): Observable<AssetCheckoutDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_Checkin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_Checkin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_Checkin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto>;
        }));
    }

    protected processAssetManagement_Checkin(response: HttpResponseBase): Observable<AssetCheckoutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetCheckoutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetAllCheckouts(): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetAllCheckouts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetAllCheckouts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetAllCheckouts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetAllCheckouts(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetActiveCheckouts(): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetActiveCheckouts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetActiveCheckouts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetActiveCheckouts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetActiveCheckouts(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetOverdueCheckouts(): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetOverdueCheckouts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetOverdueCheckouts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetOverdueCheckouts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetOverdueCheckouts(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetMyCheckouts(): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetMyCheckouts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetMyCheckouts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetMyCheckouts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetMyCheckouts(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetCheckoutsByUser(userId: string): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetCheckoutsByUser/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetCheckoutsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetCheckoutsByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetCheckoutsByUser(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetCheckoutsByAsset(assetId: string): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetCheckoutsByAsset/{assetId}";
        if (assetId === undefined || assetId === null)
            throw new globalThis.Error("The parameter 'assetId' must be defined.");
        url_ = url_.replace("{assetId}", encodeURIComponent("" + assetId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetCheckoutsByAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetCheckoutsByAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetCheckoutsByAsset(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetCheckoutById(id: string): Observable<AssetCheckoutDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetCheckoutById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetCheckoutById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetCheckoutById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto>;
        }));
    }

    protected processAssetManagement_GetCheckoutById(response: HttpResponseBase): Observable<AssetCheckoutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetCheckoutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_CancelCheckout(checkoutId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_CancelCheckout/{checkoutId}";
        if (checkoutId === undefined || checkoutId === null)
            throw new globalThis.Error("The parameter 'checkoutId' must be defined.");
        url_ = url_.replace("{checkoutId}", encodeURIComponent("" + checkoutId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_CancelCheckout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_CancelCheckout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssetManagement_CancelCheckout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_CreateInspection(assetId: string, body: InspectionLogDto | undefined): Observable<AssetInspectionLogDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_CreateInspection/{assetId}";
        if (assetId === undefined || assetId === null)
            throw new globalThis.Error("The parameter 'assetId' must be defined.");
        url_ = url_.replace("{assetId}", encodeURIComponent("" + assetId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_CreateInspection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_CreateInspection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetInspectionLogDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetInspectionLogDto>;
        }));
    }

    protected processAssetManagement_CreateInspection(response: HttpResponseBase): Observable<AssetInspectionLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetInspectionLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetInspectionsByAsset(assetId: string): Observable<AssetInspectionLogDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetInspectionsByAsset/{assetId}";
        if (assetId === undefined || assetId === null)
            throw new globalThis.Error("The parameter 'assetId' must be defined.");
        url_ = url_.replace("{assetId}", encodeURIComponent("" + assetId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetInspectionsByAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetInspectionsByAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetInspectionLogDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetInspectionLogDto[]>;
        }));
    }

    protected processAssetManagement_GetInspectionsByAsset(response: HttpResponseBase): Observable<AssetInspectionLogDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetInspectionLogDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetInspectionsByCheckout(checkoutId: string): Observable<AssetInspectionLogDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetInspectionsByCheckout/{checkoutId}";
        if (checkoutId === undefined || checkoutId === null)
            throw new globalThis.Error("The parameter 'checkoutId' must be defined.");
        url_ = url_.replace("{checkoutId}", encodeURIComponent("" + checkoutId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetInspectionsByCheckout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetInspectionsByCheckout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetInspectionLogDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetInspectionLogDto[]>;
        }));
    }

    protected processAssetManagement_GetInspectionsByCheckout(response: HttpResponseBase): Observable<AssetInspectionLogDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetInspectionLogDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetInspectionById(id: string): Observable<AssetInspectionLogDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetInspectionById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetInspectionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetInspectionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetInspectionLogDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetInspectionLogDto>;
        }));
    }

    protected processAssetManagement_GetInspectionById(response: HttpResponseBase): Observable<AssetInspectionLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetInspectionLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_ScheduleMaintenance(body: ScheduleMaintenanceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_ScheduleMaintenance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_ScheduleMaintenance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_ScheduleMaintenance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssetManagement_ScheduleMaintenance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_CompleteMaintenance(body: CompleteMaintenanceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_CompleteMaintenance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_CompleteMaintenance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_CompleteMaintenance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssetManagement_CompleteMaintenance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetAssetsNeedingMaintenance(): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetAssetsNeedingMaintenance";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetAssetsNeedingMaintenance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetAssetsNeedingMaintenance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAssetManagement_GetAssetsNeedingMaintenance(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_RegisterTenant(body: TenantCreateUpdateDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Auth/Auth_RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_RegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_RegisterTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAuth_RegisterTenant(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_Register(body: RegisterRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Register(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Register(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_Register(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    auth_TestIdentity(): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_TestIdentity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_TestIdentity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_TestIdentity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_TestIdentity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    auth_DebugClaims(): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_DebugClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_DebugClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_DebugClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_DebugClaims(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_Login(body: LoginRequest | undefined): Observable<AuthResult> {
        let url_ = this.baseUrl + "/api/Auth/Auth_Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Login(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Login(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResult>;
        }));
    }

    protected processAuth_Login(response: HttpResponseBase): Observable<AuthResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_Refresh(body: RefreshTokenRequest | undefined): Observable<AuthResult> {
        let url_ = this.baseUrl + "/api/Auth/Auth_Refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Refresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Refresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResult>;
        }));
    }

    protected processAuth_Refresh(response: HttpResponseBase): Observable<AuthResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_Revoke(body: RevokeTokenRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_Revoke";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Revoke(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Revoke(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_Revoke(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_ForgotPassword(body: ForgotPasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_ForgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_ForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_ForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_ForgotPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_ResetPassword(body: ResetPasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_ResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_ResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_ResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_ChangePassword(body: ChangePasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_ChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_ChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_ChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BeneficiaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    beneficiary_GetById(id: string): Observable<BeneficiaryDto> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto>;
        }));
    }

    protected processBeneficiary_GetById(response: HttpResponseBase): Observable<BeneficiaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    beneficiary_GetAllBeneficiaries(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<BeneficiaryDto[]> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_GetAllBeneficiaries?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_GetAllBeneficiaries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_GetAllBeneficiaries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto[]>;
        }));
    }

    protected processBeneficiary_GetAllBeneficiaries(response: HttpResponseBase): Observable<BeneficiaryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BeneficiaryDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    beneficiary_GetMyBeneficiaries(): Observable<BeneficiaryDto[]> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_GetMyBeneficiaries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_GetMyBeneficiaries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_GetMyBeneficiaries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto[]>;
        }));
    }

    protected processBeneficiary_GetMyBeneficiaries(response: HttpResponseBase): Observable<BeneficiaryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BeneficiaryDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    beneficiary_GetBeneficiariesByMemberId(memberId: string): Observable<BeneficiaryDto[]> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_GetBeneficiariesByMemberId/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_GetBeneficiariesByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_GetBeneficiariesByMemberId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto[]>;
        }));
    }

    protected processBeneficiary_GetBeneficiariesByMemberId(response: HttpResponseBase): Observable<BeneficiaryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BeneficiaryDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    beneficiary_CreateBeneficiary(body: BeneficiaryDto | undefined): Observable<BeneficiaryDto> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_CreateBeneficiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_CreateBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_CreateBeneficiary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto>;
        }));
    }

    protected processBeneficiary_CreateBeneficiary(response: HttpResponseBase): Observable<BeneficiaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = BeneficiaryDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    beneficiary_UpdateBeneficiary(body: BeneficiaryDto | undefined): Observable<BeneficiaryDto> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_UpdateBeneficiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_UpdateBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_UpdateBeneficiary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto>;
        }));
    }

    protected processBeneficiary_UpdateBeneficiary(response: HttpResponseBase): Observable<BeneficiaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    beneficiary_DeleteBeneficiary(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_DeleteBeneficiary/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_DeleteBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_DeleteBeneficiary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBeneficiary_DeleteBeneficiary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ClaimServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    claim_CheckEligibility(body: ClaimEligibilityCheckDto | undefined): Observable<ClaimEligibilityResultDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_CheckEligibility";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_CheckEligibility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_CheckEligibility(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimEligibilityResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimEligibilityResultDto>;
        }));
    }

    protected processClaim_CheckEligibility(response: HttpResponseBase): Observable<ClaimEligibilityResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimEligibilityResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    claim_CreateEnhancedClaim(body: EnhancedCreateClaimDto | undefined): Observable<ClaimDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_CreateEnhancedClaim";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_CreateEnhancedClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_CreateEnhancedClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto>;
        }));
    }

    protected processClaim_CreateEnhancedClaim(response: HttpResponseBase): Observable<ClaimDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    claim_GetProcessTracking(id: string): Observable<ClaimProcessTrackingDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_GetProcessTracking/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_GetProcessTracking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_GetProcessTracking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimProcessTrackingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimProcessTrackingDto>;
        }));
    }

    protected processClaim_GetProcessTracking(response: HttpResponseBase): Observable<ClaimProcessTrackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimProcessTrackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    claim_GetByBeneficiary(beneficiaryId: string): Observable<ClaimDto[]> {
        let url_ = this.baseUrl + "/api/Claim/Claim_GetByBeneficiary/{beneficiaryId}";
        if (beneficiaryId === undefined || beneficiaryId === null)
            throw new globalThis.Error("The parameter 'beneficiaryId' must be defined.");
        url_ = url_.replace("{beneficiaryId}", encodeURIComponent("" + beneficiaryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_GetByBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_GetByBeneficiary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto[]>;
        }));
    }

    protected processClaim_GetByBeneficiary(response: HttpResponseBase): Observable<ClaimDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    claim_GetByMember(memberId: string): Observable<ClaimDto[]> {
        let url_ = this.baseUrl + "/api/Claim/Claim_GetByMember/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_GetByMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_GetByMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto[]>;
        }));
    }

    protected processClaim_GetByMember(response: HttpResponseBase): Observable<ClaimDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    claim_UpdateClaimDocuments(id: string, body: { [key: string]: boolean; } | undefined): Observable<ClaimDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_UpdateClaimDocuments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_UpdateClaimDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_UpdateClaimDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto>;
        }));
    }

    protected processClaim_UpdateClaimDocuments(response: HttpResponseBase): Observable<ClaimDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    claim_CreateClaim(body: CreateClaimDto | undefined): Observable<ClaimDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_CreateClaim";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_CreateClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_CreateClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto>;
        }));
    }

    protected processClaim_CreateClaim(response: HttpResponseBase): Observable<ClaimDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    claim_GetClaimById(id: string): Observable<ClaimDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_GetClaimById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_GetClaimById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_GetClaimById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto>;
        }));
    }

    protected processClaim_GetClaimById(response: HttpResponseBase): Observable<ClaimDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    claim_GetAllClaims(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<ClaimDto[]> {
        let url_ = this.baseUrl + "/api/Claim/Claim_GetAllClaims?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_GetAllClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_GetAllClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto[]>;
        }));
    }

    protected processClaim_GetAllClaims(response: HttpResponseBase): Observable<ClaimDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param status (optional) 
     * @param notes (optional) 
     * @return OK
     */
    claim_UpdateClaimStatus(id: string, status: ClaimStatus | undefined, notes: string | undefined): Observable<ClaimDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_UpdateClaimStatus/{id}?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (notes === null)
            throw new globalThis.Error("The parameter 'notes' cannot be null.");
        else if (notes !== undefined)
            url_ += "notes=" + encodeURIComponent("" + notes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_UpdateClaimStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_UpdateClaimStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto>;
        }));
    }

    protected processClaim_UpdateClaimStatus(response: HttpResponseBase): Observable<ClaimDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    claim_DeleteClaim(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Claim/Claim_DeleteClaim/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_DeleteClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_DeleteClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processClaim_DeleteClaim(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ContactFormServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    submit(body: ContactFormDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ContactForm/submit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DashboardWidgetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    dashboardWidget_GetAll(): Observable<DashboardWidgetSettingDto[]> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardWidgetSettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardWidgetSettingDto[]>;
        }));
    }

    protected processDashboardWidget_GetAll(response: HttpResponseBase): Observable<DashboardWidgetSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DashboardWidgetSettingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dashboardWidget_GetVisibleByRoles(body: string[] | undefined): Observable<DashboardWidgetSettingDto[]> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_GetVisibleByRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_GetVisibleByRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_GetVisibleByRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardWidgetSettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardWidgetSettingDto[]>;
        }));
    }

    protected processDashboardWidget_GetVisibleByRoles(response: HttpResponseBase): Observable<DashboardWidgetSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DashboardWidgetSettingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dashboardWidget_Create(body: CreateDashboardWidgetSettingDto | undefined): Observable<DashboardWidgetSettingDto> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardWidgetSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardWidgetSettingDto>;
        }));
    }

    protected processDashboardWidget_Create(response: HttpResponseBase): Observable<DashboardWidgetSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardWidgetSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dashboardWidget_Update(body: UpdateDashboardWidgetSettingDto | undefined): Observable<DashboardWidgetSettingDto> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardWidgetSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardWidgetSettingDto>;
        }));
    }

    protected processDashboardWidget_Update(response: HttpResponseBase): Observable<DashboardWidgetSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardWidgetSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dashboardWidget_Delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDashboardWidget_Delete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dashboardWidget_InitializeDefaults(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_InitializeDefaults";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_InitializeDefaults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_InitializeDefaults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDashboardWidget_InitializeDefaults(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BatchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateBatchRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/debit-order/batch/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    generateFile(batchId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/debit-order/batch/{batchId}/generate-file";
        if (batchId === undefined || batchId === null)
            throw new globalThis.Error("The parameter 'batchId' must be defined.");
        url_ = url_.replace("{batchId}", encodeURIComponent("" + batchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param responseFile (optional) 
     * @return OK
     */
    processResponse(responseFile: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/debit-order/batch/process-response";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (responseFile === null || responseFile === undefined)
            throw new globalThis.Error("The parameter 'responseFile' cannot be null.");
        else
            content_.append("responseFile", responseFile.data, responseFile.fileName ? responseFile.fileName : "responseFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessResponse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProcessResponse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class Debit_orderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    batchList(page: number | undefined, pageSize: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/debit-order/batch-list?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBatchList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    batchById(batchId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/debit-order/batch-by-id/{batchId}";
        if (batchId === undefined || batchId === null)
            throw new globalThis.Error("The parameter 'batchId' must be defined.");
        url_ = url_.replace("{batchId}", encodeURIComponent("" + batchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBatchById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    batchTransactions(batchId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/debit-order/batch-transactions/{batchId}";
        if (batchId === undefined || batchId === null)
            throw new globalThis.Error("The parameter 'batchId' must be defined.");
        url_ = url_.replace("{batchId}", encodeURIComponent("" + batchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBatchTransactions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DependentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    dependent_GetById(id: string): Observable<DependentDto> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto>;
        }));
    }

    protected processDependent_GetById(response: HttpResponseBase): Observable<DependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DependentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    dependent_GetAllDependents(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<DependentDto[]> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_GetAllDependents?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_GetAllDependents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_GetAllDependents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto[]>;
        }));
    }

    protected processDependent_GetAllDependents(response: HttpResponseBase): Observable<DependentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DependentDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dependent_GetMyDependents(): Observable<DependentDto[]> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_GetMyDependents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_GetMyDependents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_GetMyDependents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto[]>;
        }));
    }

    protected processDependent_GetMyDependents(response: HttpResponseBase): Observable<DependentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DependentDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dependent_GetDependentsByMemberId(memberId: string): Observable<DependentDto[]> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_GetDependentsByMemberId/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_GetDependentsByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_GetDependentsByMemberId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto[]>;
        }));
    }

    protected processDependent_GetDependentsByMemberId(response: HttpResponseBase): Observable<DependentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DependentDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    dependent_CreateDependent(body: DependentDto | undefined): Observable<DependentDto> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_CreateDependent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_CreateDependent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_CreateDependent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto>;
        }));
    }

    protected processDependent_CreateDependent(response: HttpResponseBase): Observable<DependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DependentDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dependent_UpdateDependent(body: DependentDto | undefined): Observable<DependentDto> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_UpdateDependent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_UpdateDependent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_UpdateDependent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto>;
        }));
    }

    protected processDependent_UpdateDependent(response: HttpResponseBase): Observable<DependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DependentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    dependent_DeleteDependent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_DeleteDependent/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_DeleteDependent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_DeleteDependent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDependent_DeleteDependent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DocumentRequirementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    documentRequirement_GetRequiredDocuments(memberId: string): Observable<DocumentRequirement[]> {
        let url_ = this.baseUrl + "/api/DocumentRequirement/DocumentRequirement_GetRequiredDocuments/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentRequirement_GetRequiredDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentRequirement_GetRequiredDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentRequirement[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentRequirement[]>;
        }));
    }

    protected processDocumentRequirement_GetRequiredDocuments(response: HttpResponseBase): Observable<DocumentRequirement[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentRequirement.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    documentRequirement_GetComplianceStatus(memberId: string): Observable<DocumentComplianceStatus> {
        let url_ = this.baseUrl + "/api/DocumentRequirement/DocumentRequirement_GetComplianceStatus/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentRequirement_GetComplianceStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentRequirement_GetComplianceStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentComplianceStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentComplianceStatus>;
        }));
    }

    protected processDocumentRequirement_GetComplianceStatus(response: HttpResponseBase): Observable<DocumentComplianceStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentComplianceStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    documentRequirement_GetMissingDocuments(memberId: string): Observable<DocumentRequirement[]> {
        let url_ = this.baseUrl + "/api/DocumentRequirement/DocumentRequirement_GetMissingDocuments/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentRequirement_GetMissingDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentRequirement_GetMissingDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentRequirement[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentRequirement[]>;
        }));
    }

    protected processDocumentRequirement_GetMissingDocuments(response: HttpResponseBase): Observable<DocumentRequirement[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentRequirement.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FileUploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param entityType (optional) 
     * @param entityId (optional) 
     * @param documentType (optional) 
     * @param memberDocumentType (optional) 
     * @param isRequired (optional) 
     * @param file (optional) 
     * @return OK
     */
    file_UploadFile(entityType: string | undefined, entityId: string | undefined, documentType: string | undefined, memberDocumentType: number | undefined, isRequired: boolean | undefined, file: FileParameter | undefined): Observable<FileMetadataDto> {
        let url_ = this.baseUrl + "/api/FileUpload/File_UploadFile?";
        if (entityType === null)
            throw new globalThis.Error("The parameter 'entityType' cannot be null.");
        else if (entityType !== undefined)
            url_ += "entityType=" + encodeURIComponent("" + entityType) + "&";
        if (entityId === null)
            throw new globalThis.Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (documentType === null)
            throw new globalThis.Error("The parameter 'documentType' cannot be null.");
        else if (documentType !== undefined)
            url_ += "documentType=" + encodeURIComponent("" + documentType) + "&";
        if (memberDocumentType === null)
            throw new globalThis.Error("The parameter 'memberDocumentType' cannot be null.");
        else if (memberDocumentType !== undefined)
            url_ += "memberDocumentType=" + encodeURIComponent("" + memberDocumentType) + "&";
        if (isRequired === null)
            throw new globalThis.Error("The parameter 'isRequired' cannot be null.");
        else if (isRequired !== undefined)
            url_ += "isRequired=" + encodeURIComponent("" + isRequired) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_UploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_UploadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileMetadataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileMetadataDto>;
        }));
    }

    protected processFile_UploadFile(response: HttpResponseBase): Observable<FileMetadataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileMetadataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    file_GetMyFiles(): Observable<FileMetadataDto[]> {
        let url_ = this.baseUrl + "/api/FileUpload/File_GetMyFiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_GetMyFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_GetMyFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileMetadataDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileMetadataDto[]>;
        }));
    }

    protected processFile_GetMyFiles(response: HttpResponseBase): Observable<FileMetadataDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileMetadataDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    file_GetFilesByMemberId(memberId: string): Observable<FileMetadataDto[]> {
        let url_ = this.baseUrl + "/api/FileUpload/File_GetFilesByMemberId/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_GetFilesByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_GetFilesByMemberId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileMetadataDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileMetadataDto[]>;
        }));
    }

    protected processFile_GetFilesByMemberId(response: HttpResponseBase): Observable<FileMetadataDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileMetadataDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    file_GetByFileId(fileId: string): Observable<FileMetadataDto> {
        let url_ = this.baseUrl + "/api/FileUpload/File_GetByFileId/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new globalThis.Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_GetByFileId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_GetByFileId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileMetadataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileMetadataDto>;
        }));
    }

    protected processFile_GetByFileId(response: HttpResponseBase): Observable<FileMetadataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileMetadataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    file_DeleteFile(fileId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/FileUpload/File_DeleteFile/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new globalThis.Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_DeleteFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_DeleteFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFile_DeleteFile(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    file_DownloadFile(fileId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/FileUpload/File_DownloadFile/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new globalThis.Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_DownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_DownloadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFile_DownloadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    fileUpload(fileId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/FileUpload/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new globalThis.Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFileUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFileUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFileUpload(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantBankingPost(body: TenantBankingDetailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/tenant-banking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantBankingPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantBankingPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantBankingPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantBankingGet(): Observable<void> {
        let url_ = this.baseUrl + "/api/tenant-banking";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantBankingGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantBankingGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantBankingGet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantBankingDelete(bankingDetailId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/tenant-banking/{bankingDetailId}";
        if (bankingDetailId === undefined || bankingDetailId === null)
            throw new globalThis.Error("The parameter 'bankingDetailId' must be defined.");
        url_ = url_.replace("{bankingDetailId}", encodeURIComponent("" + bankingDetailId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantBankingDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantBankingDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantBankingDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FuneralEventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    funeralEvent_CreateFuneralEvent(body: FuneralEventDto | undefined): Observable<FuneralEventDto> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_CreateFuneralEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_CreateFuneralEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_CreateFuneralEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto>;
        }));
    }

    protected processFuneralEvent_CreateFuneralEvent(response: HttpResponseBase): Observable<FuneralEventDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuneralEventDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    funeralEvent_GetFuneralEventById(id: string): Observable<FuneralEventDto> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_GetFuneralEventById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_GetFuneralEventById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_GetFuneralEventById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto>;
        }));
    }

    protected processFuneralEvent_GetFuneralEventById(response: HttpResponseBase): Observable<FuneralEventDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuneralEventDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    funeralEvent_GetAllFuneralEvents(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<FuneralEventDto[]> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_GetAllFuneralEvents?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_GetAllFuneralEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_GetAllFuneralEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto[]>;
        }));
    }

    protected processFuneralEvent_GetAllFuneralEvents(response: HttpResponseBase): Observable<FuneralEventDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FuneralEventDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    funeralEvent_UpdateFuneralEvent(id: string, body: FuneralEventDto | undefined): Observable<FuneralEventDto> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_UpdateFuneralEvent/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_UpdateFuneralEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_UpdateFuneralEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto>;
        }));
    }

    protected processFuneralEvent_UpdateFuneralEvent(response: HttpResponseBase): Observable<FuneralEventDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuneralEventDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param status (optional) 
     * @return OK
     */
    funeralEvent_UpdateFuneralEventStatus(id: string, status: FuneralEventStatus | undefined): Observable<FuneralEventDto> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_UpdateFuneralEventStatus/{id}?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_UpdateFuneralEventStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_UpdateFuneralEventStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto>;
        }));
    }

    protected processFuneralEvent_UpdateFuneralEventStatus(response: HttpResponseBase): Observable<FuneralEventDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuneralEventDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    funeralEvent_DeleteFuneralEvent(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_DeleteFuneralEvent/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_DeleteFuneralEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_DeleteFuneralEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFuneralEvent_DeleteFuneralEvent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LandingPageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    landingPage_GetLandingPage(): Observable<LandingPageDto> {
        let url_ = this.baseUrl + "/api/LandingPage/LandingPage_GetLandingPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLandingPage_GetLandingPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLandingPage_GetLandingPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LandingPageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LandingPageDto>;
        }));
    }

    protected processLandingPage_GetLandingPage(response: HttpResponseBase): Observable<LandingPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LandingPageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    landingPage_CreateOrUpdateLandingPage(body: LandingPageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/LandingPage/LandingPage_CreateOrUpdateLandingPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLandingPage_CreateOrUpdateLandingPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLandingPage_CreateOrUpdateLandingPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLandingPage_CreateOrUpdateLandingPage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getEnumValues(enumTypeName: string): Observable<LookupDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetEnumValues/{enumTypeName}";
        if (enumTypeName === undefined || enumTypeName === null)
            throw new globalThis.Error("The parameter 'enumTypeName' must be defined.");
        url_ = url_.replace("{enumTypeName}", encodeURIComponent("" + enumTypeName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupDto[]>;
        }));
    }

    protected processGetEnumValues(response: HttpResponseBase): Observable<LookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MemberServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    member_GetById(id: string): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_GetById(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    member_GetAllMembers(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<MemberDto[]> {
        let url_ = this.baseUrl + "/api/Member/Member_GetAllMembers?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_GetAllMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_GetAllMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto[]>;
        }));
    }

    protected processMember_GetAllMembers(response: HttpResponseBase): Observable<MemberDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MemberDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    member_Create(body: CreateMemberDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Member/Member_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processMember_Create(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    member_ApproveMember(id: string): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_ApproveMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_ApproveMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_ApproveMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_ApproveMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    member_RejectMember(id: string, body: string | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_RejectMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_RejectMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_RejectMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_RejectMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    member_DisableMember(id: string): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_DisableMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_DisableMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_DisableMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_DisableMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    member_EnableMember(id: string): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_EnableMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_EnableMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_EnableMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_EnableMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    member_UpdateMember(id: string, body: MemberDto | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_UpdateMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_UpdateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_UpdateMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_UpdateMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    member_DeleteMember(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Member/Member_DeleteMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_DeleteMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_DeleteMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMember_DeleteMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    member_SaveSignature(body: SaveSignatureDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Member/Member_SaveSignature";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_SaveSignature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_SaveSignature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMember_SaveSignature(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    member_GetMySignature(): Observable<void> {
        let url_ = this.baseUrl + "/api/Member/Member_GetMySignature";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_GetMySignature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_GetMySignature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMember_GetMySignature(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param memberId (optional) 
     * @return OK
     */
    member_GetSignatureForMember(memberId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Member/Member_GetSignatureForMember?";
        if (memberId === null)
            throw new globalThis.Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_GetSignatureForMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_GetSignatureForMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMember_GetSignatureForMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MemberApprovalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    memberApproval_GetPendingMembers(): Observable<PendingMemberDto[]> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_GetPendingMembers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_GetPendingMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_GetPendingMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingMemberDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingMemberDto[]>;
        }));
    }

    protected processMemberApproval_GetPendingMembers(response: HttpResponseBase): Observable<PendingMemberDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PendingMemberDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberApproval_GetMemberDetail(memberId: string): Observable<MemberApprovalDetailDto> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_GetMemberDetail/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_GetMemberDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_GetMemberDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberApprovalDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberApprovalDetailDto>;
        }));
    }

    protected processMemberApproval_GetMemberDetail(response: HttpResponseBase): Observable<MemberApprovalDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberApprovalDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberApproval_ApproveMember(body: ApproveMemberRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_ApproveMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_ApproveMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_ApproveMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberApproval_ApproveMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberApproval_RejectMember(body: RejectMemberRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_RejectMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_RejectMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_RejectMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberApproval_RejectMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberApproval_RequestUpdates(body: RequestMemberUpdatesRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_RequestUpdates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_RequestUpdates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_RequestUpdates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberApproval_RequestUpdates(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberApproval_GetStats(): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_GetStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_GetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_GetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberApproval_GetStats(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MemberBankingDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    memberBankingDetail_GetMyBankingDetails(): Observable<MemberBankingDetailDto> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_GetMyBankingDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_GetMyBankingDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_GetMyBankingDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberBankingDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberBankingDetailDto>;
        }));
    }

    protected processMemberBankingDetail_GetMyBankingDetails(response: HttpResponseBase): Observable<MemberBankingDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberBankingDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberBankingDetail_GetBankingDetailsByMemberId(memberId: string): Observable<MemberBankingDetailDto> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_GetBankingDetailsByMemberId/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_GetBankingDetailsByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_GetBankingDetailsByMemberId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberBankingDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberBankingDetailDto>;
        }));
    }

    protected processMemberBankingDetail_GetBankingDetailsByMemberId(response: HttpResponseBase): Observable<MemberBankingDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberBankingDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberBankingDetail_HasBankingDetails(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_HasBankingDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_HasBankingDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_HasBankingDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processMemberBankingDetail_HasBankingDetails(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberBankingDetail_CreateBankingDetails(body: CreateMemberBankingDetailDto | undefined): Observable<MemberBankingDetailDto> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_CreateBankingDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_CreateBankingDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_CreateBankingDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberBankingDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberBankingDetailDto>;
        }));
    }

    protected processMemberBankingDetail_CreateBankingDetails(response: HttpResponseBase): Observable<MemberBankingDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberBankingDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberBankingDetail_UpdateBankingDetails(id: string, body: UpdateMemberBankingDetailDto | undefined): Observable<MemberBankingDetailDto> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_UpdateBankingDetails/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_UpdateBankingDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_UpdateBankingDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberBankingDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberBankingDetailDto>;
        }));
    }

    protected processMemberBankingDetail_UpdateBankingDetails(response: HttpResponseBase): Observable<MemberBankingDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberBankingDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberBankingDetail_DeleteBankingDetails(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_DeleteBankingDetails/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_DeleteBankingDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_DeleteBankingDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberBankingDetail_DeleteBankingDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MemberProfileCompletionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    profileCompletion_GetStatus(memberId: string): Observable<ProfileCompletionStatusDto> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_GetStatus/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_GetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_GetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileCompletionStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileCompletionStatusDto>;
        }));
    }

    protected processProfileCompletion_GetStatus(response: HttpResponseBase): Observable<ProfileCompletionStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileCompletionStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    profileCompletion_GetMyStatus(): Observable<ProfileCompletionStatusDto> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_GetMyStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_GetMyStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_GetMyStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileCompletionStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileCompletionStatusDto>;
        }));
    }

    protected processProfileCompletion_GetMyStatus(response: HttpResponseBase): Observable<ProfileCompletionStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileCompletionStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    profileCompletion_Initialize(body: string | undefined): Observable<MemberProfileCompletionDto> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_Initialize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_Initialize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_Initialize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberProfileCompletionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberProfileCompletionDto>;
        }));
    }

    protected processProfileCompletion_Initialize(response: HttpResponseBase): Observable<MemberProfileCompletionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberProfileCompletionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    profileCompletion_UpdateStep(body: UpdateProfileCompletionStepDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_UpdateStep";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_UpdateStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_UpdateStep(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProfileCompletion_UpdateStep(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    profileCompletion_Recalculate(memberId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_Recalculate/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_Recalculate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_Recalculate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProfileCompletion_Recalculate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    profileCompletion_RecalculateMy(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_RecalculateMy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_RecalculateMy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_RecalculateMy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProfileCompletion_RecalculateMy(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    profileCompletion_GetIncompleteMembers(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_GetIncompleteMembers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_GetIncompleteMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_GetIncompleteMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processProfileCompletion_GetIncompleteMembers(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MemberRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberRegistration_CheckIdNumber(body: CheckIdNumberDto | undefined): Observable<CheckIdNumberResponseDto> {
        let url_ = this.baseUrl + "/api/MemberRegistration/MemberRegistration_CheckIdNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberRegistration_CheckIdNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberRegistration_CheckIdNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckIdNumberResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckIdNumberResponseDto>;
        }));
    }

    protected processMemberRegistration_CheckIdNumber(response: HttpResponseBase): Observable<CheckIdNumberResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckIdNumberResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberRegistration_GetPolicyOptions(): Observable<PolicyOptionDto[]> {
        let url_ = this.baseUrl + "/api/MemberRegistration/MemberRegistration_GetPolicyOptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberRegistration_GetPolicyOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberRegistration_GetPolicyOptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyOptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyOptionDto[]>;
        }));
    }

    protected processMemberRegistration_GetPolicyOptions(response: HttpResponseBase): Observable<PolicyOptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PolicyOptionDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberRegistration_RegisterNewMember(body: RegisterNewMemberDto | undefined): Observable<AuthResult> {
        let url_ = this.baseUrl + "/api/MemberRegistration/MemberRegistration_RegisterNewMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberRegistration_RegisterNewMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberRegistration_RegisterNewMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResult>;
        }));
    }

    protected processMemberRegistration_RegisterNewMember(response: HttpResponseBase): Observable<AuthResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberRegistration_SendDependentOtp(body: RequestDependentOtpDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberRegistration/MemberRegistration_SendDependentOtp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberRegistration_SendDependentOtp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberRegistration_SendDependentOtp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberRegistration_SendDependentOtp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberRegistration_VerifyOtpAndCreateAccount(body: VerifyDependentOtpDto | undefined): Observable<AuthResult> {
        let url_ = this.baseUrl + "/api/MemberRegistration/MemberRegistration_VerifyOtpAndCreateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberRegistration_VerifyOtpAndCreateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberRegistration_VerifyOtpAndCreateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResult>;
        }));
    }

    protected processMemberRegistration_VerifyOtpAndCreateAccount(response: HttpResponseBase): Observable<AuthResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OnboardingContractServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    generate(body: GenerateContractRequest | undefined): Observable<ContractGenerationResult> {
        let url_ = this.baseUrl + "/api/OnboardingContract/generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractGenerationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractGenerationResult>;
        }));
    }

    protected processGenerate(response: HttpResponseBase): Observable<ContractGenerationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractGenerationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sign(body: SignContractRequest | undefined): Observable<OnboardingContractDto> {
        let url_ = this.baseUrl + "/api/OnboardingContract/sign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSign(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingContractDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingContractDto>;
        }));
    }

    protected processSign(response: HttpResponseBase): Observable<OnboardingContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    contractById(contractId: string): Observable<OnboardingContractDto> {
        let url_ = this.baseUrl + "/api/OnboardingContract/contract-by-id/{contractId}";
        if (contractId === undefined || contractId === null)
            throw new globalThis.Error("The parameter 'contractId' must be defined.");
        url_ = url_.replace("{contractId}", encodeURIComponent("" + contractId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingContractDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingContractDto>;
        }));
    }

    protected processContractById(response: HttpResponseBase): Observable<OnboardingContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    contractsByMember(memberId: string): Observable<OnboardingContractDto[]> {
        let url_ = this.baseUrl + "/api/OnboardingContract/contracts-by-member/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractsByMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractsByMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingContractDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingContractDto[]>;
        }));
    }

    protected processContractsByMember(response: HttpResponseBase): Observable<OnboardingContractDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OnboardingContractDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    contractDownload(contractId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingContract/contract-download/{contractId}";
        if (contractId === undefined || contractId === null)
            throw new globalThis.Error("The parameter 'contractId' must be defined.");
        url_ = url_.replace("{contractId}", encodeURIComponent("" + contractId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractDownload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processContractDownload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OnboardingFieldConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    onboardingFieldConfiguration_GetAll(): Observable<OnboardingFieldConfigurationDto[]> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingFieldConfigurationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingFieldConfigurationDto[]>;
        }));
    }

    protected processOnboardingFieldConfiguration_GetAll(response: HttpResponseBase): Observable<OnboardingFieldConfigurationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OnboardingFieldConfigurationDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_GetById(id: string | undefined): Observable<OnboardingFieldConfigurationDto> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_GetById?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingFieldConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingFieldConfigurationDto>;
        }));
    }

    protected processOnboardingFieldConfiguration_GetById(response: HttpResponseBase): Observable<OnboardingFieldConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingFieldConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldConfiguration_GetEnabled(): Observable<OnboardingFieldConfigurationDto[]> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_GetEnabled";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_GetEnabled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_GetEnabled(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingFieldConfigurationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingFieldConfigurationDto[]>;
        }));
    }

    protected processOnboardingFieldConfiguration_GetEnabled(response: HttpResponseBase): Observable<OnboardingFieldConfigurationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OnboardingFieldConfigurationDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldConfiguration_GetByCategory(): Observable<{ [key: string]: OnboardingFieldConfigurationDto[]; }> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_GetByCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_GetByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_GetByCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: OnboardingFieldConfigurationDto[]; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: OnboardingFieldConfigurationDto[]; }>;
        }));
    }

    protected processOnboardingFieldConfiguration_GetByCategory(response: HttpResponseBase): Observable<{ [key: string]: OnboardingFieldConfigurationDto[]; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (result200 as any)![key] = resultData200[key] ? resultData200[key].map((i: any) => OnboardingFieldConfigurationDto.fromJS(i)) : [];
                }
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_Create(body: CreateOnboardingFieldConfigurationDto | undefined): Observable<OnboardingFieldConfigurationDto> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingFieldConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingFieldConfigurationDto>;
        }));
    }

    protected processOnboardingFieldConfiguration_Create(response: HttpResponseBase): Observable<OnboardingFieldConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingFieldConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_Update(body: UpdateOnboardingFieldConfigurationDto | undefined): Observable<OnboardingFieldConfigurationDto> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingFieldConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingFieldConfigurationDto>;
        }));
    }

    protected processOnboardingFieldConfiguration_Update(response: HttpResponseBase): Observable<OnboardingFieldConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingFieldConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_Delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_Delete?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldConfiguration_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_UpdateOrders(body: UpdateFieldOrderDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_UpdateOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_UpdateOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_UpdateOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldConfiguration_UpdateOrders(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldConfiguration_InitializeDefaults(): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_InitializeDefaults";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_InitializeDefaults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_InitializeDefaults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldConfiguration_InitializeDefaults(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_SaveMemberData(body: SaveMemberOnboardingDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_SaveMemberData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_SaveMemberData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_SaveMemberData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldConfiguration_SaveMemberData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldConfiguration_GetMemberData(): Observable<MemberOnboardingDataDto> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_GetMemberData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_GetMemberData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_GetMemberData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberOnboardingDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberOnboardingDataDto>;
        }));
    }

    protected processOnboardingFieldConfiguration_GetMemberData(response: HttpResponseBase): Observable<MemberOnboardingDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberOnboardingDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OnboardingPdfServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param memberId (optional) 
     * @return OK
     */
    onboardingPdf_PreviewPdf(memberId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingPdf/OnboardingPdf_PreviewPdf?";
        if (memberId === null)
            throw new globalThis.Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingPdf_PreviewPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingPdf_PreviewPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingPdf_PreviewPdf(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param memberId (optional) 
     * @return OK
     */
    onboardingPdf_DownloadPdf(memberId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingPdf/OnboardingPdf_DownloadPdf?";
        if (memberId === null)
            throw new globalThis.Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingPdf_DownloadPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingPdf_DownloadPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingPdf_DownloadPdf(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class Payment_configServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    gatewayList(): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGatewayList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    gatewayById(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-by-id/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGatewayById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    gatewayCreate(body: PaymentGatewayConfigDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGatewayCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    gatewayUpdate(id: string, body: PaymentGatewayConfigDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-update/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGatewayUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    gatewayDelete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGatewayDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    gatewayToggle(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-toggle/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayToggle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayToggle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGatewayToggle(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    providers(): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProviders(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class Payment_gatewayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    initiate(body: InitiatePaymentRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-gateway/initiate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitiate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitiate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInitiate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param provider (optional) 
     * @return OK
     */
    verify(transactionId: string, provider: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-gateway/verify/{transactionId}?";
        if (transactionId === undefined || transactionId === null)
            throw new globalThis.Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        if (provider === null)
            throw new globalThis.Error("The parameter 'provider' cannot be null.");
        else if (provider !== undefined)
            url_ += "provider=" + encodeURIComponent("" + provider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param data (optional) 
     * @return OK
     */
    webhook(provider: string, data: { [key: string]: string; } | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-gateway/webhook/{provider}";
        if (provider === undefined || provider === null)
            throw new globalThis.Error("The parameter 'provider' must be defined.");
        url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (data === null || data === undefined)
            throw new globalThis.Error("The parameter 'data' cannot be null.");
        else
            content_.append("data", JSON.stringify(data));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWebhook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWebhook(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PdfFieldMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    pdfFieldMapping_GetAll(): Observable<PdfFieldMappingDto[]> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfFieldMappingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfFieldMappingDto[]>;
        }));
    }

    protected processPdfFieldMapping_GetAll(response: HttpResponseBase): Observable<PdfFieldMappingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PdfFieldMappingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    pdfFieldMapping_GetById(id: string): Observable<PdfFieldMappingDto> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfFieldMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfFieldMappingDto>;
        }));
    }

    protected processPdfFieldMapping_GetById(response: HttpResponseBase): Observable<PdfFieldMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfFieldMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    pdfFieldMapping_Create(body: CreatePdfFieldMappingRequest | undefined): Observable<PdfFieldMappingDto> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfFieldMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfFieldMappingDto>;
        }));
    }

    protected processPdfFieldMapping_Create(response: HttpResponseBase): Observable<PdfFieldMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfFieldMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    pdfFieldMapping_Update(id: string, body: UpdatePdfFieldMappingRequest | undefined): Observable<PdfFieldMappingDto> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_Update/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfFieldMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfFieldMappingDto>;
        }));
    }

    protected processPdfFieldMapping_Update(response: HttpResponseBase): Observable<PdfFieldMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfFieldMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    pdfFieldMapping_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPdfFieldMapping_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    pdfFieldMapping_AnalyzeTemplate(templateFileId: string): Observable<PdfTemplateAnalysisResult> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_AnalyzeTemplate/{templateFileId}";
        if (templateFileId === undefined || templateFileId === null)
            throw new globalThis.Error("The parameter 'templateFileId' must be defined.");
        url_ = url_.replace("{templateFileId}", encodeURIComponent("" + templateFileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_AnalyzeTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_AnalyzeTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfTemplateAnalysisResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfTemplateAnalysisResult>;
        }));
    }

    protected processPdfFieldMapping_AnalyzeTemplate(response: HttpResponseBase): Observable<PdfTemplateAnalysisResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfTemplateAnalysisResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    permission_GetAllPermissions(): Observable<Permission[]> {
        let url_ = this.baseUrl + "/api/Permission/Permission_GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPermission_GetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPermission_GetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Permission[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Permission[]>;
        }));
    }

    protected processPermission_GetAllPermissions(response: HttpResponseBase): Observable<Permission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Permission.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    permission_CreatePermission(body: PermissionInput | undefined): Observable<Permission> {
        let url_ = this.baseUrl + "/api/Permission/Permission_CreatePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPermission_CreatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPermission_CreatePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Permission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Permission>;
        }));
    }

    protected processPermission_CreatePermission(response: HttpResponseBase): Observable<Permission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Permission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PersonnelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    personnel_GetMySchedule(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<FuneralEventDto[]> {
        let url_ = this.baseUrl + "/api/Personnel/Personnel_GetMySchedule?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonnel_GetMySchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonnel_GetMySchedule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto[]>;
        }));
    }

    protected processPersonnel_GetMySchedule(response: HttpResponseBase): Observable<FuneralEventDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FuneralEventDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PolicyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    policy_GetById(id: string): Observable<PolicyDto> {
        let url_ = this.baseUrl + "/api/Policy/Policy_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicy_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicy_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyDto>;
        }));
    }

    protected processPolicy_GetById(response: HttpResponseBase): Observable<PolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    policy_GetAllPolicies(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<PolicyDto[]> {
        let url_ = this.baseUrl + "/api/Policy/Policy_GetAllPolicies?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicy_GetAllPolicies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicy_GetAllPolicies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyDto[]>;
        }));
    }

    protected processPolicy_GetAllPolicies(response: HttpResponseBase): Observable<PolicyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PolicyDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policy_CreatePolicy(body: PolicyDto | undefined): Observable<PolicyDto> {
        let url_ = this.baseUrl + "/api/Policy/Policy_CreatePolicy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicy_CreatePolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicy_CreatePolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyDto>;
        }));
    }

    protected processPolicy_CreatePolicy(response: HttpResponseBase): Observable<PolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policy_UpdatePolicy(body: PolicyDto | undefined): Observable<PolicyDto> {
        let url_ = this.baseUrl + "/api/Policy/Policy_UpdatePolicy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicy_UpdatePolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicy_UpdatePolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyDto>;
        }));
    }

    protected processPolicy_UpdatePolicy(response: HttpResponseBase): Observable<PolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    policy_DeletePolicy(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Policy/Policy_DeletePolicy/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicy_DeletePolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicy_DeletePolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPolicy_DeletePolicy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PolicyAttributeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    policyAttribute_GetById(id: string): Observable<PolicyAttributeDto> {
        let url_ = this.baseUrl + "/api/PolicyAttribute/PolicyAttribute_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyAttribute_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyAttribute_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyAttributeDto>;
        }));
    }

    protected processPolicyAttribute_GetById(response: HttpResponseBase): Observable<PolicyAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param policyId (optional) 
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    policyAttribute_GetAllPolicies(policyId: string | undefined, searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<PolicyAttributeDto[]> {
        let url_ = this.baseUrl + "/api/PolicyAttribute/PolicyAttribute_GetAllPolicies?";
        if (policyId === null)
            throw new globalThis.Error("The parameter 'policyId' cannot be null.");
        else if (policyId !== undefined)
            url_ += "policyId=" + encodeURIComponent("" + policyId) + "&";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyAttribute_GetAllPolicies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyAttribute_GetAllPolicies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyAttributeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyAttributeDto[]>;
        }));
    }

    protected processPolicyAttribute_GetAllPolicies(response: HttpResponseBase): Observable<PolicyAttributeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PolicyAttributeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyAttribute_UpdatePolicyAttribute(body: PolicyAttributeDto | undefined): Observable<PolicyAttributeDto> {
        let url_ = this.baseUrl + "/api/PolicyAttribute/PolicyAttribute_UpdatePolicyAttribute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyAttribute_UpdatePolicyAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyAttribute_UpdatePolicyAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyAttributeDto>;
        }));
    }

    protected processPolicyAttribute_UpdatePolicyAttribute(response: HttpResponseBase): Observable<PolicyAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    policyAttribute_CreatePolicyAttribute(body: PolicyAttributeDto | undefined): Observable<PolicyAttributeDto> {
        let url_ = this.baseUrl + "/api/PolicyAttribute/PolicyAttribute_CreatePolicyAttribute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyAttribute_CreatePolicyAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyAttribute_CreatePolicyAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyAttributeDto>;
        }));
    }

    protected processPolicyAttribute_CreatePolicyAttribute(response: HttpResponseBase): Observable<PolicyAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PolicyAttributeDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    policyAttribute_DeletePolicyAttribute(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/PolicyAttribute/PolicyAttribute_DeletePolicyAttribute/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyAttribute_DeletePolicyAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyAttribute_DeletePolicyAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPolicyAttribute_DeletePolicyAttribute(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PolicyEnrollmentApprovalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    policyApproval_SubmitForApproval(enrollmentId: string): Observable<PolicyEnrollmentDto> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_SubmitForApproval/{enrollmentId}";
        if (enrollmentId === undefined || enrollmentId === null)
            throw new globalThis.Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{enrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_SubmitForApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_SubmitForApproval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto>;
        }));
    }

    protected processPolicyApproval_SubmitForApproval(response: HttpResponseBase): Observable<PolicyEnrollmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyEnrollmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyApproval_Approve(enrollmentId: string, body: ApproveEnrollmentDto | undefined): Observable<PolicyEnrollmentDto> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_Approve/{enrollmentId}";
        if (enrollmentId === undefined || enrollmentId === null)
            throw new globalThis.Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{enrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_Approve(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_Approve(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto>;
        }));
    }

    protected processPolicyApproval_Approve(response: HttpResponseBase): Observable<PolicyEnrollmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyEnrollmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyApproval_Reject(enrollmentId: string, body: RejectEnrollmentDto | undefined): Observable<PolicyEnrollmentDto> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_Reject/{enrollmentId}";
        if (enrollmentId === undefined || enrollmentId === null)
            throw new globalThis.Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{enrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_Reject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_Reject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto>;
        }));
    }

    protected processPolicyApproval_Reject(response: HttpResponseBase): Observable<PolicyEnrollmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyEnrollmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyApproval_RequestChanges(enrollmentId: string, body: RequestChangesDto | undefined): Observable<PolicyEnrollmentDto> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_RequestChanges/{enrollmentId}";
        if (enrollmentId === undefined || enrollmentId === null)
            throw new globalThis.Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{enrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_RequestChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_RequestChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto>;
        }));
    }

    protected processPolicyApproval_RequestChanges(response: HttpResponseBase): Observable<PolicyEnrollmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyEnrollmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    policyApproval_GetByReference(referenceNumber: string): Observable<PolicyEnrollmentDto> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_GetByReference/{referenceNumber}";
        if (referenceNumber === undefined || referenceNumber === null)
            throw new globalThis.Error("The parameter 'referenceNumber' must be defined.");
        url_ = url_.replace("{referenceNumber}", encodeURIComponent("" + referenceNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_GetByReference(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_GetByReference(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto>;
        }));
    }

    protected processPolicyApproval_GetByReference(response: HttpResponseBase): Observable<PolicyEnrollmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyEnrollmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    policyApproval_GetPendingApprovals(): Observable<PolicyEnrollmentDto[]> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_GetPendingApprovals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_GetPendingApprovals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_GetPendingApprovals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto[]>;
        }));
    }

    protected processPolicyApproval_GetPendingApprovals(response: HttpResponseBase): Observable<PolicyEnrollmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PolicyEnrollmentDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PolicyNumberServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    policyNumber_GetConfiguration(): Observable<PolicyNumberConfigDto> {
        let url_ = this.baseUrl + "/api/PolicyNumber/PolicyNumber_GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyNumber_GetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyNumber_GetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyNumberConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyNumberConfigDto>;
        }));
    }

    protected processPolicyNumber_GetConfiguration(response: HttpResponseBase): Observable<PolicyNumberConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyNumberConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyNumber_SaveConfiguration(body: PolicyNumberConfigDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PolicyNumber/PolicyNumber_SaveConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyNumber_SaveConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyNumber_SaveConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPolicyNumber_SaveConfiguration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyNumber_Generate(body: GeneratePolicyNumberRequestDto | undefined): Observable<GeneratePolicyNumberResponseDto> {
        let url_ = this.baseUrl + "/api/PolicyNumber/PolicyNumber_Generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyNumber_Generate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyNumber_Generate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneratePolicyNumberResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneratePolicyNumberResponseDto>;
        }));
    }

    protected processPolicyNumber_Generate(response: HttpResponseBase): Observable<GeneratePolicyNumberResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneratePolicyNumberResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyNumber_Validate(body: ValidatePolicyNumberRequestDto | undefined): Observable<ValidatePolicyNumberResponseDto> {
        let url_ = this.baseUrl + "/api/PolicyNumber/PolicyNumber_Validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyNumber_Validate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyNumber_Validate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValidatePolicyNumberResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValidatePolicyNumberResponseDto>;
        }));
    }

    protected processPolicyNumber_Validate(response: HttpResponseBase): Observable<ValidatePolicyNumberResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidatePolicyNumberResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    policyNumber_GetExampleFormat(): Observable<string> {
        let url_ = this.baseUrl + "/api/PolicyNumber/PolicyNumber_GetExampleFormat";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyNumber_GetExampleFormat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyNumber_GetExampleFormat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPolicyNumber_GetExampleFormat(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PremiumCalculationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    premiumCalculation_GetSettings(): Observable<PremiumCalculationSettingsDto> {
        let url_ = this.baseUrl + "/api/PremiumCalculation/PremiumCalculation_GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPremiumCalculation_GetSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPremiumCalculation_GetSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PremiumCalculationSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PremiumCalculationSettingsDto>;
        }));
    }

    protected processPremiumCalculation_GetSettings(response: HttpResponseBase): Observable<PremiumCalculationSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PremiumCalculationSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    premiumCalculation_SaveSettings(body: PremiumCalculationSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PremiumCalculation/PremiumCalculation_SaveSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPremiumCalculation_SaveSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPremiumCalculation_SaveSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPremiumCalculation_SaveSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    premiumCalculation_Calculate(body: CalculatePremiumRequestDto | undefined): Observable<PremiumCalculationResultDto> {
        let url_ = this.baseUrl + "/api/PremiumCalculation/PremiumCalculation_Calculate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPremiumCalculation_Calculate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPremiumCalculation_Calculate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PremiumCalculationResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PremiumCalculationResultDto>;
        }));
    }

    protected processPremiumCalculation_Calculate(response: HttpResponseBase): Observable<PremiumCalculationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PremiumCalculationResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    premiumCalculation_CalculateForMember(memberId: string): Observable<PremiumCalculationResultDto> {
        let url_ = this.baseUrl + "/api/PremiumCalculation/PremiumCalculation_CalculateForMember/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPremiumCalculation_CalculateForMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPremiumCalculation_CalculateForMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PremiumCalculationResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PremiumCalculationResultDto>;
        }));
    }

    protected processPremiumCalculation_CalculateForMember(response: HttpResponseBase): Observable<PremiumCalculationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PremiumCalculationResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    premiumCalculation_GetMyPremium(): Observable<PremiumCalculationResultDto> {
        let url_ = this.baseUrl + "/api/PremiumCalculation/PremiumCalculation_GetMyPremium";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPremiumCalculation_GetMyPremium(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPremiumCalculation_GetMyPremium(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PremiumCalculationResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PremiumCalculationResultDto>;
        }));
    }

    protected processPremiumCalculation_GetMyPremium(response: HttpResponseBase): Observable<PremiumCalculationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PremiumCalculationResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RequiredDocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    requiredDocument_GetAll(): Observable<RequiredDocumentDto[]> {
        let url_ = this.baseUrl + "/api/RequiredDocument/RequiredDocument_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequiredDocument_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequiredDocument_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequiredDocumentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequiredDocumentDto[]>;
        }));
    }

    protected processRequiredDocument_GetAll(response: HttpResponseBase): Observable<RequiredDocumentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequiredDocumentDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    requiredDocument_GetMemberStatus(memberId: string): Observable<MemberDocumentStatusDto> {
        let url_ = this.baseUrl + "/api/RequiredDocument/RequiredDocument_GetMemberStatus/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequiredDocument_GetMemberStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequiredDocument_GetMemberStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDocumentStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDocumentStatusDto>;
        }));
    }

    protected processRequiredDocument_GetMemberStatus(response: HttpResponseBase): Observable<MemberDocumentStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDocumentStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    requiredDocument_Create(body: RequiredDocumentDto | undefined): Observable<RequiredDocumentDto> {
        let url_ = this.baseUrl + "/api/RequiredDocument/RequiredDocument_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequiredDocument_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequiredDocument_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequiredDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequiredDocumentDto>;
        }));
    }

    protected processRequiredDocument_Create(response: HttpResponseBase): Observable<RequiredDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequiredDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    requiredDocument_Update(body: RequiredDocumentDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RequiredDocument/RequiredDocument_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequiredDocument_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequiredDocument_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRequiredDocument_Update(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    requiredDocument_Delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RequiredDocument/RequiredDocument_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequiredDocument_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequiredDocument_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRequiredDocument_Delete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ResourceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resource_CreateResource(body: ResourceDto | undefined): Observable<ResourceDto> {
        let url_ = this.baseUrl + "/api/Resource/Resource_CreateResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_CreateResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_CreateResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceDto>;
        }));
    }

    protected processResource_CreateResource(response: HttpResponseBase): Observable<ResourceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    resource_GetResourceById(id: string): Observable<ResourceDto> {
        let url_ = this.baseUrl + "/api/Resource/Resource_GetResourceById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_GetResourceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_GetResourceById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceDto>;
        }));
    }

    protected processResource_GetResourceById(response: HttpResponseBase): Observable<ResourceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    resource_GetAllResources(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<ResourceDto[]> {
        let url_ = this.baseUrl + "/api/Resource/Resource_GetAllResources?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_GetAllResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_GetAllResources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceDto[]>;
        }));
    }

    protected processResource_GetAllResources(response: HttpResponseBase): Observable<ResourceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResourceDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resource_UpdateResource(id: string, body: ResourceDto | undefined): Observable<ResourceDto> {
        let url_ = this.baseUrl + "/api/Resource/Resource_UpdateResource/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_UpdateResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_UpdateResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceDto>;
        }));
    }

    protected processResource_UpdateResource(response: HttpResponseBase): Observable<ResourceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    resource_DeleteResource(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Resource/Resource_DeleteResource/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_DeleteResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_DeleteResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResource_DeleteResource(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resource_BookResource(body: ResourceBookingDto | undefined): Observable<ResourceBookingDto> {
        let url_ = this.baseUrl + "/api/Resource/Resource_BookResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_BookResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_BookResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceBookingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceBookingDto>;
        }));
    }

    protected processResource_BookResource(response: HttpResponseBase): Observable<ResourceBookingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceBookingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    resource_CancelResourceBooking(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Resource/Resource_CancelResourceBooking/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_CancelResourceBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_CancelResourceBooking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResource_CancelResourceBooking(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    resource_GetResourceBookings(funeralEventId: string): Observable<ResourceBookingDto[]> {
        let url_ = this.baseUrl + "/api/Resource/Resource_GetResourceBookings/{funeralEventId}";
        if (funeralEventId === undefined || funeralEventId === null)
            throw new globalThis.Error("The parameter 'funeralEventId' must be defined.");
        url_ = url_.replace("{funeralEventId}", encodeURIComponent("" + funeralEventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_GetResourceBookings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_GetResourceBookings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceBookingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceBookingDto[]>;
        }));
    }

    protected processResource_GetResourceBookings(response: HttpResponseBase): Observable<ResourceBookingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResourceBookingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    role_GetAllRoles(): Observable<RoleDto[]> {
        let url_ = this.baseUrl + "/api/Role/Role_GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole_GetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole_GetAllRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto[]>;
        }));
    }

    protected processRole_GetAllRoles(response: HttpResponseBase): Observable<RoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    role_CreateRole(body: RoleInput | undefined): Observable<Role> {
        let url_ = this.baseUrl + "/api/Role/Role_CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole_CreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole_CreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role>;
        }));
    }

    protected processRole_CreateRole(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    role_UpdateRole(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/Role/Role_UpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole_UpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole_UpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processRole_UpdateRole(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RolePermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    rolePermission_GetAllRolePermissions(): Observable<RolePermission[]> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermission_GetAllRolePermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermission_GetAllRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermission_GetAllRolePermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RolePermission[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RolePermission[]>;
        }));
    }

    protected processRolePermission_GetAllRolePermissions(response: HttpResponseBase): Observable<RolePermission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RolePermission.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    rolePermission_CreateRolePermission(body: CreateRolePermissionDto | undefined): Observable<RolePermission> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermission_CreateRolePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermission_CreateRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermission_CreateRolePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RolePermission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RolePermission>;
        }));
    }

    protected processRolePermission_CreateRolePermission(response: HttpResponseBase): Observable<RolePermission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    rolePermission_DeleteRolePermission(roleId: string, permissionId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermission_DeleteRolePermission/{roleId}/{permissionId}";
        if (roleId === undefined || roleId === null)
            throw new globalThis.Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (permissionId === undefined || permissionId === null)
            throw new globalThis.Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermission_DeleteRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermission_DeleteRolePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRolePermission_DeleteRolePermission(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SubscriptionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    subscriptionPlan_Create(body: SubscriptionPlanDto | undefined): Observable<SubscriptionPlanDto> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/SubscriptionPlan_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionPlan_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionPlan_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanDto>;
        }));
    }

    protected processSubscriptionPlan_Create(response: HttpResponseBase): Observable<SubscriptionPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    subscriptionPlan_GetById(id: string): Observable<SubscriptionPlanDto> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/SubscriptionPlan_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionPlan_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionPlan_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanDto>;
        }));
    }

    protected processSubscriptionPlan_GetById(response: HttpResponseBase): Observable<SubscriptionPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    subscriptionPlan_GetAll(): Observable<SubscriptionPlanDto[]> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/SubscriptionPlan_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionPlan_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionPlan_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanDto[]>;
        }));
    }

    protected processSubscriptionPlan_GetAll(response: HttpResponseBase): Observable<SubscriptionPlanDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscriptionPlanDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    subscriptionPlan_Update(id: string, body: SubscriptionPlanDto | undefined): Observable<SubscriptionPlanDto> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/SubscriptionPlan_Update/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionPlan_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionPlan_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanDto>;
        }));
    }

    protected processSubscriptionPlan_Update(response: HttpResponseBase): Observable<SubscriptionPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    subscriptionPlan_Delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/SubscriptionPlan_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionPlan_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionPlan_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSubscriptionPlan_Delete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenant_RegisterTenant(body: TenantCreateUpdateDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tenant/Tenant_RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenant_RegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenant_RegisterTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTenant_RegisterTenant(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenant_GetTenantById(id: string): Observable<TenantCreateUpdateDto> {
        let url_ = this.baseUrl + "/api/Tenant/Tenant_GetTenantById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenant_GetTenantById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenant_GetTenantById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantCreateUpdateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantCreateUpdateDto>;
        }));
    }

    protected processTenant_GetTenantById(response: HttpResponseBase): Observable<TenantCreateUpdateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantCreateUpdateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenant_GetAllTenants(): Observable<TenantCreateUpdateDto[]> {
        let url_ = this.baseUrl + "/api/Tenant/Tenant_GetAllTenants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenant_GetAllTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenant_GetAllTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantCreateUpdateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantCreateUpdateDto[]>;
        }));
    }

    protected processTenant_GetAllTenants(response: HttpResponseBase): Observable<TenantCreateUpdateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantCreateUpdateDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenant_UpdateTenant(id: string, body: TenantCreateUpdateDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tenant/Tenant_UpdateTenant/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenant_UpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenant_UpdateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTenant_UpdateTenant(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenant_DeleteTenant(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tenant/Tenant_DeleteTenant/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenant_DeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenant_DeleteTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTenant_DeleteTenant(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantApprovalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    tenantApproval_GetPendingTenants(): Observable<TenantApprovalListDto[]> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_GetPendingTenants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_GetPendingTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_GetPendingTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantApprovalListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantApprovalListDto[]>;
        }));
    }

    protected processTenantApproval_GetPendingTenants(response: HttpResponseBase): Observable<TenantApprovalListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantApprovalListDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantApproval_GetAllTenantRequests(): Observable<TenantApprovalListDto[]> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_GetAllTenantRequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_GetAllTenantRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_GetAllTenantRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantApprovalListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantApprovalListDto[]>;
        }));
    }

    protected processTenantApproval_GetAllTenantRequests(response: HttpResponseBase): Observable<TenantApprovalListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantApprovalListDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantApproval_GetTenantDetail(tenantId: string): Observable<TenantApprovalDetailDto> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_GetTenantDetail/{tenantId}";
        if (tenantId === undefined || tenantId === null)
            throw new globalThis.Error("The parameter 'tenantId' must be defined.");
        url_ = url_.replace("{tenantId}", encodeURIComponent("" + tenantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_GetTenantDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_GetTenantDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantApprovalDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantApprovalDetailDto>;
        }));
    }

    protected processTenantApproval_GetTenantDetail(response: HttpResponseBase): Observable<TenantApprovalDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantApprovalDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantApproval_ApproveTenant(body: ApproveTenantDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_ApproveTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_ApproveTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_ApproveTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantApproval_ApproveTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantApproval_RejectTenant(body: RejectTenantDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_RejectTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_RejectTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_RejectTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantApproval_RejectTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantApproval_RequestChange(body: RequestTenantChangeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_RequestChange";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_RequestChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_RequestChange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantApproval_RequestChange(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class Tenant_bankingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    verify(bankingDetailId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/tenant-banking/{bankingDetailId}/verify";
        if (bankingDetailId === undefined || bankingDetailId === null)
            throw new globalThis.Error("The parameter 'bankingDetailId' must be defined.");
        url_ = url_.replace("{bankingDetailId}", encodeURIComponent("" + bankingDetailId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class Tenant_invoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param status (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    invoiceList(status: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/tenant-invoice/invoice-list?";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoiceList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    invoiceById(invoiceId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/tenant-invoice/invoice-by-id/{invoiceId}";
        if (invoiceId === undefined || invoiceId === null)
            throw new globalThis.Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoiceById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    invoiceUnpaid(): Observable<void> {
        let url_ = this.baseUrl + "/api/tenant-invoice/invoice-unpaid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceUnpaid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceUnpaid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoiceUnpaid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    invoiceSummary(): Observable<void> {
        let url_ = this.baseUrl + "/api/tenant-invoice/invoice-summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoiceSummary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param status (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    invoiceAll(tenantId: string | undefined, status: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/tenant-invoice/invoice-all?";
        if (tenantId === null)
            throw new globalThis.Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoiceAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantSettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    tenantSetting_GetById(id: string): Observable<TenantSettingDto> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingDto>;
        }));
    }

    protected processTenantSetting_GetById(response: HttpResponseBase): Observable<TenantSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantSetting_GetCurrentTenantSettings(): Observable<TenantSettingDto> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_GetCurrentTenantSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_GetCurrentTenantSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_GetCurrentTenantSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingDto>;
        }));
    }

    protected processTenantSetting_GetCurrentTenantSettings(response: HttpResponseBase): Observable<TenantSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    tenantSetting_GetAllTenantSettings(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<TenantSettingDto[]> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_GetAllTenantSettings?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_GetAllTenantSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_GetAllTenantSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingDto[]>;
        }));
    }

    protected processTenantSetting_GetAllTenantSettings(response: HttpResponseBase): Observable<TenantSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantSettingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantSetting_CreateTenantSetting(body: TenantSettingDto | undefined): Observable<TenantSettingDto> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_CreateTenantSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_CreateTenantSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_CreateTenantSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingDto>;
        }));
    }

    protected processTenantSetting_CreateTenantSetting(response: HttpResponseBase): Observable<TenantSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantSetting_UpdateTenantSetting(body: TenantSettingDto | undefined): Observable<TenantSettingDto> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_UpdateTenantSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_UpdateTenantSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_UpdateTenantSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingDto>;
        }));
    }

    protected processTenantSetting_UpdateTenantSetting(response: HttpResponseBase): Observable<TenantSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantSetting_DeleteTenantSetting(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_DeleteTenantSetting/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_DeleteTenantSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_DeleteTenantSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTenantSetting_DeleteTenantSetting(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    uploadContractTemplate(file: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSetting/upload-contract-template";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadContractTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadContractTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadContractTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    removeContractTemplate(): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSetting/remove-contract-template";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveContractTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveContractTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveContractTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TermsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    terms_GetActive(): Observable<TermsAndConditionsDto> {
        let url_ = this.baseUrl + "/api/Terms/Terms_GetActive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_GetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_GetActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TermsAndConditionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TermsAndConditionsDto>;
        }));
    }

    protected processTerms_GetActive(response: HttpResponseBase): Observable<TermsAndConditionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TermsAndConditionsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    terms_GetAll(): Observable<TermsAndConditionsDto[]> {
        let url_ = this.baseUrl + "/api/Terms/Terms_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TermsAndConditionsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TermsAndConditionsDto[]>;
        }));
    }

    protected processTerms_GetAll(response: HttpResponseBase): Observable<TermsAndConditionsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TermsAndConditionsDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    terms_Create(body: TermsAndConditionsDto | undefined): Observable<TermsAndConditionsDto> {
        let url_ = this.baseUrl + "/api/Terms/Terms_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TermsAndConditionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TermsAndConditionsDto>;
        }));
    }

    protected processTerms_Create(response: HttpResponseBase): Observable<TermsAndConditionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TermsAndConditionsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    terms_Accept(body: AcceptTermsDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Terms/Terms_Accept";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_Accept(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_Accept(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTerms_Accept(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    terms_HasAcceptedLatest(memberId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Terms/Terms_HasAcceptedLatest/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_HasAcceptedLatest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_HasAcceptedLatest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTerms_HasAcceptedLatest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    terms_GetMemberAcceptance(memberId: string): Observable<TermsAcceptanceDto> {
        let url_ = this.baseUrl + "/api/Terms/Terms_GetMemberAcceptance/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_GetMemberAcceptance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_GetMemberAcceptance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TermsAcceptanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TermsAcceptanceDto>;
        }));
    }

    protected processTerms_GetMemberAcceptance(response: HttpResponseBase): Observable<TermsAcceptanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TermsAcceptanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TimesheetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    timesheet_CreateTimesheetEntry(body: TimesheetEntryDto | undefined): Observable<TimesheetEntryDto> {
        let url_ = this.baseUrl + "/api/Timesheet/Timesheet_CreateTimesheetEntry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimesheet_CreateTimesheetEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimesheet_CreateTimesheetEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimesheetEntryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimesheetEntryDto>;
        }));
    }

    protected processTimesheet_CreateTimesheetEntry(response: HttpResponseBase): Observable<TimesheetEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimesheetEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    timesheet_GetTimesheetEntryById(id: string): Observable<TimesheetEntryDto> {
        let url_ = this.baseUrl + "/api/Timesheet/Timesheet_GetTimesheetEntryById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimesheet_GetTimesheetEntryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimesheet_GetTimesheetEntryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimesheetEntryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimesheetEntryDto>;
        }));
    }

    protected processTimesheet_GetTimesheetEntryById(response: HttpResponseBase): Observable<TimesheetEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimesheetEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    timesheet_GetMyTimesheetEntries(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<TimesheetEntryDto[]> {
        let url_ = this.baseUrl + "/api/Timesheet/Timesheet_GetMyTimesheetEntries?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimesheet_GetMyTimesheetEntries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimesheet_GetMyTimesheetEntries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimesheetEntryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimesheetEntryDto[]>;
        }));
    }

    protected processTimesheet_GetMyTimesheetEntries(response: HttpResponseBase): Observable<TimesheetEntryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimesheetEntryDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    timesheet_UpdateTimesheetEntry(id: string, body: TimesheetEntryDto | undefined): Observable<TimesheetEntryDto> {
        let url_ = this.baseUrl + "/api/Timesheet/Timesheet_UpdateTimesheetEntry/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimesheet_UpdateTimesheetEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimesheet_UpdateTimesheetEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimesheetEntryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimesheetEntryDto>;
        }));
    }

    protected processTimesheet_UpdateTimesheetEntry(response: HttpResponseBase): Observable<TimesheetEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimesheetEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    timesheet_DeleteTimesheetEntry(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Timesheet/Timesheet_DeleteTimesheetEntry/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimesheet_DeleteTimesheetEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimesheet_DeleteTimesheetEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTimesheet_DeleteTimesheetEntry(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    user_GetById(id: string | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/User/User_GetById?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUser_GetById(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    user_GetAllUsers(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/User/User_GetAllUsers?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_GetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_GetAllUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processUser_GetAllUsers(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    user_UpdateUser(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/User/User_UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_UpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_UpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUser_UpdateUser(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    user_CreateUser(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/User/User_CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_CreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_CreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUser_CreateUser(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UserDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    user_DeleteUser(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/User/User_DeleteUser/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_DeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_DeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUser_DeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    userProfile_GetCurrentUserProfile(): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_GetCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_GetCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_GetCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processUserProfile_GetCurrentUserProfile(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userProfile_UpdateCurrentUserProfile(body: UpdateUserProfileDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_UpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_UpdateCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUserProfile_UpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userProfile_VerifyIdentity(body: CreateVerificationRequestDto | undefined): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_VerifyIdentity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_VerifyIdentity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_VerifyIdentity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processUserProfile_VerifyIdentity(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    userProfile_GetVerificationStatus(): Observable<void> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_GetVerificationStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_GetVerificationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_GetVerificationStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUserProfile_GetVerificationStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    userProfile_GetVerificationHistory(): Observable<VerificationRequestDto[]> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_GetVerificationHistory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_GetVerificationHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_GetVerificationHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto[]>;
        }));
    }

    protected processUserProfile_GetVerificationHistory(response: HttpResponseBase): Observable<VerificationRequestDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationRequestDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    userProfile_QuickIdCheck(): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_QuickIdCheck";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_QuickIdCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_QuickIdCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processUserProfile_QuickIdCheck(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userProfile_CheckIdExists(body: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_CheckIdExists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_CheckIdExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_CheckIdExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUserProfile_CheckIdExists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    userRole_GetAllUserRoles(): Observable<UserRoleDto[]> {
        let url_ = this.baseUrl + "/api/UserRole/UserRole_GetAllUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRole_GetAllUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRole_GetAllUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleDto[]>;
        }));
    }

    protected processUserRole_GetAllUserRoles(response: HttpResponseBase): Observable<UserRoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRoleDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userRole_CreateUserRole(body: UserRoleInputDto | undefined): Observable<UserRoleDto> {
        let url_ = this.baseUrl + "/api/UserRole/UserRole_CreateUserRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRole_CreateUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRole_CreateUserRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleDto>;
        }));
    }

    protected processUserRole_CreateUserRole(response: HttpResponseBase): Observable<UserRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    userRole_DeleteUserRole(userRoleId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserRole/UserRole_DeleteUserRole/{userRoleId}";
        if (userRoleId === undefined || userRoleId === null)
            throw new globalThis.Error("The parameter 'userRoleId' must be defined.");
        url_ = url_.replace("{userRoleId}", encodeURIComponent("" + userRoleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRole_DeleteUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRole_DeleteUserRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUserRole_DeleteUserRole(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VerificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    verification_CreateRequest(body: CreateVerificationRequestDto | undefined): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/Verification/Verification_CreateRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_CreateRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_CreateRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processVerification_CreateRequest(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_GetRequest(id: string): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/Verification/Verification_GetRequest/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_GetRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_GetRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processVerification_GetRequest(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    verification_GetAllRequests(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<VerificationRequestDto[]> {
        let url_ = this.baseUrl + "/api/Verification/Verification_GetAllRequests?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_GetAllRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_GetAllRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto[]>;
        }));
    }

    protected processVerification_GetAllRequests(response: HttpResponseBase): Observable<VerificationRequestDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationRequestDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_ProcessRequest(id: string): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/Verification/Verification_ProcessRequest/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_ProcessRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_ProcessRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processVerification_ProcessRequest(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_GetByMember(memberId: string): Observable<VerificationRequestDto[]> {
        let url_ = this.baseUrl + "/api/Verification/Verification_GetByMember/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_GetByMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_GetByMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto[]>;
        }));
    }

    protected processVerification_GetByMember(response: HttpResponseBase): Observable<VerificationRequestDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationRequestDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_GetByClaim(claimId: string): Observable<VerificationRequestDto[]> {
        let url_ = this.baseUrl + "/api/Verification/Verification_GetByClaim/{claimId}";
        if (claimId === undefined || claimId === null)
            throw new globalThis.Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_GetByClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_GetByClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto[]>;
        }));
    }

    protected processVerification_GetByClaim(response: HttpResponseBase): Observable<VerificationRequestDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationRequestDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_CheckPersonVerified(idNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Verification/Verification_CheckPersonVerified/{idNumber}";
        if (idNumber === undefined || idNumber === null)
            throw new globalThis.Error("The parameter 'idNumber' must be defined.");
        url_ = url_.replace("{idNumber}", encodeURIComponent("" + idNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_CheckPersonVerified(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_CheckPersonVerified(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processVerification_CheckPersonVerified(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_CheckPersonAlive(idNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Verification/Verification_CheckPersonAlive/{idNumber}";
        if (idNumber === undefined || idNumber === null)
            throw new globalThis.Error("The parameter 'idNumber' must be defined.");
        url_ = url_.replace("{idNumber}", encodeURIComponent("" + idNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_CheckPersonAlive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_CheckPersonAlive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processVerification_CheckPersonAlive(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    verification_QuickIdentityCheck(body: CreateVerificationRequestDto | undefined): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/Verification/Verification_QuickIdentityCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_QuickIdentityCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_QuickIdentityCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processVerification_QuickIdentityCheck(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    verification_QuickLifeCheck(body: CreateVerificationRequestDto | undefined): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/Verification/Verification_QuickLifeCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_QuickLifeCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_QuickLifeCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processVerification_QuickLifeCheck(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AcceptTermsDto implements IAcceptTermsDto {
    memberId!: string;
    termsAndConditionsId!: string;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;

    constructor(data?: IAcceptTermsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.termsAndConditionsId = _data["termsAndConditionsId"];
            this.ipAddress = _data["ipAddress"];
            this.userAgent = _data["userAgent"];
        }
    }

    static fromJS(data: any): AcceptTermsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptTermsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["termsAndConditionsId"] = this.termsAndConditionsId;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        return data;
    }
}

export interface IAcceptTermsDto {
    memberId: string;
    termsAndConditionsId: string;
    ipAddress: string | undefined;
    userAgent: string | undefined;
}

export class ApproveEnrollmentDto implements IApproveEnrollmentDto {
    notes!: string | undefined;

    constructor(data?: IApproveEnrollmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ApproveEnrollmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveEnrollmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notes"] = this.notes;
        return data;
    }
}

export interface IApproveEnrollmentDto {
    notes: string | undefined;
}

export class ApproveMemberRequest implements IApproveMemberRequest {
    memberId!: string;
    approvalNotes!: string | undefined;

    constructor(data?: IApproveMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.approvalNotes = _data["approvalNotes"];
        }
    }

    static fromJS(data: any): ApproveMemberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["approvalNotes"] = this.approvalNotes;
        return data;
    }
}

export interface IApproveMemberRequest {
    memberId: string;
    approvalNotes: string | undefined;
}

export class ApproveTenantDto implements IApproveTenantDto {
    tenantId!: string;

    constructor(data?: IApproveTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): ApproveTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IApproveTenantDto {
    tenantId: string;
}

export class AssetCheckoutDto implements IAssetCheckoutDto {
    id!: string;
    assetId!: string;
    assetName!: string | undefined;
    assetIdentificationNumber!: string | undefined;
    checkedOutByUserId!: string;
    checkedOutByName!: string | undefined;
    checkedOutByRole!: string | undefined;
    checkoutDate!: DateTime;
    expectedReturnDate!: DateTime | undefined;
    purpose!: string | undefined;
    destination!: string | undefined;
    startingOdometer!: number | undefined;
    endingOdometer!: number | undefined;
    fuelLevelCheckout!: number | undefined;
    fuelLevelCheckin!: number | undefined;
    status!: CheckoutStatus;
    readonly statusName!: string | undefined;
    checkinDate!: DateTime | undefined;
    checkedInByUserId!: string | undefined;
    checkedInByName!: string | undefined;
    checkoutNotes!: string | undefined;
    checkinNotes!: string | undefined;
    returnedInGoodCondition!: boolean | undefined;
    damageReported!: string | undefined;
    readonly isOverdue!: boolean;
    createdAt!: DateTime;

    constructor(data?: IAssetCheckoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetId = _data["assetId"];
            this.assetName = _data["assetName"];
            this.assetIdentificationNumber = _data["assetIdentificationNumber"];
            this.checkedOutByUserId = _data["checkedOutByUserId"];
            this.checkedOutByName = _data["checkedOutByName"];
            this.checkedOutByRole = _data["checkedOutByRole"];
            this.checkoutDate = _data["checkoutDate"] ? DateTime.fromISO(_data["checkoutDate"].toString()) : undefined as any;
            this.expectedReturnDate = _data["expectedReturnDate"] ? DateTime.fromISO(_data["expectedReturnDate"].toString()) : undefined as any;
            this.purpose = _data["purpose"];
            this.destination = _data["destination"];
            this.startingOdometer = _data["startingOdometer"];
            this.endingOdometer = _data["endingOdometer"];
            this.fuelLevelCheckout = _data["fuelLevelCheckout"];
            this.fuelLevelCheckin = _data["fuelLevelCheckin"];
            this.status = _data["status"];
            (this as any).statusName = _data["statusName"];
            this.checkinDate = _data["checkinDate"] ? DateTime.fromISO(_data["checkinDate"].toString()) : undefined as any;
            this.checkedInByUserId = _data["checkedInByUserId"];
            this.checkedInByName = _data["checkedInByName"];
            this.checkoutNotes = _data["checkoutNotes"];
            this.checkinNotes = _data["checkinNotes"];
            this.returnedInGoodCondition = _data["returnedInGoodCondition"];
            this.damageReported = _data["damageReported"];
            (this as any).isOverdue = _data["isOverdue"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): AssetCheckoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCheckoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetId"] = this.assetId;
        data["assetName"] = this.assetName;
        data["assetIdentificationNumber"] = this.assetIdentificationNumber;
        data["checkedOutByUserId"] = this.checkedOutByUserId;
        data["checkedOutByName"] = this.checkedOutByName;
        data["checkedOutByRole"] = this.checkedOutByRole;
        data["checkoutDate"] = this.checkoutDate ? this.checkoutDate.toString() : undefined as any;
        data["expectedReturnDate"] = this.expectedReturnDate ? this.expectedReturnDate.toString() : undefined as any;
        data["purpose"] = this.purpose;
        data["destination"] = this.destination;
        data["startingOdometer"] = this.startingOdometer;
        data["endingOdometer"] = this.endingOdometer;
        data["fuelLevelCheckout"] = this.fuelLevelCheckout;
        data["fuelLevelCheckin"] = this.fuelLevelCheckin;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["checkinDate"] = this.checkinDate ? this.checkinDate.toString() : undefined as any;
        data["checkedInByUserId"] = this.checkedInByUserId;
        data["checkedInByName"] = this.checkedInByName;
        data["checkoutNotes"] = this.checkoutNotes;
        data["checkinNotes"] = this.checkinNotes;
        data["returnedInGoodCondition"] = this.returnedInGoodCondition;
        data["damageReported"] = this.damageReported;
        data["isOverdue"] = this.isOverdue;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        return data;
    }
}

export interface IAssetCheckoutDto {
    id: string;
    assetId: string;
    assetName: string | undefined;
    assetIdentificationNumber: string | undefined;
    checkedOutByUserId: string;
    checkedOutByName: string | undefined;
    checkedOutByRole: string | undefined;
    checkoutDate: DateTime;
    expectedReturnDate: DateTime | undefined;
    purpose: string | undefined;
    destination: string | undefined;
    startingOdometer: number | undefined;
    endingOdometer: number | undefined;
    fuelLevelCheckout: number | undefined;
    fuelLevelCheckin: number | undefined;
    status: CheckoutStatus;
    statusName: string | undefined;
    checkinDate: DateTime | undefined;
    checkedInByUserId: string | undefined;
    checkedInByName: string | undefined;
    checkoutNotes: string | undefined;
    checkinNotes: string | undefined;
    returnedInGoodCondition: boolean | undefined;
    damageReported: string | undefined;
    isOverdue: boolean;
    createdAt: DateTime;
}

export class AssetDto implements IAssetDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    assetType!: AssetType;
    readonly assetTypeName!: string | undefined;
    status!: AssetStatus;
    readonly statusName!: string | undefined;
    identificationNumber!: string | undefined;
    make!: string | undefined;
    model!: string | undefined;
    year!: number | undefined;
    quantity!: number;
    currentLocation!: string | undefined;
    requiresInspection!: boolean;
    inspectionCheckpoints!: string[] | undefined;
    lastMaintenanceDate!: DateTime | undefined;
    nextMaintenanceDate!: DateTime | undefined;
    purchaseDate!: DateTime | undefined;
    purchaseCost!: number | undefined;
    conditionNotes!: string | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime | undefined;

    constructor(data?: IAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.assetType = _data["assetType"];
            (this as any).assetTypeName = _data["assetTypeName"];
            this.status = _data["status"];
            (this as any).statusName = _data["statusName"];
            this.identificationNumber = _data["identificationNumber"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.year = _data["year"];
            this.quantity = _data["quantity"];
            this.currentLocation = _data["currentLocation"];
            this.requiresInspection = _data["requiresInspection"];
            if (Array.isArray(_data["inspectionCheckpoints"])) {
                this.inspectionCheckpoints = [] as any;
                for (let item of _data["inspectionCheckpoints"])
                    this.inspectionCheckpoints!.push(item);
            }
            this.lastMaintenanceDate = _data["lastMaintenanceDate"] ? DateTime.fromISO(_data["lastMaintenanceDate"].toString()) : undefined as any;
            this.nextMaintenanceDate = _data["nextMaintenanceDate"] ? DateTime.fromISO(_data["nextMaintenanceDate"].toString()) : undefined as any;
            this.purchaseDate = _data["purchaseDate"] ? DateTime.fromISO(_data["purchaseDate"].toString()) : undefined as any;
            this.purchaseCost = _data["purchaseCost"];
            this.conditionNotes = _data["conditionNotes"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): AssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["assetType"] = this.assetType;
        data["assetTypeName"] = this.assetTypeName;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["identificationNumber"] = this.identificationNumber;
        data["make"] = this.make;
        data["model"] = this.model;
        data["year"] = this.year;
        data["quantity"] = this.quantity;
        data["currentLocation"] = this.currentLocation;
        data["requiresInspection"] = this.requiresInspection;
        if (Array.isArray(this.inspectionCheckpoints)) {
            data["inspectionCheckpoints"] = [];
            for (let item of this.inspectionCheckpoints)
                data["inspectionCheckpoints"].push(item);
        }
        data["lastMaintenanceDate"] = this.lastMaintenanceDate ? this.lastMaintenanceDate.toString() : undefined as any;
        data["nextMaintenanceDate"] = this.nextMaintenanceDate ? this.nextMaintenanceDate.toString() : undefined as any;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toString() : undefined as any;
        data["purchaseCost"] = this.purchaseCost;
        data["conditionNotes"] = this.conditionNotes;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IAssetDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    assetType: AssetType;
    assetTypeName: string | undefined;
    status: AssetStatus;
    statusName: string | undefined;
    identificationNumber: string | undefined;
    make: string | undefined;
    model: string | undefined;
    year: number | undefined;
    quantity: number;
    currentLocation: string | undefined;
    requiresInspection: boolean;
    inspectionCheckpoints: string[] | undefined;
    lastMaintenanceDate: DateTime | undefined;
    nextMaintenanceDate: DateTime | undefined;
    purchaseDate: DateTime | undefined;
    purchaseCost: number | undefined;
    conditionNotes: string | undefined;
    createdAt: DateTime;
    updatedAt: DateTime | undefined;
}

export class AssetInspectionLogDto implements IAssetInspectionLogDto {
    id!: string;
    assetId!: string;
    assetName!: string | undefined;
    checkoutId!: string | undefined;
    inspectionType!: InspectionType;
    readonly inspectionTypeName!: string | undefined;
    inspectionDate!: DateTime;
    inspectedByUserId!: string;
    inspectedByName!: string | undefined;
    checkpoints!: InspectionCheckpoint[] | undefined;
    overallResult!: InspectionResult;
    readonly overallResultName!: string | undefined;
    notes!: string | undefined;
    attachments!: string[] | undefined;
    issuesFound!: boolean;
    issueDescription!: string | undefined;
    inspectorSignature!: string | undefined;
    createdAt!: DateTime;

    constructor(data?: IAssetInspectionLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetId = _data["assetId"];
            this.assetName = _data["assetName"];
            this.checkoutId = _data["checkoutId"];
            this.inspectionType = _data["inspectionType"];
            (this as any).inspectionTypeName = _data["inspectionTypeName"];
            this.inspectionDate = _data["inspectionDate"] ? DateTime.fromISO(_data["inspectionDate"].toString()) : undefined as any;
            this.inspectedByUserId = _data["inspectedByUserId"];
            this.inspectedByName = _data["inspectedByName"];
            if (Array.isArray(_data["checkpoints"])) {
                this.checkpoints = [] as any;
                for (let item of _data["checkpoints"])
                    this.checkpoints!.push(InspectionCheckpoint.fromJS(item));
            }
            this.overallResult = _data["overallResult"];
            (this as any).overallResultName = _data["overallResultName"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(item);
            }
            this.issuesFound = _data["issuesFound"];
            this.issueDescription = _data["issueDescription"];
            this.inspectorSignature = _data["inspectorSignature"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): AssetInspectionLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetInspectionLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetId"] = this.assetId;
        data["assetName"] = this.assetName;
        data["checkoutId"] = this.checkoutId;
        data["inspectionType"] = this.inspectionType;
        data["inspectionTypeName"] = this.inspectionTypeName;
        data["inspectionDate"] = this.inspectionDate ? this.inspectionDate.toString() : undefined as any;
        data["inspectedByUserId"] = this.inspectedByUserId;
        data["inspectedByName"] = this.inspectedByName;
        if (Array.isArray(this.checkpoints)) {
            data["checkpoints"] = [];
            for (let item of this.checkpoints)
                data["checkpoints"].push(item ? item.toJSON() : undefined as any);
        }
        data["overallResult"] = this.overallResult;
        data["overallResultName"] = this.overallResultName;
        data["notes"] = this.notes;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item);
        }
        data["issuesFound"] = this.issuesFound;
        data["issueDescription"] = this.issueDescription;
        data["inspectorSignature"] = this.inspectorSignature;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        return data;
    }
}

export interface IAssetInspectionLogDto {
    id: string;
    assetId: string;
    assetName: string | undefined;
    checkoutId: string | undefined;
    inspectionType: InspectionType;
    inspectionTypeName: string | undefined;
    inspectionDate: DateTime;
    inspectedByUserId: string;
    inspectedByName: string | undefined;
    checkpoints: InspectionCheckpoint[] | undefined;
    overallResult: InspectionResult;
    overallResultName: string | undefined;
    notes: string | undefined;
    attachments: string[] | undefined;
    issuesFound: boolean;
    issueDescription: string | undefined;
    inspectorSignature: string | undefined;
    createdAt: DateTime;
}

export class AssetStatsDto implements IAssetStatsDto {
    totalAssets!: number;
    availableAssets!: number;
    checkedOutAssets!: number;
    underMaintenanceAssets!: number;
    overdueCheckouts!: number;
    assetsByType!: { [key: string]: number; } | undefined;
    recentCheckouts!: AssetCheckoutDto[] | undefined;
    assetsNeedingMaintenance!: AssetDto[] | undefined;

    constructor(data?: IAssetStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalAssets = _data["totalAssets"];
            this.availableAssets = _data["availableAssets"];
            this.checkedOutAssets = _data["checkedOutAssets"];
            this.underMaintenanceAssets = _data["underMaintenanceAssets"];
            this.overdueCheckouts = _data["overdueCheckouts"];
            if (_data["assetsByType"]) {
                this.assetsByType = {} as any;
                for (let key in _data["assetsByType"]) {
                    if (_data["assetsByType"].hasOwnProperty(key))
                        (this.assetsByType as any)![key] = _data["assetsByType"][key];
                }
            }
            if (Array.isArray(_data["recentCheckouts"])) {
                this.recentCheckouts = [] as any;
                for (let item of _data["recentCheckouts"])
                    this.recentCheckouts!.push(AssetCheckoutDto.fromJS(item));
            }
            if (Array.isArray(_data["assetsNeedingMaintenance"])) {
                this.assetsNeedingMaintenance = [] as any;
                for (let item of _data["assetsNeedingMaintenance"])
                    this.assetsNeedingMaintenance!.push(AssetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssetStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalAssets"] = this.totalAssets;
        data["availableAssets"] = this.availableAssets;
        data["checkedOutAssets"] = this.checkedOutAssets;
        data["underMaintenanceAssets"] = this.underMaintenanceAssets;
        data["overdueCheckouts"] = this.overdueCheckouts;
        if (this.assetsByType) {
            data["assetsByType"] = {};
            for (let key in this.assetsByType) {
                if (this.assetsByType.hasOwnProperty(key))
                    (data["assetsByType"] as any)[key] = (this.assetsByType as any)[key];
            }
        }
        if (Array.isArray(this.recentCheckouts)) {
            data["recentCheckouts"] = [];
            for (let item of this.recentCheckouts)
                data["recentCheckouts"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.assetsNeedingMaintenance)) {
            data["assetsNeedingMaintenance"] = [];
            for (let item of this.assetsNeedingMaintenance)
                data["assetsNeedingMaintenance"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IAssetStatsDto {
    totalAssets: number;
    availableAssets: number;
    checkedOutAssets: number;
    underMaintenanceAssets: number;
    overdueCheckouts: number;
    assetsByType: { [key: string]: number; } | undefined;
    recentCheckouts: AssetCheckoutDto[] | undefined;
    assetsNeedingMaintenance: AssetDto[] | undefined;
}

export enum AssetStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum AssetType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class AuthResult implements IAuthResult {
    succeeded!: boolean;
    message!: string | undefined;
    token!: string | undefined;
    refreshToken!: string | undefined;
    expiresAt!: DateTime | undefined;
    mustChangePassword!: boolean;

    constructor(data?: IAuthResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            this.expiresAt = _data["expiresAt"] ? DateTime.fromISO(_data["expiresAt"].toString()) : undefined as any;
            this.mustChangePassword = _data["mustChangePassword"];
        }
    }

    static fromJS(data: any): AuthResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toString() : undefined as any;
        data["mustChangePassword"] = this.mustChangePassword;
        return data;
    }
}

export interface IAuthResult {
    succeeded: boolean;
    message: string | undefined;
    token: string | undefined;
    refreshToken: string | undefined;
    expiresAt: DateTime | undefined;
    mustChangePassword: boolean;
}

export class BeneficiaryDto implements IBeneficiaryDto {
    id!: string;
    memberId!: string;
    name!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    identificationNumber!: string | undefined;
    relationship!: string | undefined;
    benefitPercentage!: number | undefined;

    constructor(data?: IBeneficiaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.identificationNumber = _data["identificationNumber"];
            this.relationship = _data["relationship"];
            this.benefitPercentage = _data["benefitPercentage"];
        }
    }

    static fromJS(data: any): BeneficiaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["identificationNumber"] = this.identificationNumber;
        data["relationship"] = this.relationship;
        data["benefitPercentage"] = this.benefitPercentage;
        return data;
    }
}

export interface IBeneficiaryDto {
    id: string;
    memberId: string;
    name: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    identificationNumber: string | undefined;
    relationship: string | undefined;
    benefitPercentage: number | undefined;
}

export class BeneficiaryInfoDto implements IBeneficiaryInfoDto {
    id!: string;
    age!: number;
    dateOfBirth!: DateTime;
    firstName!: string | undefined;
    lastName!: string | undefined;

    constructor(data?: IBeneficiaryInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.age = _data["age"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): BeneficiaryInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiaryInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["age"] = this.age;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IBeneficiaryInfoDto {
    id: string;
    age: number;
    dateOfBirth: DateTime;
    firstName: string | undefined;
    lastName: string | undefined;
}

export class BeneficiarySummary implements IBeneficiarySummary {
    id!: string;
    name!: string | undefined;
    relationship!: string | undefined;
    allocationPercentage!: number | undefined;

    constructor(data?: IBeneficiarySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.relationship = _data["relationship"];
            this.allocationPercentage = _data["allocationPercentage"];
        }
    }

    static fromJS(data: any): BeneficiarySummary {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiarySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["relationship"] = this.relationship;
        data["allocationPercentage"] = this.allocationPercentage;
        return data;
    }
}

export interface IBeneficiarySummary {
    id: string;
    name: string | undefined;
    relationship: string | undefined;
    allocationPercentage: number | undefined;
}

export class CalculatePremiumRequestDto implements ICalculatePremiumRequestDto {
    coverAmount!: number;
    dependents!: DependentInfoDto[] | undefined;
    beneficiaries!: BeneficiaryInfoDto[] | undefined;

    constructor(data?: ICalculatePremiumRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coverAmount = _data["coverAmount"];
            if (Array.isArray(_data["dependents"])) {
                this.dependents = [] as any;
                for (let item of _data["dependents"])
                    this.dependents!.push(DependentInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["beneficiaries"])) {
                this.beneficiaries = [] as any;
                for (let item of _data["beneficiaries"])
                    this.beneficiaries!.push(BeneficiaryInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CalculatePremiumRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalculatePremiumRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coverAmount"] = this.coverAmount;
        if (Array.isArray(this.dependents)) {
            data["dependents"] = [];
            for (let item of this.dependents)
                data["dependents"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.beneficiaries)) {
            data["beneficiaries"] = [];
            for (let item of this.beneficiaries)
                data["beneficiaries"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICalculatePremiumRequestDto {
    coverAmount: number;
    dependents: DependentInfoDto[] | undefined;
    beneficiaries: BeneficiaryInfoDto[] | undefined;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    currentPassword!: string;
    newPassword!: string;
    confirmPassword!: string;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IChangePasswordRequest {
    currentPassword: string;
    newPassword: string;
    confirmPassword: string;
}

export class CheckIdNumberDto implements ICheckIdNumberDto {
    idNumber!: string;

    constructor(data?: ICheckIdNumberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
        }
    }

    static fromJS(data: any): CheckIdNumberDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckIdNumberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        return data;
    }
}

export interface ICheckIdNumberDto {
    idNumber: string;
}

export class CheckIdNumberResponseDto implements ICheckIdNumberResponseDto {
    exists!: boolean;
    isMainMember!: boolean;
    hasUserAccount!: boolean;
    memberId!: string | undefined;
    memberName!: string | undefined;
    contactEmail!: string | undefined;
    contactPhone!: string | undefined;
    message!: string | undefined;

    constructor(data?: ICheckIdNumberResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exists = _data["exists"];
            this.isMainMember = _data["isMainMember"];
            this.hasUserAccount = _data["hasUserAccount"];
            this.memberId = _data["memberId"];
            this.memberName = _data["memberName"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CheckIdNumberResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckIdNumberResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exists"] = this.exists;
        data["isMainMember"] = this.isMainMember;
        data["hasUserAccount"] = this.hasUserAccount;
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["message"] = this.message;
        return data;
    }
}

export interface ICheckIdNumberResponseDto {
    exists: boolean;
    isMainMember: boolean;
    hasUserAccount: boolean;
    memberId: string | undefined;
    memberName: string | undefined;
    contactEmail: string | undefined;
    contactPhone: string | undefined;
    message: string | undefined;
}

export class CheckinAssetDto implements ICheckinAssetDto {
    checkoutId!: string;
    endingOdometer!: number | undefined;
    fuelLevelCheckin!: number | undefined;
    returnedInGoodCondition!: boolean;
    damageReported!: string | undefined;
    checkinNotes!: string | undefined;
    checkinInspection!: InspectionLogDto;

    constructor(data?: ICheckinAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkoutId = _data["checkoutId"];
            this.endingOdometer = _data["endingOdometer"];
            this.fuelLevelCheckin = _data["fuelLevelCheckin"];
            this.returnedInGoodCondition = _data["returnedInGoodCondition"];
            this.damageReported = _data["damageReported"];
            this.checkinNotes = _data["checkinNotes"];
            this.checkinInspection = _data["checkinInspection"] ? InspectionLogDto.fromJS(_data["checkinInspection"]) : undefined as any;
        }
    }

    static fromJS(data: any): CheckinAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckinAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkoutId"] = this.checkoutId;
        data["endingOdometer"] = this.endingOdometer;
        data["fuelLevelCheckin"] = this.fuelLevelCheckin;
        data["returnedInGoodCondition"] = this.returnedInGoodCondition;
        data["damageReported"] = this.damageReported;
        data["checkinNotes"] = this.checkinNotes;
        data["checkinInspection"] = this.checkinInspection ? this.checkinInspection.toJSON() : undefined as any;
        return data;
    }
}

export interface ICheckinAssetDto {
    checkoutId: string;
    endingOdometer: number | undefined;
    fuelLevelCheckin: number | undefined;
    returnedInGoodCondition: boolean;
    damageReported: string | undefined;
    checkinNotes: string | undefined;
    checkinInspection: InspectionLogDto;
}

export class CheckoutAssetDto implements ICheckoutAssetDto {
    assetId!: string;
    expectedReturnDate!: DateTime | undefined;
    purpose!: string | undefined;
    destination!: string | undefined;
    startingOdometer!: number | undefined;
    fuelLevelCheckout!: number | undefined;
    checkoutNotes!: string | undefined;
    checkoutInspection!: InspectionLogDto;

    constructor(data?: ICheckoutAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetId = _data["assetId"];
            this.expectedReturnDate = _data["expectedReturnDate"] ? DateTime.fromISO(_data["expectedReturnDate"].toString()) : undefined as any;
            this.purpose = _data["purpose"];
            this.destination = _data["destination"];
            this.startingOdometer = _data["startingOdometer"];
            this.fuelLevelCheckout = _data["fuelLevelCheckout"];
            this.checkoutNotes = _data["checkoutNotes"];
            this.checkoutInspection = _data["checkoutInspection"] ? InspectionLogDto.fromJS(_data["checkoutInspection"]) : undefined as any;
        }
    }

    static fromJS(data: any): CheckoutAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckoutAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetId"] = this.assetId;
        data["expectedReturnDate"] = this.expectedReturnDate ? this.expectedReturnDate.toString() : undefined as any;
        data["purpose"] = this.purpose;
        data["destination"] = this.destination;
        data["startingOdometer"] = this.startingOdometer;
        data["fuelLevelCheckout"] = this.fuelLevelCheckout;
        data["checkoutNotes"] = this.checkoutNotes;
        data["checkoutInspection"] = this.checkoutInspection ? this.checkoutInspection.toJSON() : undefined as any;
        return data;
    }
}

export interface ICheckoutAssetDto {
    assetId: string;
    expectedReturnDate: DateTime | undefined;
    purpose: string | undefined;
    destination: string | undefined;
    startingOdometer: number | undefined;
    fuelLevelCheckout: number | undefined;
    checkoutNotes: string | undefined;
    checkoutInspection: InspectionLogDto;
}

export enum CheckoutStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum CheckpointStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ClaimDto implements IClaimDto {
    id!: string;
    memberId!: string;
    policyId!: string;
    claimAmount!: number;
    claimDate!: DateTime;
    status!: string | undefined;
    description!: string | undefined;

    constructor(data?: IClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.policyId = _data["policyId"];
            this.claimAmount = _data["claimAmount"];
            this.claimDate = _data["claimDate"] ? DateTime.fromISO(_data["claimDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["policyId"] = this.policyId;
        data["claimAmount"] = this.claimAmount;
        data["claimDate"] = this.claimDate ? this.claimDate.toString() : undefined as any;
        data["status"] = this.status;
        data["description"] = this.description;
        return data;
    }
}

export interface IClaimDto {
    id: string;
    memberId: string;
    policyId: string;
    claimAmount: number;
    claimDate: DateTime;
    status: string | undefined;
    description: string | undefined;
}

export class ClaimEligibilityCheckDto implements IClaimEligibilityCheckDto {
    memberId!: string;
    policyId!: string;
    claimType!: ClaimType;
    claimantType!: ClaimantType;
    beneficiaryId!: string | undefined;
    requestingUserId!: string;
    notes!: string | undefined;

    constructor(data?: IClaimEligibilityCheckDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.policyId = _data["policyId"];
            this.claimType = _data["claimType"];
            this.claimantType = _data["claimantType"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.requestingUserId = _data["requestingUserId"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ClaimEligibilityCheckDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimEligibilityCheckDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["policyId"] = this.policyId;
        data["claimType"] = this.claimType;
        data["claimantType"] = this.claimantType;
        data["beneficiaryId"] = this.beneficiaryId;
        data["requestingUserId"] = this.requestingUserId;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IClaimEligibilityCheckDto {
    memberId: string;
    policyId: string;
    claimType: ClaimType;
    claimantType: ClaimantType;
    beneficiaryId: string | undefined;
    requestingUserId: string;
    notes: string | undefined;
}

export class ClaimEligibilityResultDto implements IClaimEligibilityResultDto {
    isEligible!: boolean;
    message!: string | undefined;
    requirements!: string[] | undefined;
    warnings!: string[] | undefined;
    requiredDocuments!: string[] | undefined;
    isPolicyActive!: boolean;
    isWaitingPeriodSatisfied!: boolean;
    arePremiumsCurrent!: boolean;
    maxClaimAmount!: number;
    outstandingPremiums!: number;
    isClaimantAuthorized!: boolean;
    requiresAdditionalVerification!: boolean;
    authorizationNotes!: string | undefined;
    isDeceasedCovered!: boolean;
    coverageType!: string | undefined;
    coverageAmount!: number;
    exclusions!: string[] | undefined;
    expectedProcessingTime!: string | undefined;
    requiresManagerApproval!: boolean;
    priority!: number;

    constructor(data?: IClaimEligibilityResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEligible = _data["isEligible"];
            this.message = _data["message"];
            if (Array.isArray(_data["requirements"])) {
                this.requirements = [] as any;
                for (let item of _data["requirements"])
                    this.requirements!.push(item);
            }
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
            if (Array.isArray(_data["requiredDocuments"])) {
                this.requiredDocuments = [] as any;
                for (let item of _data["requiredDocuments"])
                    this.requiredDocuments!.push(item);
            }
            this.isPolicyActive = _data["isPolicyActive"];
            this.isWaitingPeriodSatisfied = _data["isWaitingPeriodSatisfied"];
            this.arePremiumsCurrent = _data["arePremiumsCurrent"];
            this.maxClaimAmount = _data["maxClaimAmount"];
            this.outstandingPremiums = _data["outstandingPremiums"];
            this.isClaimantAuthorized = _data["isClaimantAuthorized"];
            this.requiresAdditionalVerification = _data["requiresAdditionalVerification"];
            this.authorizationNotes = _data["authorizationNotes"];
            this.isDeceasedCovered = _data["isDeceasedCovered"];
            this.coverageType = _data["coverageType"];
            this.coverageAmount = _data["coverageAmount"];
            if (Array.isArray(_data["exclusions"])) {
                this.exclusions = [] as any;
                for (let item of _data["exclusions"])
                    this.exclusions!.push(item);
            }
            this.expectedProcessingTime = _data["expectedProcessingTime"];
            this.requiresManagerApproval = _data["requiresManagerApproval"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): ClaimEligibilityResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimEligibilityResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEligible"] = this.isEligible;
        data["message"] = this.message;
        if (Array.isArray(this.requirements)) {
            data["requirements"] = [];
            for (let item of this.requirements)
                data["requirements"].push(item);
        }
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        if (Array.isArray(this.requiredDocuments)) {
            data["requiredDocuments"] = [];
            for (let item of this.requiredDocuments)
                data["requiredDocuments"].push(item);
        }
        data["isPolicyActive"] = this.isPolicyActive;
        data["isWaitingPeriodSatisfied"] = this.isWaitingPeriodSatisfied;
        data["arePremiumsCurrent"] = this.arePremiumsCurrent;
        data["maxClaimAmount"] = this.maxClaimAmount;
        data["outstandingPremiums"] = this.outstandingPremiums;
        data["isClaimantAuthorized"] = this.isClaimantAuthorized;
        data["requiresAdditionalVerification"] = this.requiresAdditionalVerification;
        data["authorizationNotes"] = this.authorizationNotes;
        data["isDeceasedCovered"] = this.isDeceasedCovered;
        data["coverageType"] = this.coverageType;
        data["coverageAmount"] = this.coverageAmount;
        if (Array.isArray(this.exclusions)) {
            data["exclusions"] = [];
            for (let item of this.exclusions)
                data["exclusions"].push(item);
        }
        data["expectedProcessingTime"] = this.expectedProcessingTime;
        data["requiresManagerApproval"] = this.requiresManagerApproval;
        data["priority"] = this.priority;
        return data;
    }
}

export interface IClaimEligibilityResultDto {
    isEligible: boolean;
    message: string | undefined;
    requirements: string[] | undefined;
    warnings: string[] | undefined;
    requiredDocuments: string[] | undefined;
    isPolicyActive: boolean;
    isWaitingPeriodSatisfied: boolean;
    arePremiumsCurrent: boolean;
    maxClaimAmount: number;
    outstandingPremiums: number;
    isClaimantAuthorized: boolean;
    requiresAdditionalVerification: boolean;
    authorizationNotes: string | undefined;
    isDeceasedCovered: boolean;
    coverageType: string | undefined;
    coverageAmount: number;
    exclusions: string[] | undefined;
    expectedProcessingTime: string | undefined;
    requiresManagerApproval: boolean;
    priority: number;
}

export class ClaimProcessStepDto implements IClaimProcessStepDto {
    stepNumber!: number;
    stepName!: string | undefined;
    description!: string | undefined;
    status!: string | undefined;
    isRequired!: boolean;
    completedAt!: DateTime | undefined;
    completedBy!: string | undefined;
    notes!: string | undefined;
    requiredActions!: string[] | undefined;
    requiredDocuments!: string[] | undefined;

    constructor(data?: IClaimProcessStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepNumber = _data["stepNumber"];
            this.stepName = _data["stepName"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.isRequired = _data["isRequired"];
            this.completedAt = _data["completedAt"] ? DateTime.fromISO(_data["completedAt"].toString()) : undefined as any;
            this.completedBy = _data["completedBy"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["requiredActions"])) {
                this.requiredActions = [] as any;
                for (let item of _data["requiredActions"])
                    this.requiredActions!.push(item);
            }
            if (Array.isArray(_data["requiredDocuments"])) {
                this.requiredDocuments = [] as any;
                for (let item of _data["requiredDocuments"])
                    this.requiredDocuments!.push(item);
            }
        }
    }

    static fromJS(data: any): ClaimProcessStepDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimProcessStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stepNumber"] = this.stepNumber;
        data["stepName"] = this.stepName;
        data["description"] = this.description;
        data["status"] = this.status;
        data["isRequired"] = this.isRequired;
        data["completedAt"] = this.completedAt ? this.completedAt.toString() : undefined as any;
        data["completedBy"] = this.completedBy;
        data["notes"] = this.notes;
        if (Array.isArray(this.requiredActions)) {
            data["requiredActions"] = [];
            for (let item of this.requiredActions)
                data["requiredActions"].push(item);
        }
        if (Array.isArray(this.requiredDocuments)) {
            data["requiredDocuments"] = [];
            for (let item of this.requiredDocuments)
                data["requiredDocuments"].push(item);
        }
        return data;
    }
}

export interface IClaimProcessStepDto {
    stepNumber: number;
    stepName: string | undefined;
    description: string | undefined;
    status: string | undefined;
    isRequired: boolean;
    completedAt: DateTime | undefined;
    completedBy: string | undefined;
    notes: string | undefined;
    requiredActions: string[] | undefined;
    requiredDocuments: string[] | undefined;
}

export class ClaimProcessTrackingDto implements IClaimProcessTrackingDto {
    claimId!: string;
    currentStatus!: string | undefined;
    currentStepName!: string | undefined;
    currentStepNumber!: number;
    totalSteps!: number;
    percentageComplete!: number;
    lastUpdated!: DateTime;
    nextAction!: string | undefined;
    expectedCompletionDate!: DateTime | undefined;
    steps!: ClaimProcessStepDto[] | undefined;
    lastContactDate!: DateTime | undefined;
    lastContactMethod!: string | undefined;
    nextFollowUpDate!: DateTime | undefined;
    requiresClaimantAction!: boolean;
    pendingRequirements!: string[] | undefined;

    constructor(data?: IClaimProcessTrackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claimId = _data["claimId"];
            this.currentStatus = _data["currentStatus"];
            this.currentStepName = _data["currentStepName"];
            this.currentStepNumber = _data["currentStepNumber"];
            this.totalSteps = _data["totalSteps"];
            this.percentageComplete = _data["percentageComplete"];
            this.lastUpdated = _data["lastUpdated"] ? DateTime.fromISO(_data["lastUpdated"].toString()) : undefined as any;
            this.nextAction = _data["nextAction"];
            this.expectedCompletionDate = _data["expectedCompletionDate"] ? DateTime.fromISO(_data["expectedCompletionDate"].toString()) : undefined as any;
            if (Array.isArray(_data["steps"])) {
                this.steps = [] as any;
                for (let item of _data["steps"])
                    this.steps!.push(ClaimProcessStepDto.fromJS(item));
            }
            this.lastContactDate = _data["lastContactDate"] ? DateTime.fromISO(_data["lastContactDate"].toString()) : undefined as any;
            this.lastContactMethod = _data["lastContactMethod"];
            this.nextFollowUpDate = _data["nextFollowUpDate"] ? DateTime.fromISO(_data["nextFollowUpDate"].toString()) : undefined as any;
            this.requiresClaimantAction = _data["requiresClaimantAction"];
            if (Array.isArray(_data["pendingRequirements"])) {
                this.pendingRequirements = [] as any;
                for (let item of _data["pendingRequirements"])
                    this.pendingRequirements!.push(item);
            }
        }
    }

    static fromJS(data: any): ClaimProcessTrackingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimProcessTrackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claimId"] = this.claimId;
        data["currentStatus"] = this.currentStatus;
        data["currentStepName"] = this.currentStepName;
        data["currentStepNumber"] = this.currentStepNumber;
        data["totalSteps"] = this.totalSteps;
        data["percentageComplete"] = this.percentageComplete;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toString() : undefined as any;
        data["nextAction"] = this.nextAction;
        data["expectedCompletionDate"] = this.expectedCompletionDate ? this.expectedCompletionDate.toString() : undefined as any;
        if (Array.isArray(this.steps)) {
            data["steps"] = [];
            for (let item of this.steps)
                data["steps"].push(item ? item.toJSON() : undefined as any);
        }
        data["lastContactDate"] = this.lastContactDate ? this.lastContactDate.toString() : undefined as any;
        data["lastContactMethod"] = this.lastContactMethod;
        data["nextFollowUpDate"] = this.nextFollowUpDate ? this.nextFollowUpDate.toString() : undefined as any;
        data["requiresClaimantAction"] = this.requiresClaimantAction;
        if (Array.isArray(this.pendingRequirements)) {
            data["pendingRequirements"] = [];
            for (let item of this.pendingRequirements)
                data["pendingRequirements"].push(item);
        }
        return data;
    }
}

export interface IClaimProcessTrackingDto {
    claimId: string;
    currentStatus: string | undefined;
    currentStepName: string | undefined;
    currentStepNumber: number;
    totalSteps: number;
    percentageComplete: number;
    lastUpdated: DateTime;
    nextAction: string | undefined;
    expectedCompletionDate: DateTime | undefined;
    steps: ClaimProcessStepDto[] | undefined;
    lastContactDate: DateTime | undefined;
    lastContactMethod: string | undefined;
    nextFollowUpDate: DateTime | undefined;
    requiresClaimantAction: boolean;
    pendingRequirements: string[] | undefined;
}

export enum ClaimStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
}

export enum ClaimType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum ClaimantType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class CompleteMaintenanceDto implements ICompleteMaintenanceDto {
    assetId!: string;
    nextMaintenanceDate!: DateTime | undefined;
    notes!: string | undefined;

    constructor(data?: ICompleteMaintenanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetId = _data["assetId"];
            this.nextMaintenanceDate = _data["nextMaintenanceDate"] ? DateTime.fromISO(_data["nextMaintenanceDate"].toString()) : undefined as any;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CompleteMaintenanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteMaintenanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetId"] = this.assetId;
        data["nextMaintenanceDate"] = this.nextMaintenanceDate ? this.nextMaintenanceDate.toString() : undefined as any;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICompleteMaintenanceDto {
    assetId: string;
    nextMaintenanceDate: DateTime | undefined;
    notes: string | undefined;
}

export class ContactFormDto implements IContactFormDto {
    name!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    subject!: string | undefined;
    message!: string | undefined;
    tenantSubdomain!: string | undefined;

    constructor(data?: IContactFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.subject = _data["subject"];
            this.message = _data["message"];
            this.tenantSubdomain = _data["tenantSubdomain"];
        }
    }

    static fromJS(data: any): ContactFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["subject"] = this.subject;
        data["message"] = this.message;
        data["tenantSubdomain"] = this.tenantSubdomain;
        return data;
    }
}

export interface IContactFormDto {
    name: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    subject: string | undefined;
    message: string | undefined;
    tenantSubdomain: string | undefined;
}

export class ContractGenerationResult implements IContractGenerationResult {
    contractId!: string;
    pdfUrl!: string | undefined;
    usedTemplate!: boolean;
    message!: string | undefined;

    constructor(data?: IContractGenerationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.pdfUrl = _data["pdfUrl"];
            this.usedTemplate = _data["usedTemplate"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ContractGenerationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContractGenerationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["pdfUrl"] = this.pdfUrl;
        data["usedTemplate"] = this.usedTemplate;
        data["message"] = this.message;
        return data;
    }
}

export interface IContractGenerationResult {
    contractId: string;
    pdfUrl: string | undefined;
    usedTemplate: boolean;
    message: string | undefined;
}

export class CreateAssetDto implements ICreateAssetDto {
    name!: string | undefined;
    description!: string | undefined;
    assetType!: AssetType;
    identificationNumber!: string | undefined;
    make!: string | undefined;
    model!: string | undefined;
    year!: number | undefined;
    quantity!: number;
    currentLocation!: string | undefined;
    requiresInspection!: boolean;
    inspectionCheckpoints!: string[] | undefined;
    purchaseDate!: DateTime | undefined;
    purchaseCost!: number | undefined;
    conditionNotes!: string | undefined;

    constructor(data?: ICreateAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.assetType = _data["assetType"];
            this.identificationNumber = _data["identificationNumber"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.year = _data["year"];
            this.quantity = _data["quantity"];
            this.currentLocation = _data["currentLocation"];
            this.requiresInspection = _data["requiresInspection"];
            if (Array.isArray(_data["inspectionCheckpoints"])) {
                this.inspectionCheckpoints = [] as any;
                for (let item of _data["inspectionCheckpoints"])
                    this.inspectionCheckpoints!.push(item);
            }
            this.purchaseDate = _data["purchaseDate"] ? DateTime.fromISO(_data["purchaseDate"].toString()) : undefined as any;
            this.purchaseCost = _data["purchaseCost"];
            this.conditionNotes = _data["conditionNotes"];
        }
    }

    static fromJS(data: any): CreateAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["assetType"] = this.assetType;
        data["identificationNumber"] = this.identificationNumber;
        data["make"] = this.make;
        data["model"] = this.model;
        data["year"] = this.year;
        data["quantity"] = this.quantity;
        data["currentLocation"] = this.currentLocation;
        data["requiresInspection"] = this.requiresInspection;
        if (Array.isArray(this.inspectionCheckpoints)) {
            data["inspectionCheckpoints"] = [];
            for (let item of this.inspectionCheckpoints)
                data["inspectionCheckpoints"].push(item);
        }
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toString() : undefined as any;
        data["purchaseCost"] = this.purchaseCost;
        data["conditionNotes"] = this.conditionNotes;
        return data;
    }
}

export interface ICreateAssetDto {
    name: string | undefined;
    description: string | undefined;
    assetType: AssetType;
    identificationNumber: string | undefined;
    make: string | undefined;
    model: string | undefined;
    year: number | undefined;
    quantity: number;
    currentLocation: string | undefined;
    requiresInspection: boolean;
    inspectionCheckpoints: string[] | undefined;
    purchaseDate: DateTime | undefined;
    purchaseCost: number | undefined;
    conditionNotes: string | undefined;
}

export class CreateBatchRequest implements ICreateBatchRequest {
    processingDate!: DateTime;

    constructor(data?: ICreateBatchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processingDate = _data["processingDate"] ? DateTime.fromISO(_data["processingDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CreateBatchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBatchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processingDate"] = this.processingDate ? this.processingDate.toString() : undefined as any;
        return data;
    }
}

export interface ICreateBatchRequest {
    processingDate: DateTime;
}

export class CreateClaimDto implements ICreateClaimDto {
    memberId!: string;
    policyId!: string;
    requestedAmount!: number | undefined;
    dateOfDeath!: DateTime;
    causeOfDeath!: string | undefined;
    placeOfDeath!: string | undefined;
    description!: string | undefined;
    beneficiaryId!: string | undefined;
    additionalNotes!: string | undefined;
    hasDeathCertificate!: boolean;
    hasIdentityDocuments!: boolean;
    hasMedicalReports!: boolean;
    requiresPoliceReport!: boolean;

    constructor(data?: ICreateClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.policyId = _data["policyId"];
            this.requestedAmount = _data["requestedAmount"];
            this.dateOfDeath = _data["dateOfDeath"] ? DateTime.fromISO(_data["dateOfDeath"].toString()) : undefined as any;
            this.causeOfDeath = _data["causeOfDeath"];
            this.placeOfDeath = _data["placeOfDeath"];
            this.description = _data["description"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.additionalNotes = _data["additionalNotes"];
            this.hasDeathCertificate = _data["hasDeathCertificate"];
            this.hasIdentityDocuments = _data["hasIdentityDocuments"];
            this.hasMedicalReports = _data["hasMedicalReports"];
            this.requiresPoliceReport = _data["requiresPoliceReport"];
        }
    }

    static fromJS(data: any): CreateClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["policyId"] = this.policyId;
        data["requestedAmount"] = this.requestedAmount;
        data["dateOfDeath"] = this.dateOfDeath ? this.dateOfDeath.toString() : undefined as any;
        data["causeOfDeath"] = this.causeOfDeath;
        data["placeOfDeath"] = this.placeOfDeath;
        data["description"] = this.description;
        data["beneficiaryId"] = this.beneficiaryId;
        data["additionalNotes"] = this.additionalNotes;
        data["hasDeathCertificate"] = this.hasDeathCertificate;
        data["hasIdentityDocuments"] = this.hasIdentityDocuments;
        data["hasMedicalReports"] = this.hasMedicalReports;
        data["requiresPoliceReport"] = this.requiresPoliceReport;
        return data;
    }
}

export interface ICreateClaimDto {
    memberId: string;
    policyId: string;
    requestedAmount: number | undefined;
    dateOfDeath: DateTime;
    causeOfDeath: string | undefined;
    placeOfDeath: string | undefined;
    description: string | undefined;
    beneficiaryId: string | undefined;
    additionalNotes: string | undefined;
    hasDeathCertificate: boolean;
    hasIdentityDocuments: boolean;
    hasMedicalReports: boolean;
    requiresPoliceReport: boolean;
}

export class CreateDashboardWidgetSettingDto implements ICreateDashboardWidgetSettingDto {
    widgetKey!: string | undefined;
    widgetName!: string | undefined;
    isVisible!: boolean;
    allowedRoles!: string[] | undefined;
    displayOrder!: number;

    constructor(data?: ICreateDashboardWidgetSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetKey = _data["widgetKey"];
            this.widgetName = _data["widgetName"];
            this.isVisible = _data["isVisible"];
            if (Array.isArray(_data["allowedRoles"])) {
                this.allowedRoles = [] as any;
                for (let item of _data["allowedRoles"])
                    this.allowedRoles!.push(item);
            }
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): CreateDashboardWidgetSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDashboardWidgetSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetKey"] = this.widgetKey;
        data["widgetName"] = this.widgetName;
        data["isVisible"] = this.isVisible;
        if (Array.isArray(this.allowedRoles)) {
            data["allowedRoles"] = [];
            for (let item of this.allowedRoles)
                data["allowedRoles"].push(item);
        }
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface ICreateDashboardWidgetSettingDto {
    widgetKey: string | undefined;
    widgetName: string | undefined;
    isVisible: boolean;
    allowedRoles: string[] | undefined;
    displayOrder: number;
}

export class CreateMemberBankingDetailDto implements ICreateMemberBankingDetailDto {
    bankName!: string | undefined;
    accountNumber!: string | undefined;
    accountType!: string | undefined;
    branchCode!: string | undefined;
    branchName!: string | undefined;
    accountHolderName!: string | undefined;
    debitDay!: number | undefined;
    paymentMethod!: PaymentMethodType;

    constructor(data?: ICreateMemberBankingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.accountType = _data["accountType"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.accountHolderName = _data["accountHolderName"];
            this.debitDay = _data["debitDay"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): CreateMemberBankingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMemberBankingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["accountType"] = this.accountType;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["accountHolderName"] = this.accountHolderName;
        data["debitDay"] = this.debitDay;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }
}

export interface ICreateMemberBankingDetailDto {
    bankName: string | undefined;
    accountNumber: string | undefined;
    accountType: string | undefined;
    branchCode: string | undefined;
    branchName: string | undefined;
    accountHolderName: string | undefined;
    debitDay: number | undefined;
    paymentMethod: PaymentMethodType;
}

export class CreateMemberDto implements ICreateMemberDto {
    id!: string | undefined;
    name!: string | undefined;
    address!: string | undefined;
    title!: string | undefined;
    firstNames!: string | undefined;
    surname!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    email!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    identificationNumber!: string | undefined;
    sourceOfIncome!: SourceOfIncome;
    sourceOfIncomeOther!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    province!: SouthAfricanProvince;
    postalCode!: string | undefined;
    isReplacingExistingPolicy!: boolean;
    existingPolicyNumber!: string | undefined;
    existingInsurerName!: string | undefined;
    existingPolicyPaidUpToDate!: boolean | undefined;
    existingPolicyWaitingPeriodExpired!: boolean | undefined;
    sameBenefitAsExistingPolicy!: boolean | undefined;
    benefitDifferenceNotes!: string | undefined;
    occupation!: string | undefined;
    workPhoneNumber!: string | undefined;
    passportNumber!: string | undefined;
    countryOfBirth!: string | undefined;
    countryOfResidence!: string | undefined;
    citizenship!: string | undefined;
    nationality!: string | undefined;
    isForeigner!: boolean;
    workPermitNumber!: string | undefined;
    policyId!: string;

    constructor(data?: ICreateMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.title = _data["title"];
            this.firstNames = _data["firstNames"];
            this.surname = _data["surname"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.email = _data["email"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.identificationNumber = _data["identificationNumber"];
            this.sourceOfIncome = _data["sourceOfIncome"];
            this.sourceOfIncomeOther = _data["sourceOfIncomeOther"];
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.isReplacingExistingPolicy = _data["isReplacingExistingPolicy"];
            this.existingPolicyNumber = _data["existingPolicyNumber"];
            this.existingInsurerName = _data["existingInsurerName"];
            this.existingPolicyPaidUpToDate = _data["existingPolicyPaidUpToDate"];
            this.existingPolicyWaitingPeriodExpired = _data["existingPolicyWaitingPeriodExpired"];
            this.sameBenefitAsExistingPolicy = _data["sameBenefitAsExistingPolicy"];
            this.benefitDifferenceNotes = _data["benefitDifferenceNotes"];
            this.occupation = _data["occupation"];
            this.workPhoneNumber = _data["workPhoneNumber"];
            this.passportNumber = _data["passportNumber"];
            this.countryOfBirth = _data["countryOfBirth"];
            this.countryOfResidence = _data["countryOfResidence"];
            this.citizenship = _data["citizenship"];
            this.nationality = _data["nationality"];
            this.isForeigner = _data["isForeigner"];
            this.workPermitNumber = _data["workPermitNumber"];
            this.policyId = _data["policyId"];
        }
    }

    static fromJS(data: any): CreateMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address;
        data["title"] = this.title;
        data["firstNames"] = this.firstNames;
        data["surname"] = this.surname;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["email"] = this.email;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["identificationNumber"] = this.identificationNumber;
        data["sourceOfIncome"] = this.sourceOfIncome;
        data["sourceOfIncomeOther"] = this.sourceOfIncomeOther;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["isReplacingExistingPolicy"] = this.isReplacingExistingPolicy;
        data["existingPolicyNumber"] = this.existingPolicyNumber;
        data["existingInsurerName"] = this.existingInsurerName;
        data["existingPolicyPaidUpToDate"] = this.existingPolicyPaidUpToDate;
        data["existingPolicyWaitingPeriodExpired"] = this.existingPolicyWaitingPeriodExpired;
        data["sameBenefitAsExistingPolicy"] = this.sameBenefitAsExistingPolicy;
        data["benefitDifferenceNotes"] = this.benefitDifferenceNotes;
        data["occupation"] = this.occupation;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["passportNumber"] = this.passportNumber;
        data["countryOfBirth"] = this.countryOfBirth;
        data["countryOfResidence"] = this.countryOfResidence;
        data["citizenship"] = this.citizenship;
        data["nationality"] = this.nationality;
        data["isForeigner"] = this.isForeigner;
        data["workPermitNumber"] = this.workPermitNumber;
        data["policyId"] = this.policyId;
        return data;
    }
}

export interface ICreateMemberDto {
    id: string | undefined;
    name: string | undefined;
    address: string | undefined;
    title: string | undefined;
    firstNames: string | undefined;
    surname: string | undefined;
    dateOfBirth: DateTime | undefined;
    email: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    identificationNumber: string | undefined;
    sourceOfIncome: SourceOfIncome;
    sourceOfIncomeOther: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    province: SouthAfricanProvince;
    postalCode: string | undefined;
    isReplacingExistingPolicy: boolean;
    existingPolicyNumber: string | undefined;
    existingInsurerName: string | undefined;
    existingPolicyPaidUpToDate: boolean | undefined;
    existingPolicyWaitingPeriodExpired: boolean | undefined;
    sameBenefitAsExistingPolicy: boolean | undefined;
    benefitDifferenceNotes: string | undefined;
    occupation: string | undefined;
    workPhoneNumber: string | undefined;
    passportNumber: string | undefined;
    countryOfBirth: string | undefined;
    countryOfResidence: string | undefined;
    citizenship: string | undefined;
    nationality: string | undefined;
    isForeigner: boolean;
    workPermitNumber: string | undefined;
    policyId: string;
}

export class CreateOnboardingFieldConfigurationDto implements ICreateOnboardingFieldConfigurationDto {
    fieldKey!: string;
    fieldLabel!: string;
    fieldType!: string;
    category!: string | undefined;
    isRequired!: boolean;
    isEnabled!: boolean;
    displayOrder!: number;
    placeholder!: string | undefined;
    helpText!: string | undefined;
    optionsJson!: string | undefined;
    validationRulesJson!: string | undefined;
    defaultValue!: string | undefined;
    maxLength!: number | undefined;
    minLength!: number | undefined;

    constructor(data?: ICreateOnboardingFieldConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldKey = _data["fieldKey"];
            this.fieldLabel = _data["fieldLabel"];
            this.fieldType = _data["fieldType"];
            this.category = _data["category"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.placeholder = _data["placeholder"];
            this.helpText = _data["helpText"];
            this.optionsJson = _data["optionsJson"];
            this.validationRulesJson = _data["validationRulesJson"];
            this.defaultValue = _data["defaultValue"];
            this.maxLength = _data["maxLength"];
            this.minLength = _data["minLength"];
        }
    }

    static fromJS(data: any): CreateOnboardingFieldConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOnboardingFieldConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldKey"] = this.fieldKey;
        data["fieldLabel"] = this.fieldLabel;
        data["fieldType"] = this.fieldType;
        data["category"] = this.category;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["placeholder"] = this.placeholder;
        data["helpText"] = this.helpText;
        data["optionsJson"] = this.optionsJson;
        data["validationRulesJson"] = this.validationRulesJson;
        data["defaultValue"] = this.defaultValue;
        data["maxLength"] = this.maxLength;
        data["minLength"] = this.minLength;
        return data;
    }
}

export interface ICreateOnboardingFieldConfigurationDto {
    fieldKey: string;
    fieldLabel: string;
    fieldType: string;
    category: string | undefined;
    isRequired: boolean;
    isEnabled: boolean;
    displayOrder: number;
    placeholder: string | undefined;
    helpText: string | undefined;
    optionsJson: string | undefined;
    validationRulesJson: string | undefined;
    defaultValue: string | undefined;
    maxLength: number | undefined;
    minLength: number | undefined;
}

export class CreatePdfFieldMappingRequest implements ICreatePdfFieldMappingRequest {
    sourceField!: string | undefined;
    pdfFieldName!: string | undefined;
    mappingType!: string | undefined;
    isEnabled!: boolean;
    displayOrder!: number;
    description!: string | undefined;
    conditionalRulesJson!: string | undefined;
    transformRule!: string | undefined;
    defaultValue!: string | undefined;
    checkedValue!: string | undefined;
    uncheckedValue!: string | undefined;
    category!: string | undefined;

    constructor(data?: ICreatePdfFieldMappingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceField = _data["sourceField"];
            this.pdfFieldName = _data["pdfFieldName"];
            this.mappingType = _data["mappingType"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.description = _data["description"];
            this.conditionalRulesJson = _data["conditionalRulesJson"];
            this.transformRule = _data["transformRule"];
            this.defaultValue = _data["defaultValue"];
            this.checkedValue = _data["checkedValue"];
            this.uncheckedValue = _data["uncheckedValue"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): CreatePdfFieldMappingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePdfFieldMappingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceField"] = this.sourceField;
        data["pdfFieldName"] = this.pdfFieldName;
        data["mappingType"] = this.mappingType;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["description"] = this.description;
        data["conditionalRulesJson"] = this.conditionalRulesJson;
        data["transformRule"] = this.transformRule;
        data["defaultValue"] = this.defaultValue;
        data["checkedValue"] = this.checkedValue;
        data["uncheckedValue"] = this.uncheckedValue;
        data["category"] = this.category;
        return data;
    }
}

export interface ICreatePdfFieldMappingRequest {
    sourceField: string | undefined;
    pdfFieldName: string | undefined;
    mappingType: string | undefined;
    isEnabled: boolean;
    displayOrder: number;
    description: string | undefined;
    conditionalRulesJson: string | undefined;
    transformRule: string | undefined;
    defaultValue: string | undefined;
    checkedValue: string | undefined;
    uncheckedValue: string | undefined;
    category: string | undefined;
}

export class CreateRolePermissionDto implements ICreateRolePermissionDto {
    id!: string;
    roleId!: string;
    permissionId!: string;

    constructor(data?: ICreateRolePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.permissionId = _data["permissionId"];
        }
    }

    static fromJS(data: any): CreateRolePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRolePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["permissionId"] = this.permissionId;
        return data;
    }
}

export interface ICreateRolePermissionDto {
    id: string;
    roleId: string;
    permissionId: string;
}

export class CreateVerificationRequestDto implements ICreateVerificationRequestDto {
    idNumber!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    verificationType!: string | undefined;
    userId!: string | undefined;
    memberId!: string | undefined;
    claimId!: string | undefined;

    constructor(data?: ICreateVerificationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.verificationType = _data["verificationType"];
            this.userId = _data["userId"];
            this.memberId = _data["memberId"];
            this.claimId = _data["claimId"];
        }
    }

    static fromJS(data: any): CreateVerificationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVerificationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["verificationType"] = this.verificationType;
        data["userId"] = this.userId;
        data["memberId"] = this.memberId;
        data["claimId"] = this.claimId;
        return data;
    }
}

export interface ICreateVerificationRequestDto {
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    dateOfBirth: DateTime | undefined;
    verificationType: string | undefined;
    userId: string | undefined;
    memberId: string | undefined;
    claimId: string | undefined;
}

export class DashboardWidgetSettingDto implements IDashboardWidgetSettingDto {
    id!: string;
    widgetKey!: string | undefined;
    widgetName!: string | undefined;
    isVisible!: boolean;
    allowedRoles!: string[] | undefined;
    displayOrder!: number;

    constructor(data?: IDashboardWidgetSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.widgetKey = _data["widgetKey"];
            this.widgetName = _data["widgetName"];
            this.isVisible = _data["isVisible"];
            if (Array.isArray(_data["allowedRoles"])) {
                this.allowedRoles = [] as any;
                for (let item of _data["allowedRoles"])
                    this.allowedRoles!.push(item);
            }
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): DashboardWidgetSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardWidgetSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["widgetKey"] = this.widgetKey;
        data["widgetName"] = this.widgetName;
        data["isVisible"] = this.isVisible;
        if (Array.isArray(this.allowedRoles)) {
            data["allowedRoles"] = [];
            for (let item of this.allowedRoles)
                data["allowedRoles"].push(item);
        }
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IDashboardWidgetSettingDto {
    id: string;
    widgetKey: string | undefined;
    widgetName: string | undefined;
    isVisible: boolean;
    allowedRoles: string[] | undefined;
    displayOrder: number;
}

export class DependentCountTierDto implements IDependentCountTierDto {
    minDependents!: number;
    maxDependents!: number;
    label!: string | undefined;
    ageBrackets!: { [key: string]: PolicyCoverAgeBracketDto; } | undefined;

    constructor(data?: IDependentCountTierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minDependents = _data["minDependents"];
            this.maxDependents = _data["maxDependents"];
            this.label = _data["label"];
            if (_data["ageBrackets"]) {
                this.ageBrackets = {} as any;
                for (let key in _data["ageBrackets"]) {
                    if (_data["ageBrackets"].hasOwnProperty(key))
                        (this.ageBrackets as any)![key] = _data["ageBrackets"][key] ? PolicyCoverAgeBracketDto.fromJS(_data["ageBrackets"][key]) : new PolicyCoverAgeBracketDto();
                }
            }
        }
    }

    static fromJS(data: any): DependentCountTierDto {
        data = typeof data === 'object' ? data : {};
        let result = new DependentCountTierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minDependents"] = this.minDependents;
        data["maxDependents"] = this.maxDependents;
        data["label"] = this.label;
        if (this.ageBrackets) {
            data["ageBrackets"] = {};
            for (let key in this.ageBrackets) {
                if (this.ageBrackets.hasOwnProperty(key))
                    (data["ageBrackets"] as any)[key] = this.ageBrackets[key] ? this.ageBrackets[key].toJSON() : undefined as any;
            }
        }
        return data;
    }
}

export interface IDependentCountTierDto {
    minDependents: number;
    maxDependents: number;
    label: string | undefined;
    ageBrackets: { [key: string]: PolicyCoverAgeBracketDto; } | undefined;
}

export class DependentDto implements IDependentDto {
    id!: string;
    memberId!: string;
    name!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    identificationNumber!: string | undefined;
    dependentType!: DependentType;
    dateOfBirth!: DateTime | undefined;
    calculatedAge!: number | undefined;

    constructor(data?: IDependentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.identificationNumber = _data["identificationNumber"];
            this.dependentType = _data["dependentType"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.calculatedAge = _data["calculatedAge"];
        }
    }

    static fromJS(data: any): DependentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DependentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["identificationNumber"] = this.identificationNumber;
        data["dependentType"] = this.dependentType;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["calculatedAge"] = this.calculatedAge;
        return data;
    }
}

export interface IDependentDto {
    id: string;
    memberId: string;
    name: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    identificationNumber: string | undefined;
    dependentType: DependentType;
    dateOfBirth: DateTime | undefined;
    calculatedAge: number | undefined;
}

export class DependentInfoDto implements IDependentInfoDto {
    id!: string;
    age!: number;
    dateOfBirth!: DateTime;
    firstName!: string | undefined;
    lastName!: string | undefined;

    constructor(data?: IDependentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.age = _data["age"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): DependentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DependentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["age"] = this.age;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IDependentInfoDto {
    id: string;
    age: number;
    dateOfBirth: DateTime;
    firstName: string | undefined;
    lastName: string | undefined;
}

export class DependentSummary implements IDependentSummary {
    id!: string;
    name!: string | undefined;
    relationship!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    age!: number | undefined;

    constructor(data?: IDependentSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.relationship = _data["relationship"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.age = _data["age"];
        }
    }

    static fromJS(data: any): DependentSummary {
        data = typeof data === 'object' ? data : {};
        let result = new DependentSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["relationship"] = this.relationship;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["age"] = this.age;
        return data;
    }
}

export interface IDependentSummary {
    id: string;
    name: string | undefined;
    relationship: string | undefined;
    dateOfBirth: DateTime | undefined;
    age: number | undefined;
}

export enum DependentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class DocumentComplianceStatus implements IDocumentComplianceStatus {
    isCompliant!: boolean;
    totalRequired!: number;
    totalUploaded!: number;
    totalApproved!: number;
    missingDocuments!: DocumentRequirement[] | undefined;
    pendingVerification!: DocumentRequirement[] | undefined;
    rejectedDocuments!: DocumentRequirement[] | undefined;

    constructor(data?: IDocumentComplianceStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isCompliant = _data["isCompliant"];
            this.totalRequired = _data["totalRequired"];
            this.totalUploaded = _data["totalUploaded"];
            this.totalApproved = _data["totalApproved"];
            if (Array.isArray(_data["missingDocuments"])) {
                this.missingDocuments = [] as any;
                for (let item of _data["missingDocuments"])
                    this.missingDocuments!.push(DocumentRequirement.fromJS(item));
            }
            if (Array.isArray(_data["pendingVerification"])) {
                this.pendingVerification = [] as any;
                for (let item of _data["pendingVerification"])
                    this.pendingVerification!.push(DocumentRequirement.fromJS(item));
            }
            if (Array.isArray(_data["rejectedDocuments"])) {
                this.rejectedDocuments = [] as any;
                for (let item of _data["rejectedDocuments"])
                    this.rejectedDocuments!.push(DocumentRequirement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentComplianceStatus {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentComplianceStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isCompliant"] = this.isCompliant;
        data["totalRequired"] = this.totalRequired;
        data["totalUploaded"] = this.totalUploaded;
        data["totalApproved"] = this.totalApproved;
        if (Array.isArray(this.missingDocuments)) {
            data["missingDocuments"] = [];
            for (let item of this.missingDocuments)
                data["missingDocuments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.pendingVerification)) {
            data["pendingVerification"] = [];
            for (let item of this.pendingVerification)
                data["pendingVerification"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.rejectedDocuments)) {
            data["rejectedDocuments"] = [];
            for (let item of this.rejectedDocuments)
                data["rejectedDocuments"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IDocumentComplianceStatus {
    isCompliant: boolean;
    totalRequired: number;
    totalUploaded: number;
    totalApproved: number;
    missingDocuments: DocumentRequirement[] | undefined;
    pendingVerification: DocumentRequirement[] | undefined;
    rejectedDocuments: DocumentRequirement[] | undefined;
}

export class DocumentRequirement implements IDocumentRequirement {
    documentType!: MemberDocumentType;
    documentName!: string | undefined;
    requirementReason!: string | undefined;
    isRequired!: boolean;
    isUploaded!: boolean;
    fileMetadataId!: string | undefined;
    verificationStatus!: DocumentVerificationStatus;

    constructor(data?: IDocumentRequirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"];
            this.documentName = _data["documentName"];
            this.requirementReason = _data["requirementReason"];
            this.isRequired = _data["isRequired"];
            this.isUploaded = _data["isUploaded"];
            this.fileMetadataId = _data["fileMetadataId"];
            this.verificationStatus = _data["verificationStatus"];
        }
    }

    static fromJS(data: any): DocumentRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        data["documentName"] = this.documentName;
        data["requirementReason"] = this.requirementReason;
        data["isRequired"] = this.isRequired;
        data["isUploaded"] = this.isUploaded;
        data["fileMetadataId"] = this.fileMetadataId;
        data["verificationStatus"] = this.verificationStatus;
        return data;
    }
}

export interface IDocumentRequirement {
    documentType: MemberDocumentType;
    documentName: string | undefined;
    requirementReason: string | undefined;
    isRequired: boolean;
    isUploaded: boolean;
    fileMetadataId: string | undefined;
    verificationStatus: DocumentVerificationStatus;
}

export enum DocumentVerificationStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class EnhancedCreateClaimDto implements IEnhancedCreateClaimDto {
    memberId!: string;
    policyId!: string;
    requestedAmount!: number | undefined;
    description!: string | undefined;
    claimType!: string | undefined;
    claimantType!: string | undefined;
    dateOfDeath!: DateTime;
    causeOfDeath!: string | undefined;
    placeOfDeath!: string | undefined;
    claimantName!: string | undefined;
    claimantEmail!: string | undefined;
    claimantPhone!: string | undefined;
    claimantIdNumber!: string | undefined;
    claimantAddress!: string | undefined;
    deceasedPersonId!: string | undefined;
    deceasedPersonName!: string | undefined;
    deceasedPersonIdNumber!: string | undefined;
    relationshipToDeceased!: string | undefined;
    beneficiaryId!: string | undefined;
    dependentId!: string | undefined;
    bankName!: string | undefined;
    accountNumber!: string | undefined;
    branchCode!: string | undefined;
    accountHolderName!: string | undefined;
    funeralServiceProvider!: string | undefined;
    estimatedFuneralCosts!: number | undefined;
    proposedFuneralDate!: DateTime | undefined;
    funeralLocation!: string | undefined;
    hasDeathCertificate!: boolean;
    hasIdentityDocuments!: boolean;
    hasMedicalReports!: boolean;
    hasPoliceReport!: boolean;
    hasProofOfRelationship!: boolean;
    hasBankingDetails!: boolean;
    additionalNotes!: string | undefined;
    requiresUrgentProcessing!: boolean;

    constructor(data?: IEnhancedCreateClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.policyId = _data["policyId"];
            this.requestedAmount = _data["requestedAmount"];
            this.description = _data["description"];
            this.claimType = _data["claimType"];
            this.claimantType = _data["claimantType"];
            this.dateOfDeath = _data["dateOfDeath"] ? DateTime.fromISO(_data["dateOfDeath"].toString()) : undefined as any;
            this.causeOfDeath = _data["causeOfDeath"];
            this.placeOfDeath = _data["placeOfDeath"];
            this.claimantName = _data["claimantName"];
            this.claimantEmail = _data["claimantEmail"];
            this.claimantPhone = _data["claimantPhone"];
            this.claimantIdNumber = _data["claimantIdNumber"];
            this.claimantAddress = _data["claimantAddress"];
            this.deceasedPersonId = _data["deceasedPersonId"];
            this.deceasedPersonName = _data["deceasedPersonName"];
            this.deceasedPersonIdNumber = _data["deceasedPersonIdNumber"];
            this.relationshipToDeceased = _data["relationshipToDeceased"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.dependentId = _data["dependentId"];
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.branchCode = _data["branchCode"];
            this.accountHolderName = _data["accountHolderName"];
            this.funeralServiceProvider = _data["funeralServiceProvider"];
            this.estimatedFuneralCosts = _data["estimatedFuneralCosts"];
            this.proposedFuneralDate = _data["proposedFuneralDate"] ? DateTime.fromISO(_data["proposedFuneralDate"].toString()) : undefined as any;
            this.funeralLocation = _data["funeralLocation"];
            this.hasDeathCertificate = _data["hasDeathCertificate"];
            this.hasIdentityDocuments = _data["hasIdentityDocuments"];
            this.hasMedicalReports = _data["hasMedicalReports"];
            this.hasPoliceReport = _data["hasPoliceReport"];
            this.hasProofOfRelationship = _data["hasProofOfRelationship"];
            this.hasBankingDetails = _data["hasBankingDetails"];
            this.additionalNotes = _data["additionalNotes"];
            this.requiresUrgentProcessing = _data["requiresUrgentProcessing"];
        }
    }

    static fromJS(data: any): EnhancedCreateClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnhancedCreateClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["policyId"] = this.policyId;
        data["requestedAmount"] = this.requestedAmount;
        data["description"] = this.description;
        data["claimType"] = this.claimType;
        data["claimantType"] = this.claimantType;
        data["dateOfDeath"] = this.dateOfDeath ? this.dateOfDeath.toString() : undefined as any;
        data["causeOfDeath"] = this.causeOfDeath;
        data["placeOfDeath"] = this.placeOfDeath;
        data["claimantName"] = this.claimantName;
        data["claimantEmail"] = this.claimantEmail;
        data["claimantPhone"] = this.claimantPhone;
        data["claimantIdNumber"] = this.claimantIdNumber;
        data["claimantAddress"] = this.claimantAddress;
        data["deceasedPersonId"] = this.deceasedPersonId;
        data["deceasedPersonName"] = this.deceasedPersonName;
        data["deceasedPersonIdNumber"] = this.deceasedPersonIdNumber;
        data["relationshipToDeceased"] = this.relationshipToDeceased;
        data["beneficiaryId"] = this.beneficiaryId;
        data["dependentId"] = this.dependentId;
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["branchCode"] = this.branchCode;
        data["accountHolderName"] = this.accountHolderName;
        data["funeralServiceProvider"] = this.funeralServiceProvider;
        data["estimatedFuneralCosts"] = this.estimatedFuneralCosts;
        data["proposedFuneralDate"] = this.proposedFuneralDate ? this.proposedFuneralDate.toString() : undefined as any;
        data["funeralLocation"] = this.funeralLocation;
        data["hasDeathCertificate"] = this.hasDeathCertificate;
        data["hasIdentityDocuments"] = this.hasIdentityDocuments;
        data["hasMedicalReports"] = this.hasMedicalReports;
        data["hasPoliceReport"] = this.hasPoliceReport;
        data["hasProofOfRelationship"] = this.hasProofOfRelationship;
        data["hasBankingDetails"] = this.hasBankingDetails;
        data["additionalNotes"] = this.additionalNotes;
        data["requiresUrgentProcessing"] = this.requiresUrgentProcessing;
        return data;
    }
}

export interface IEnhancedCreateClaimDto {
    memberId: string;
    policyId: string;
    requestedAmount: number | undefined;
    description: string | undefined;
    claimType: string | undefined;
    claimantType: string | undefined;
    dateOfDeath: DateTime;
    causeOfDeath: string | undefined;
    placeOfDeath: string | undefined;
    claimantName: string | undefined;
    claimantEmail: string | undefined;
    claimantPhone: string | undefined;
    claimantIdNumber: string | undefined;
    claimantAddress: string | undefined;
    deceasedPersonId: string | undefined;
    deceasedPersonName: string | undefined;
    deceasedPersonIdNumber: string | undefined;
    relationshipToDeceased: string | undefined;
    beneficiaryId: string | undefined;
    dependentId: string | undefined;
    bankName: string | undefined;
    accountNumber: string | undefined;
    branchCode: string | undefined;
    accountHolderName: string | undefined;
    funeralServiceProvider: string | undefined;
    estimatedFuneralCosts: number | undefined;
    proposedFuneralDate: DateTime | undefined;
    funeralLocation: string | undefined;
    hasDeathCertificate: boolean;
    hasIdentityDocuments: boolean;
    hasMedicalReports: boolean;
    hasPoliceReport: boolean;
    hasProofOfRelationship: boolean;
    hasBankingDetails: boolean;
    additionalNotes: string | undefined;
    requiresUrgentProcessing: boolean;
}

export class ErrorResponse implements IErrorResponse {
    message!: string | undefined;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface IErrorResponse {
    message: string | undefined;
}

export class ExtendedFamilyBenefitRowDto implements IExtendedFamilyBenefitRowDto {
    minAge!: number;
    maxAge!: number;
    ageRange!: string | undefined;
    premium_5000_Cover!: number;
    premium_10000_Cover!: number;
    premium_15000_Cover!: number;
    premium_20000_Cover!: number;
    premium_25000_Cover!: number;

    constructor(data?: IExtendedFamilyBenefitRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minAge = _data["minAge"];
            this.maxAge = _data["maxAge"];
            this.ageRange = _data["ageRange"];
            this.premium_5000_Cover = _data["premium_5000_Cover"];
            this.premium_10000_Cover = _data["premium_10000_Cover"];
            this.premium_15000_Cover = _data["premium_15000_Cover"];
            this.premium_20000_Cover = _data["premium_20000_Cover"];
            this.premium_25000_Cover = _data["premium_25000_Cover"];
        }
    }

    static fromJS(data: any): ExtendedFamilyBenefitRowDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendedFamilyBenefitRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minAge"] = this.minAge;
        data["maxAge"] = this.maxAge;
        data["ageRange"] = this.ageRange;
        data["premium_5000_Cover"] = this.premium_5000_Cover;
        data["premium_10000_Cover"] = this.premium_10000_Cover;
        data["premium_15000_Cover"] = this.premium_15000_Cover;
        data["premium_20000_Cover"] = this.premium_20000_Cover;
        data["premium_25000_Cover"] = this.premium_25000_Cover;
        return data;
    }
}

export interface IExtendedFamilyBenefitRowDto {
    minAge: number;
    maxAge: number;
    ageRange: string | undefined;
    premium_5000_Cover: number;
    premium_10000_Cover: number;
    premium_15000_Cover: number;
    premium_20000_Cover: number;
    premium_25000_Cover: number;
}

export class ExtendedFamilyBenefitTableDto implements IExtendedFamilyBenefitTableDto {
    rows!: ExtendedFamilyBenefitRowDto[] | undefined;

    constructor(data?: IExtendedFamilyBenefitTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(ExtendedFamilyBenefitRowDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExtendedFamilyBenefitTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendedFamilyBenefitTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IExtendedFamilyBenefitTableDto {
    rows: ExtendedFamilyBenefitRowDto[] | undefined;
}

export class FileMetadataDto implements IFileMetadataDto {
    id!: string;
    tenantId!: string;
    userId!: string | undefined;
    fileName!: string | undefined;
    filePath!: string | undefined;
    contentType!: string | undefined;
    size!: number;
    description!: string | undefined;
    entityType!: string | undefined;
    entityId!: string | undefined;

    constructor(data?: IFileMetadataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.contentType = _data["contentType"];
            this.size = _data["size"];
            this.description = _data["description"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): FileMetadataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileMetadataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["contentType"] = this.contentType;
        data["size"] = this.size;
        data["description"] = this.description;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        return data;
    }
}

export interface IFileMetadataDto {
    id: string;
    tenantId: string;
    userId: string | undefined;
    fileName: string | undefined;
    filePath: string | undefined;
    contentType: string | undefined;
    size: number;
    description: string | undefined;
    entityType: string | undefined;
    entityId: string | undefined;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string | undefined;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email: string | undefined;
}

export class FuneralEventDto implements IFuneralEventDto {
    id!: string;
    claimId!: string;
    eventDate!: DateTime;
    location!: string | undefined;
    notes!: string | undefined;
    status!: FuneralEventStatus;
    assetIds!: string[] | undefined;
    driverIds!: string[] | undefined;
    decoratorIds!: string[] | undefined;

    constructor(data?: IFuneralEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.claimId = _data["claimId"];
            this.eventDate = _data["eventDate"] ? DateTime.fromISO(_data["eventDate"].toString()) : undefined as any;
            this.location = _data["location"];
            this.notes = _data["notes"];
            this.status = _data["status"];
            if (Array.isArray(_data["assetIds"])) {
                this.assetIds = [] as any;
                for (let item of _data["assetIds"])
                    this.assetIds!.push(item);
            }
            if (Array.isArray(_data["driverIds"])) {
                this.driverIds = [] as any;
                for (let item of _data["driverIds"])
                    this.driverIds!.push(item);
            }
            if (Array.isArray(_data["decoratorIds"])) {
                this.decoratorIds = [] as any;
                for (let item of _data["decoratorIds"])
                    this.decoratorIds!.push(item);
            }
        }
    }

    static fromJS(data: any): FuneralEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new FuneralEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["claimId"] = this.claimId;
        data["eventDate"] = this.eventDate ? this.eventDate.toString() : undefined as any;
        data["location"] = this.location;
        data["notes"] = this.notes;
        data["status"] = this.status;
        if (Array.isArray(this.assetIds)) {
            data["assetIds"] = [];
            for (let item of this.assetIds)
                data["assetIds"].push(item);
        }
        if (Array.isArray(this.driverIds)) {
            data["driverIds"] = [];
            for (let item of this.driverIds)
                data["driverIds"].push(item);
        }
        if (Array.isArray(this.decoratorIds)) {
            data["decoratorIds"] = [];
            for (let item of this.decoratorIds)
                data["decoratorIds"].push(item);
        }
        return data;
    }
}

export interface IFuneralEventDto {
    id: string;
    claimId: string;
    eventDate: DateTime;
    location: string | undefined;
    notes: string | undefined;
    status: FuneralEventStatus;
    assetIds: string[] | undefined;
    driverIds: string[] | undefined;
    decoratorIds: string[] | undefined;
}

export enum FuneralEventStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class GenerateContractRequest implements IGenerateContractRequest {
    memberId!: string;

    constructor(data?: IGenerateContractRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
        }
    }

    static fromJS(data: any): GenerateContractRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateContractRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        return data;
    }
}

export interface IGenerateContractRequest {
    memberId: string;
}

export class GeneratePolicyNumberRequestDto implements IGeneratePolicyNumberRequestDto {
    memberId!: string | undefined;

    constructor(data?: IGeneratePolicyNumberRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
        }
    }

    static fromJS(data: any): GeneratePolicyNumberRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneratePolicyNumberRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        return data;
    }
}

export interface IGeneratePolicyNumberRequestDto {
    memberId: string | undefined;
}

export class GeneratePolicyNumberResponseDto implements IGeneratePolicyNumberResponseDto {
    policyNumber!: string | undefined;
    generationStrategy!: string | undefined;
    message!: string | undefined;

    constructor(data?: IGeneratePolicyNumberResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.policyNumber = _data["policyNumber"];
            this.generationStrategy = _data["generationStrategy"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): GeneratePolicyNumberResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneratePolicyNumberResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyNumber"] = this.policyNumber;
        data["generationStrategy"] = this.generationStrategy;
        data["message"] = this.message;
        return data;
    }
}

export interface IGeneratePolicyNumberResponseDto {
    policyNumber: string | undefined;
    generationStrategy: string | undefined;
    message: string | undefined;
}

export class InitiatePaymentRequest implements IInitiatePaymentRequest {
    invoiceId!: string;
    amount!: number;
    provider!: PaymentGatewayProvider;
    returnUrl!: string | undefined;

    constructor(data?: IInitiatePaymentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            this.amount = _data["amount"];
            this.provider = _data["provider"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): InitiatePaymentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InitiatePaymentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["amount"] = this.amount;
        data["provider"] = this.provider;
        data["returnUrl"] = this.returnUrl;
        return data;
    }
}

export interface IInitiatePaymentRequest {
    invoiceId: string;
    amount: number;
    provider: PaymentGatewayProvider;
    returnUrl: string | undefined;
}

export class InspectionCheckpoint implements IInspectionCheckpoint {
    checkpoint!: string | undefined;
    status!: CheckpointStatus;
    readonly statusName!: string | undefined;
    notes!: string | undefined;

    constructor(data?: IInspectionCheckpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkpoint = _data["checkpoint"];
            this.status = _data["status"];
            (this as any).statusName = _data["statusName"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): InspectionCheckpoint {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionCheckpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkpoint"] = this.checkpoint;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IInspectionCheckpoint {
    checkpoint: string | undefined;
    status: CheckpointStatus;
    statusName: string | undefined;
    notes: string | undefined;
}

export class InspectionLogDto implements IInspectionLogDto {
    inspectionType!: InspectionType;
    checkpoints!: InspectionCheckpoint[] | undefined;
    overallResult!: InspectionResult;
    notes!: string | undefined;
    issuesFound!: boolean;
    issueDescription!: string | undefined;
    inspectorSignature!: string | undefined;

    constructor(data?: IInspectionLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inspectionType = _data["inspectionType"];
            if (Array.isArray(_data["checkpoints"])) {
                this.checkpoints = [] as any;
                for (let item of _data["checkpoints"])
                    this.checkpoints!.push(InspectionCheckpoint.fromJS(item));
            }
            this.overallResult = _data["overallResult"];
            this.notes = _data["notes"];
            this.issuesFound = _data["issuesFound"];
            this.issueDescription = _data["issueDescription"];
            this.inspectorSignature = _data["inspectorSignature"];
        }
    }

    static fromJS(data: any): InspectionLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspectionType"] = this.inspectionType;
        if (Array.isArray(this.checkpoints)) {
            data["checkpoints"] = [];
            for (let item of this.checkpoints)
                data["checkpoints"].push(item ? item.toJSON() : undefined as any);
        }
        data["overallResult"] = this.overallResult;
        data["notes"] = this.notes;
        data["issuesFound"] = this.issuesFound;
        data["issueDescription"] = this.issueDescription;
        data["inspectorSignature"] = this.inspectorSignature;
        return data;
    }
}

export interface IInspectionLogDto {
    inspectionType: InspectionType;
    checkpoints: InspectionCheckpoint[] | undefined;
    overallResult: InspectionResult;
    notes: string | undefined;
    issuesFound: boolean;
    issueDescription: string | undefined;
    inspectorSignature: string | undefined;
}

export enum InspectionResult {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum InspectionType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class JsonNode implements IJsonNode {
    options!: JsonNodeOptions;
    parent!: JsonNode;
    root!: JsonNode;

    constructor(data?: IJsonNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.options = _data["options"] ? JsonNodeOptions.fromJS(_data["options"]) : undefined as any;
            this.parent = _data["parent"] ? JsonNode.fromJS(_data["parent"]) : undefined as any;
            this.root = _data["root"] ? JsonNode.fromJS(_data["root"]) : undefined as any;
        }
    }

    static fromJS(data: any): JsonNode {
        data = typeof data === 'object' ? data : {};
        let result = new JsonNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["options"] = this.options ? this.options.toJSON() : undefined as any;
        data["parent"] = this.parent ? this.parent.toJSON() : undefined as any;
        data["root"] = this.root ? this.root.toJSON() : undefined as any;
        return data;
    }
}

export interface IJsonNode {
    options: JsonNodeOptions;
    parent: JsonNode;
    root: JsonNode;
}

export class JsonNodeOptions implements IJsonNodeOptions {
    propertyNameCaseInsensitive!: boolean;

    constructor(data?: IJsonNodeOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyNameCaseInsensitive = _data["propertyNameCaseInsensitive"];
        }
    }

    static fromJS(data: any): JsonNodeOptions {
        data = typeof data === 'object' ? data : {};
        let result = new JsonNodeOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyNameCaseInsensitive"] = this.propertyNameCaseInsensitive;
        return data;
    }
}

export interface IJsonNodeOptions {
    propertyNameCaseInsensitive: boolean;
}

export class LandingPageComponentDto implements ILandingPageComponentDto {
    id!: number | undefined;
    sortOrder!: number;
    componentType!: string | undefined;
    content!: JsonNode;
    column!: number;
    columnSpan!: number;
    row!: number;
    rowSpan!: number;
    fullWidth!: boolean;
    minHeight!: number | undefined;
    maxHeight!: number | undefined;
    padding!: number;
    margin!: number;
    backgroundColor!: string | undefined;
    borderRadius!: number;
    boxShadow!: string | undefined;
    zIndex!: number;
    responsiveConfig!: string | undefined;
    animationType!: string | undefined;
    animationDuration!: number;
    animationDelay!: number;
    animationEasing!: string | undefined;
    animationEnabled!: boolean;
    autoHeight!: boolean;
    hoverEffect!: string | undefined;

    constructor(data?: ILandingPageComponentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
            this.componentType = _data["componentType"];
            this.content = _data["content"] ? JsonNode.fromJS(_data["content"]) : undefined as any;
            this.column = _data["column"];
            this.columnSpan = _data["columnSpan"];
            this.row = _data["row"];
            this.rowSpan = _data["rowSpan"];
            this.fullWidth = _data["fullWidth"];
            this.minHeight = _data["minHeight"];
            this.maxHeight = _data["maxHeight"];
            this.padding = _data["padding"];
            this.margin = _data["margin"];
            this.backgroundColor = _data["backgroundColor"];
            this.borderRadius = _data["borderRadius"];
            this.boxShadow = _data["boxShadow"];
            this.zIndex = _data["zIndex"];
            this.responsiveConfig = _data["responsiveConfig"];
            this.animationType = _data["animationType"];
            this.animationDuration = _data["animationDuration"];
            this.animationDelay = _data["animationDelay"];
            this.animationEasing = _data["animationEasing"];
            this.animationEnabled = _data["animationEnabled"];
            this.autoHeight = _data["autoHeight"];
            this.hoverEffect = _data["hoverEffect"];
        }
    }

    static fromJS(data: any): LandingPageComponentDto {
        data = typeof data === 'object' ? data : {};
        let result = new LandingPageComponentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["componentType"] = this.componentType;
        data["content"] = this.content ? this.content.toJSON() : undefined as any;
        data["column"] = this.column;
        data["columnSpan"] = this.columnSpan;
        data["row"] = this.row;
        data["rowSpan"] = this.rowSpan;
        data["fullWidth"] = this.fullWidth;
        data["minHeight"] = this.minHeight;
        data["maxHeight"] = this.maxHeight;
        data["padding"] = this.padding;
        data["margin"] = this.margin;
        data["backgroundColor"] = this.backgroundColor;
        data["borderRadius"] = this.borderRadius;
        data["boxShadow"] = this.boxShadow;
        data["zIndex"] = this.zIndex;
        data["responsiveConfig"] = this.responsiveConfig;
        data["animationType"] = this.animationType;
        data["animationDuration"] = this.animationDuration;
        data["animationDelay"] = this.animationDelay;
        data["animationEasing"] = this.animationEasing;
        data["animationEnabled"] = this.animationEnabled;
        data["autoHeight"] = this.autoHeight;
        data["hoverEffect"] = this.hoverEffect;
        return data;
    }
}

export interface ILandingPageComponentDto {
    id: number | undefined;
    sortOrder: number;
    componentType: string | undefined;
    content: JsonNode;
    column: number;
    columnSpan: number;
    row: number;
    rowSpan: number;
    fullWidth: boolean;
    minHeight: number | undefined;
    maxHeight: number | undefined;
    padding: number;
    margin: number;
    backgroundColor: string | undefined;
    borderRadius: number;
    boxShadow: string | undefined;
    zIndex: number;
    responsiveConfig: string | undefined;
    animationType: string | undefined;
    animationDuration: number;
    animationDelay: number;
    animationEasing: string | undefined;
    animationEnabled: boolean;
    autoHeight: boolean;
    hoverEffect: string | undefined;
}

export class LandingPageDto implements ILandingPageDto {
    pageTitle!: string | undefined;
    metaDescription!: string | undefined;
    metaKeywords!: string | undefined;
    ogTitle!: string | undefined;
    ogDescription!: string | undefined;
    ogImage!: string | undefined;
    twitterCard!: string | undefined;
    canonicalUrl!: string | undefined;
    layouts!: LandingPageLayoutDto[] | undefined;

    constructor(data?: ILandingPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageTitle = _data["pageTitle"];
            this.metaDescription = _data["metaDescription"];
            this.metaKeywords = _data["metaKeywords"];
            this.ogTitle = _data["ogTitle"];
            this.ogDescription = _data["ogDescription"];
            this.ogImage = _data["ogImage"];
            this.twitterCard = _data["twitterCard"];
            this.canonicalUrl = _data["canonicalUrl"];
            if (Array.isArray(_data["layouts"])) {
                this.layouts = [] as any;
                for (let item of _data["layouts"])
                    this.layouts!.push(LandingPageLayoutDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LandingPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LandingPageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageTitle"] = this.pageTitle;
        data["metaDescription"] = this.metaDescription;
        data["metaKeywords"] = this.metaKeywords;
        data["ogTitle"] = this.ogTitle;
        data["ogDescription"] = this.ogDescription;
        data["ogImage"] = this.ogImage;
        data["twitterCard"] = this.twitterCard;
        data["canonicalUrl"] = this.canonicalUrl;
        if (Array.isArray(this.layouts)) {
            data["layouts"] = [];
            for (let item of this.layouts)
                data["layouts"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ILandingPageDto {
    pageTitle: string | undefined;
    metaDescription: string | undefined;
    metaKeywords: string | undefined;
    ogTitle: string | undefined;
    ogDescription: string | undefined;
    ogImage: string | undefined;
    twitterCard: string | undefined;
    canonicalUrl: string | undefined;
    layouts: LandingPageLayoutDto[] | undefined;
}

export class LandingPageLayoutDto implements ILandingPageLayoutDto {
    id!: number | undefined;
    sortOrder!: number;
    sectionType!: string | undefined;
    components!: LandingPageComponentDto[] | undefined;

    constructor(data?: ILandingPageLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
            this.sectionType = _data["sectionType"];
            if (Array.isArray(_data["components"])) {
                this.components = [] as any;
                for (let item of _data["components"])
                    this.components!.push(LandingPageComponentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LandingPageLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new LandingPageLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["sectionType"] = this.sectionType;
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ILandingPageLayoutDto {
    id: number | undefined;
    sortOrder: number;
    sectionType: string | undefined;
    components: LandingPageComponentDto[] | undefined;
}

export class LoginRequest implements ILoginRequest {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    email: string | undefined;
    password: string | undefined;
}

export class LookupDto implements ILookupDto {
    name!: string | undefined;
    value!: number;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface ILookupDto {
    name: string | undefined;
    value: number;
}

export class MemberApprovalDetailDto implements IMemberApprovalDetailDto {
    id!: string;
    title!: string | undefined;
    firstNames!: string | undefined;
    surname!: string | undefined;
    identificationNumber!: string | undefined;
    email!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    age!: number | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    postalCode!: string | undefined;
    sourceOfIncome!: string | undefined;
    sourceOfIncomeOther!: string | undefined;
    occupation!: string | undefined;
    workPhoneNumber!: string | undefined;
    nationality!: string | undefined;
    countryOfResidence!: string | undefined;
    isForeigner!: boolean;
    passportNumber!: string | undefined;
    workPermitNumber!: string | undefined;
    isReplacingExistingPolicy!: boolean;
    existingPolicyNumber!: string | undefined;
    existingInsurerName!: string | undefined;
    isIdVerified!: boolean;
    idVerifiedAt!: DateTime | undefined;
    isLifeVerified!: boolean;
    lifeVerifiedAt!: DateTime | undefined;
    signatureDataUrl!: string | undefined;
    signedAt!: DateTime | undefined;
    status!: string | undefined;
    createdDate!: DateTime | undefined;
    daysWaiting!: number;
    policyEnrollments!: PolicyEnrollmentSummary[] | undefined;
    dependents!: DependentSummary[] | undefined;
    beneficiaries!: BeneficiarySummary[] | undefined;
    customFields!: OnboardingFieldData[] | undefined;

    constructor(data?: IMemberApprovalDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.firstNames = _data["firstNames"];
            this.surname = _data["surname"];
            this.identificationNumber = _data["identificationNumber"];
            this.email = _data["email"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.age = _data["age"];
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.sourceOfIncome = _data["sourceOfIncome"];
            this.sourceOfIncomeOther = _data["sourceOfIncomeOther"];
            this.occupation = _data["occupation"];
            this.workPhoneNumber = _data["workPhoneNumber"];
            this.nationality = _data["nationality"];
            this.countryOfResidence = _data["countryOfResidence"];
            this.isForeigner = _data["isForeigner"];
            this.passportNumber = _data["passportNumber"];
            this.workPermitNumber = _data["workPermitNumber"];
            this.isReplacingExistingPolicy = _data["isReplacingExistingPolicy"];
            this.existingPolicyNumber = _data["existingPolicyNumber"];
            this.existingInsurerName = _data["existingInsurerName"];
            this.isIdVerified = _data["isIdVerified"];
            this.idVerifiedAt = _data["idVerifiedAt"] ? DateTime.fromISO(_data["idVerifiedAt"].toString()) : undefined as any;
            this.isLifeVerified = _data["isLifeVerified"];
            this.lifeVerifiedAt = _data["lifeVerifiedAt"] ? DateTime.fromISO(_data["lifeVerifiedAt"].toString()) : undefined as any;
            this.signatureDataUrl = _data["signatureDataUrl"];
            this.signedAt = _data["signedAt"] ? DateTime.fromISO(_data["signedAt"].toString()) : undefined as any;
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? DateTime.fromISO(_data["createdDate"].toString()) : undefined as any;
            this.daysWaiting = _data["daysWaiting"];
            if (Array.isArray(_data["policyEnrollments"])) {
                this.policyEnrollments = [] as any;
                for (let item of _data["policyEnrollments"])
                    this.policyEnrollments!.push(PolicyEnrollmentSummary.fromJS(item));
            }
            if (Array.isArray(_data["dependents"])) {
                this.dependents = [] as any;
                for (let item of _data["dependents"])
                    this.dependents!.push(DependentSummary.fromJS(item));
            }
            if (Array.isArray(_data["beneficiaries"])) {
                this.beneficiaries = [] as any;
                for (let item of _data["beneficiaries"])
                    this.beneficiaries!.push(BeneficiarySummary.fromJS(item));
            }
            if (Array.isArray(_data["customFields"])) {
                this.customFields = [] as any;
                for (let item of _data["customFields"])
                    this.customFields!.push(OnboardingFieldData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberApprovalDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberApprovalDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["firstNames"] = this.firstNames;
        data["surname"] = this.surname;
        data["identificationNumber"] = this.identificationNumber;
        data["email"] = this.email;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["age"] = this.age;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["sourceOfIncome"] = this.sourceOfIncome;
        data["sourceOfIncomeOther"] = this.sourceOfIncomeOther;
        data["occupation"] = this.occupation;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["nationality"] = this.nationality;
        data["countryOfResidence"] = this.countryOfResidence;
        data["isForeigner"] = this.isForeigner;
        data["passportNumber"] = this.passportNumber;
        data["workPermitNumber"] = this.workPermitNumber;
        data["isReplacingExistingPolicy"] = this.isReplacingExistingPolicy;
        data["existingPolicyNumber"] = this.existingPolicyNumber;
        data["existingInsurerName"] = this.existingInsurerName;
        data["isIdVerified"] = this.isIdVerified;
        data["idVerifiedAt"] = this.idVerifiedAt ? this.idVerifiedAt.toString() : undefined as any;
        data["isLifeVerified"] = this.isLifeVerified;
        data["lifeVerifiedAt"] = this.lifeVerifiedAt ? this.lifeVerifiedAt.toString() : undefined as any;
        data["signatureDataUrl"] = this.signatureDataUrl;
        data["signedAt"] = this.signedAt ? this.signedAt.toString() : undefined as any;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toString() : undefined as any;
        data["daysWaiting"] = this.daysWaiting;
        if (Array.isArray(this.policyEnrollments)) {
            data["policyEnrollments"] = [];
            for (let item of this.policyEnrollments)
                data["policyEnrollments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.dependents)) {
            data["dependents"] = [];
            for (let item of this.dependents)
                data["dependents"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.beneficiaries)) {
            data["beneficiaries"] = [];
            for (let item of this.beneficiaries)
                data["beneficiaries"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.customFields)) {
            data["customFields"] = [];
            for (let item of this.customFields)
                data["customFields"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IMemberApprovalDetailDto {
    id: string;
    title: string | undefined;
    firstNames: string | undefined;
    surname: string | undefined;
    identificationNumber: string | undefined;
    email: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    dateOfBirth: DateTime | undefined;
    age: number | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    province: string | undefined;
    postalCode: string | undefined;
    sourceOfIncome: string | undefined;
    sourceOfIncomeOther: string | undefined;
    occupation: string | undefined;
    workPhoneNumber: string | undefined;
    nationality: string | undefined;
    countryOfResidence: string | undefined;
    isForeigner: boolean;
    passportNumber: string | undefined;
    workPermitNumber: string | undefined;
    isReplacingExistingPolicy: boolean;
    existingPolicyNumber: string | undefined;
    existingInsurerName: string | undefined;
    isIdVerified: boolean;
    idVerifiedAt: DateTime | undefined;
    isLifeVerified: boolean;
    lifeVerifiedAt: DateTime | undefined;
    signatureDataUrl: string | undefined;
    signedAt: DateTime | undefined;
    status: string | undefined;
    createdDate: DateTime | undefined;
    daysWaiting: number;
    policyEnrollments: PolicyEnrollmentSummary[] | undefined;
    dependents: DependentSummary[] | undefined;
    beneficiaries: BeneficiarySummary[] | undefined;
    customFields: OnboardingFieldData[] | undefined;
}

export class MemberBankingDetailDto implements IMemberBankingDetailDto {
    id!: string;
    memberId!: string;
    bankName!: string | undefined;
    accountNumber!: string | undefined;
    accountType!: string | undefined;
    branchCode!: string | undefined;
    branchName!: string | undefined;
    accountHolderName!: string | undefined;
    debitDay!: number | undefined;
    paymentMethod!: PaymentMethodType;
    isVerified!: boolean;
    createdAt!: DateTime;

    constructor(data?: IMemberBankingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.accountType = _data["accountType"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.accountHolderName = _data["accountHolderName"];
            this.debitDay = _data["debitDay"];
            this.paymentMethod = _data["paymentMethod"];
            this.isVerified = _data["isVerified"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): MemberBankingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberBankingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["accountType"] = this.accountType;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["accountHolderName"] = this.accountHolderName;
        data["debitDay"] = this.debitDay;
        data["paymentMethod"] = this.paymentMethod;
        data["isVerified"] = this.isVerified;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        return data;
    }
}

export interface IMemberBankingDetailDto {
    id: string;
    memberId: string;
    bankName: string | undefined;
    accountNumber: string | undefined;
    accountType: string | undefined;
    branchCode: string | undefined;
    branchName: string | undefined;
    accountHolderName: string | undefined;
    debitDay: number | undefined;
    paymentMethod: PaymentMethodType;
    isVerified: boolean;
    createdAt: DateTime;
}

export class MemberDocumentStatusDto implements IMemberDocumentStatusDto {
    memberId!: string;
    requiredDocuments!: RequiredDocumentDto[] | undefined;
    uploadedDocuments!: FileMetadataDto[] | undefined;
    missingDocuments!: RequiredDocumentDto[] | undefined;
    allRequiredDocumentsUploaded!: boolean;

    constructor(data?: IMemberDocumentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            if (Array.isArray(_data["requiredDocuments"])) {
                this.requiredDocuments = [] as any;
                for (let item of _data["requiredDocuments"])
                    this.requiredDocuments!.push(RequiredDocumentDto.fromJS(item));
            }
            if (Array.isArray(_data["uploadedDocuments"])) {
                this.uploadedDocuments = [] as any;
                for (let item of _data["uploadedDocuments"])
                    this.uploadedDocuments!.push(FileMetadataDto.fromJS(item));
            }
            if (Array.isArray(_data["missingDocuments"])) {
                this.missingDocuments = [] as any;
                for (let item of _data["missingDocuments"])
                    this.missingDocuments!.push(RequiredDocumentDto.fromJS(item));
            }
            this.allRequiredDocumentsUploaded = _data["allRequiredDocumentsUploaded"];
        }
    }

    static fromJS(data: any): MemberDocumentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDocumentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        if (Array.isArray(this.requiredDocuments)) {
            data["requiredDocuments"] = [];
            for (let item of this.requiredDocuments)
                data["requiredDocuments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.uploadedDocuments)) {
            data["uploadedDocuments"] = [];
            for (let item of this.uploadedDocuments)
                data["uploadedDocuments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.missingDocuments)) {
            data["missingDocuments"] = [];
            for (let item of this.missingDocuments)
                data["missingDocuments"].push(item ? item.toJSON() : undefined as any);
        }
        data["allRequiredDocumentsUploaded"] = this.allRequiredDocumentsUploaded;
        return data;
    }
}

export interface IMemberDocumentStatusDto {
    memberId: string;
    requiredDocuments: RequiredDocumentDto[] | undefined;
    uploadedDocuments: FileMetadataDto[] | undefined;
    missingDocuments: RequiredDocumentDto[] | undefined;
    allRequiredDocumentsUploaded: boolean;
}

export enum MemberDocumentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _99 = 99,
}

export class MemberDto implements IMemberDto {
    id!: string;
    name!: string | undefined;
    address!: string | undefined;
    title!: string | undefined;
    firstNames!: string | undefined;
    surname!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    email!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    identificationNumber!: string | undefined;
    sourceOfIncome!: SourceOfIncome;
    sourceOfIncomeOther!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    province!: SouthAfricanProvince;
    postalCode!: string | undefined;
    isReplacingExistingPolicy!: boolean;
    existingPolicyNumber!: string | undefined;
    existingInsurerName!: string | undefined;
    existingPolicyPaidUpToDate!: boolean | undefined;
    existingPolicyWaitingPeriodExpired!: boolean | undefined;
    sameBenefitAsExistingPolicy!: boolean | undefined;
    benefitDifferenceNotes!: string | undefined;
    occupation!: string | undefined;
    workPhoneNumber!: string | undefined;
    passportNumber!: string | undefined;
    countryOfBirth!: string | undefined;
    countryOfResidence!: string | undefined;
    citizenship!: string | undefined;
    nationality!: string | undefined;
    isForeigner!: boolean;
    workPermitNumber!: string | undefined;
    status!: MemberStatus;
    paymentStatus!: PaymentStatus;
    nextPaymentDate!: DateTime | undefined;
    signatureDataUrl!: string | undefined;
    signedAt!: DateTime | undefined;
    dependents!: DependentDto[] | undefined;
    beneficiaries!: BeneficiaryDto[] | undefined;
    policyEnrollments!: PolicyEnrollmentDto[] | undefined;

    constructor(data?: IMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.title = _data["title"];
            this.firstNames = _data["firstNames"];
            this.surname = _data["surname"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.email = _data["email"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.identificationNumber = _data["identificationNumber"];
            this.sourceOfIncome = _data["sourceOfIncome"];
            this.sourceOfIncomeOther = _data["sourceOfIncomeOther"];
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.isReplacingExistingPolicy = _data["isReplacingExistingPolicy"];
            this.existingPolicyNumber = _data["existingPolicyNumber"];
            this.existingInsurerName = _data["existingInsurerName"];
            this.existingPolicyPaidUpToDate = _data["existingPolicyPaidUpToDate"];
            this.existingPolicyWaitingPeriodExpired = _data["existingPolicyWaitingPeriodExpired"];
            this.sameBenefitAsExistingPolicy = _data["sameBenefitAsExistingPolicy"];
            this.benefitDifferenceNotes = _data["benefitDifferenceNotes"];
            this.occupation = _data["occupation"];
            this.workPhoneNumber = _data["workPhoneNumber"];
            this.passportNumber = _data["passportNumber"];
            this.countryOfBirth = _data["countryOfBirth"];
            this.countryOfResidence = _data["countryOfResidence"];
            this.citizenship = _data["citizenship"];
            this.nationality = _data["nationality"];
            this.isForeigner = _data["isForeigner"];
            this.workPermitNumber = _data["workPermitNumber"];
            this.status = _data["status"];
            this.paymentStatus = _data["paymentStatus"];
            this.nextPaymentDate = _data["nextPaymentDate"] ? DateTime.fromISO(_data["nextPaymentDate"].toString()) : undefined as any;
            this.signatureDataUrl = _data["signatureDataUrl"];
            this.signedAt = _data["signedAt"] ? DateTime.fromISO(_data["signedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["dependents"])) {
                this.dependents = [] as any;
                for (let item of _data["dependents"])
                    this.dependents!.push(DependentDto.fromJS(item));
            }
            if (Array.isArray(_data["beneficiaries"])) {
                this.beneficiaries = [] as any;
                for (let item of _data["beneficiaries"])
                    this.beneficiaries!.push(BeneficiaryDto.fromJS(item));
            }
            if (Array.isArray(_data["policyEnrollments"])) {
                this.policyEnrollments = [] as any;
                for (let item of _data["policyEnrollments"])
                    this.policyEnrollments!.push(PolicyEnrollmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address;
        data["title"] = this.title;
        data["firstNames"] = this.firstNames;
        data["surname"] = this.surname;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["email"] = this.email;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["identificationNumber"] = this.identificationNumber;
        data["sourceOfIncome"] = this.sourceOfIncome;
        data["sourceOfIncomeOther"] = this.sourceOfIncomeOther;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["isReplacingExistingPolicy"] = this.isReplacingExistingPolicy;
        data["existingPolicyNumber"] = this.existingPolicyNumber;
        data["existingInsurerName"] = this.existingInsurerName;
        data["existingPolicyPaidUpToDate"] = this.existingPolicyPaidUpToDate;
        data["existingPolicyWaitingPeriodExpired"] = this.existingPolicyWaitingPeriodExpired;
        data["sameBenefitAsExistingPolicy"] = this.sameBenefitAsExistingPolicy;
        data["benefitDifferenceNotes"] = this.benefitDifferenceNotes;
        data["occupation"] = this.occupation;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["passportNumber"] = this.passportNumber;
        data["countryOfBirth"] = this.countryOfBirth;
        data["countryOfResidence"] = this.countryOfResidence;
        data["citizenship"] = this.citizenship;
        data["nationality"] = this.nationality;
        data["isForeigner"] = this.isForeigner;
        data["workPermitNumber"] = this.workPermitNumber;
        data["status"] = this.status;
        data["paymentStatus"] = this.paymentStatus;
        data["nextPaymentDate"] = this.nextPaymentDate ? this.nextPaymentDate.toString() : undefined as any;
        data["signatureDataUrl"] = this.signatureDataUrl;
        data["signedAt"] = this.signedAt ? this.signedAt.toString() : undefined as any;
        if (Array.isArray(this.dependents)) {
            data["dependents"] = [];
            for (let item of this.dependents)
                data["dependents"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.beneficiaries)) {
            data["beneficiaries"] = [];
            for (let item of this.beneficiaries)
                data["beneficiaries"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.policyEnrollments)) {
            data["policyEnrollments"] = [];
            for (let item of this.policyEnrollments)
                data["policyEnrollments"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IMemberDto {
    id: string;
    name: string | undefined;
    address: string | undefined;
    title: string | undefined;
    firstNames: string | undefined;
    surname: string | undefined;
    dateOfBirth: DateTime | undefined;
    email: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    identificationNumber: string | undefined;
    sourceOfIncome: SourceOfIncome;
    sourceOfIncomeOther: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    province: SouthAfricanProvince;
    postalCode: string | undefined;
    isReplacingExistingPolicy: boolean;
    existingPolicyNumber: string | undefined;
    existingInsurerName: string | undefined;
    existingPolicyPaidUpToDate: boolean | undefined;
    existingPolicyWaitingPeriodExpired: boolean | undefined;
    sameBenefitAsExistingPolicy: boolean | undefined;
    benefitDifferenceNotes: string | undefined;
    occupation: string | undefined;
    workPhoneNumber: string | undefined;
    passportNumber: string | undefined;
    countryOfBirth: string | undefined;
    countryOfResidence: string | undefined;
    citizenship: string | undefined;
    nationality: string | undefined;
    isForeigner: boolean;
    workPermitNumber: string | undefined;
    status: MemberStatus;
    paymentStatus: PaymentStatus;
    nextPaymentDate: DateTime | undefined;
    signatureDataUrl: string | undefined;
    signedAt: DateTime | undefined;
    dependents: DependentDto[] | undefined;
    beneficiaries: BeneficiaryDto[] | undefined;
    policyEnrollments: PolicyEnrollmentDto[] | undefined;
}

export class MemberOnboardingDataDto implements IMemberOnboardingDataDto {
    memberId!: string;
    tenantId!: string;
    fieldValues!: { [key: string]: string; } | undefined;
    submittedAt!: DateTime | undefined;

    constructor(data?: IMemberOnboardingDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.tenantId = _data["tenantId"];
            if (_data["fieldValues"]) {
                this.fieldValues = {} as any;
                for (let key in _data["fieldValues"]) {
                    if (_data["fieldValues"].hasOwnProperty(key))
                        (this.fieldValues as any)![key] = _data["fieldValues"][key];
                }
            }
            this.submittedAt = _data["submittedAt"] ? DateTime.fromISO(_data["submittedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): MemberOnboardingDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberOnboardingDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["tenantId"] = this.tenantId;
        if (this.fieldValues) {
            data["fieldValues"] = {};
            for (let key in this.fieldValues) {
                if (this.fieldValues.hasOwnProperty(key))
                    (data["fieldValues"] as any)[key] = (this.fieldValues as any)[key];
            }
        }
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toString() : undefined as any;
        return data;
    }
}

export interface IMemberOnboardingDataDto {
    memberId: string;
    tenantId: string;
    fieldValues: { [key: string]: string; } | undefined;
    submittedAt: DateTime | undefined;
}

export class MemberProfileCompletionDto implements IMemberProfileCompletionDto {
    id!: string;
    memberId!: string;
    hasDependents!: boolean;
    hasBeneficiaries!: boolean;
    hasUploadedIdDocument!: boolean;
    hasAcceptedTerms!: boolean;
    hasCompletedCustomForms!: boolean;
    hasUploadedRequiredDocuments!: boolean;
    isProfileComplete!: boolean;
    profileCompletedAt!: DateTime | undefined;
    completionPercentage!: number;
    nextStepRecommendation!: string | undefined;

    constructor(data?: IMemberProfileCompletionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.hasDependents = _data["hasDependents"];
            this.hasBeneficiaries = _data["hasBeneficiaries"];
            this.hasUploadedIdDocument = _data["hasUploadedIdDocument"];
            this.hasAcceptedTerms = _data["hasAcceptedTerms"];
            this.hasCompletedCustomForms = _data["hasCompletedCustomForms"];
            this.hasUploadedRequiredDocuments = _data["hasUploadedRequiredDocuments"];
            this.isProfileComplete = _data["isProfileComplete"];
            this.profileCompletedAt = _data["profileCompletedAt"] ? DateTime.fromISO(_data["profileCompletedAt"].toString()) : undefined as any;
            this.completionPercentage = _data["completionPercentage"];
            this.nextStepRecommendation = _data["nextStepRecommendation"];
        }
    }

    static fromJS(data: any): MemberProfileCompletionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberProfileCompletionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["hasDependents"] = this.hasDependents;
        data["hasBeneficiaries"] = this.hasBeneficiaries;
        data["hasUploadedIdDocument"] = this.hasUploadedIdDocument;
        data["hasAcceptedTerms"] = this.hasAcceptedTerms;
        data["hasCompletedCustomForms"] = this.hasCompletedCustomForms;
        data["hasUploadedRequiredDocuments"] = this.hasUploadedRequiredDocuments;
        data["isProfileComplete"] = this.isProfileComplete;
        data["profileCompletedAt"] = this.profileCompletedAt ? this.profileCompletedAt.toString() : undefined as any;
        data["completionPercentage"] = this.completionPercentage;
        data["nextStepRecommendation"] = this.nextStepRecommendation;
        return data;
    }
}

export interface IMemberProfileCompletionDto {
    id: string;
    memberId: string;
    hasDependents: boolean;
    hasBeneficiaries: boolean;
    hasUploadedIdDocument: boolean;
    hasAcceptedTerms: boolean;
    hasCompletedCustomForms: boolean;
    hasUploadedRequiredDocuments: boolean;
    isProfileComplete: boolean;
    profileCompletedAt: DateTime | undefined;
    completionPercentage: number;
    nextStepRecommendation: string | undefined;
}

export enum MemberStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class OnboardingContractDto implements IOnboardingContractDto {
    id!: string;
    tenantId!: string;
    memberId!: string;
    templateFileId!: string | undefined;
    generatedPdfPath!: string | undefined;
    signedPdfPath!: string | undefined;
    signatureImagePath!: string | undefined;
    ipAddress!: string | undefined;
    signedAt!: DateTime | undefined;
    isLegallyBinding!: boolean;
    documentHash!: string | undefined;
    signedDocumentHash!: string | undefined;

    constructor(data?: IOnboardingContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.memberId = _data["memberId"];
            this.templateFileId = _data["templateFileId"];
            this.generatedPdfPath = _data["generatedPdfPath"];
            this.signedPdfPath = _data["signedPdfPath"];
            this.signatureImagePath = _data["signatureImagePath"];
            this.ipAddress = _data["ipAddress"];
            this.signedAt = _data["signedAt"] ? DateTime.fromISO(_data["signedAt"].toString()) : undefined as any;
            this.isLegallyBinding = _data["isLegallyBinding"];
            this.documentHash = _data["documentHash"];
            this.signedDocumentHash = _data["signedDocumentHash"];
        }
    }

    static fromJS(data: any): OnboardingContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["memberId"] = this.memberId;
        data["templateFileId"] = this.templateFileId;
        data["generatedPdfPath"] = this.generatedPdfPath;
        data["signedPdfPath"] = this.signedPdfPath;
        data["signatureImagePath"] = this.signatureImagePath;
        data["ipAddress"] = this.ipAddress;
        data["signedAt"] = this.signedAt ? this.signedAt.toString() : undefined as any;
        data["isLegallyBinding"] = this.isLegallyBinding;
        data["documentHash"] = this.documentHash;
        data["signedDocumentHash"] = this.signedDocumentHash;
        return data;
    }
}

export interface IOnboardingContractDto {
    id: string;
    tenantId: string;
    memberId: string;
    templateFileId: string | undefined;
    generatedPdfPath: string | undefined;
    signedPdfPath: string | undefined;
    signatureImagePath: string | undefined;
    ipAddress: string | undefined;
    signedAt: DateTime | undefined;
    isLegallyBinding: boolean;
    documentHash: string | undefined;
    signedDocumentHash: string | undefined;
}

export class OnboardingFieldConfigurationDto implements IOnboardingFieldConfigurationDto {
    id!: string;
    tenantId!: string;
    fieldKey!: string | undefined;
    fieldLabel!: string | undefined;
    fieldType!: string | undefined;
    category!: string | undefined;
    isRequired!: boolean;
    isEnabled!: boolean;
    displayOrder!: number;
    placeholder!: string | undefined;
    helpText!: string | undefined;
    optionsJson!: string | undefined;
    validationRulesJson!: string | undefined;
    defaultValue!: string | undefined;
    maxLength!: number | undefined;
    minLength!: number | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime | undefined;

    constructor(data?: IOnboardingFieldConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fieldKey = _data["fieldKey"];
            this.fieldLabel = _data["fieldLabel"];
            this.fieldType = _data["fieldType"];
            this.category = _data["category"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.placeholder = _data["placeholder"];
            this.helpText = _data["helpText"];
            this.optionsJson = _data["optionsJson"];
            this.validationRulesJson = _data["validationRulesJson"];
            this.defaultValue = _data["defaultValue"];
            this.maxLength = _data["maxLength"];
            this.minLength = _data["minLength"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): OnboardingFieldConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingFieldConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fieldKey"] = this.fieldKey;
        data["fieldLabel"] = this.fieldLabel;
        data["fieldType"] = this.fieldType;
        data["category"] = this.category;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["placeholder"] = this.placeholder;
        data["helpText"] = this.helpText;
        data["optionsJson"] = this.optionsJson;
        data["validationRulesJson"] = this.validationRulesJson;
        data["defaultValue"] = this.defaultValue;
        data["maxLength"] = this.maxLength;
        data["minLength"] = this.minLength;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IOnboardingFieldConfigurationDto {
    id: string;
    tenantId: string;
    fieldKey: string | undefined;
    fieldLabel: string | undefined;
    fieldType: string | undefined;
    category: string | undefined;
    isRequired: boolean;
    isEnabled: boolean;
    displayOrder: number;
    placeholder: string | undefined;
    helpText: string | undefined;
    optionsJson: string | undefined;
    validationRulesJson: string | undefined;
    defaultValue: string | undefined;
    maxLength: number | undefined;
    minLength: number | undefined;
    createdAt: DateTime;
    updatedAt: DateTime | undefined;
}

export class OnboardingFieldData implements IOnboardingFieldData {
    fieldKey!: string | undefined;
    fieldLabel!: string | undefined;
    fieldValue!: string | undefined;
    fieldType!: string | undefined;

    constructor(data?: IOnboardingFieldData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldKey = _data["fieldKey"];
            this.fieldLabel = _data["fieldLabel"];
            this.fieldValue = _data["fieldValue"];
            this.fieldType = _data["fieldType"];
        }
    }

    static fromJS(data: any): OnboardingFieldData {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingFieldData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldKey"] = this.fieldKey;
        data["fieldLabel"] = this.fieldLabel;
        data["fieldValue"] = this.fieldValue;
        data["fieldType"] = this.fieldType;
        return data;
    }
}

export interface IOnboardingFieldData {
    fieldKey: string | undefined;
    fieldLabel: string | undefined;
    fieldValue: string | undefined;
    fieldType: string | undefined;
}

export class PaymentGatewayConfigDto implements IPaymentGatewayConfigDto {
    id!: string;
    tenantId!: string;
    provider!: PaymentGatewayProvider;
    merchantId!: string | undefined;
    siteCode!: string | undefined;
    isActive!: boolean;
    isTestMode!: boolean;
    webhookUrl!: string | undefined;
    returnUrl!: string | undefined;
    cancelUrl!: string | undefined;
    apiKey!: string | undefined;
    secretKey!: string | undefined;
    passPhrase!: string | undefined;

    constructor(data?: IPaymentGatewayConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.provider = _data["provider"];
            this.merchantId = _data["merchantId"];
            this.siteCode = _data["siteCode"];
            this.isActive = _data["isActive"];
            this.isTestMode = _data["isTestMode"];
            this.webhookUrl = _data["webhookUrl"];
            this.returnUrl = _data["returnUrl"];
            this.cancelUrl = _data["cancelUrl"];
            this.apiKey = _data["apiKey"];
            this.secretKey = _data["secretKey"];
            this.passPhrase = _data["passPhrase"];
        }
    }

    static fromJS(data: any): PaymentGatewayConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["provider"] = this.provider;
        data["merchantId"] = this.merchantId;
        data["siteCode"] = this.siteCode;
        data["isActive"] = this.isActive;
        data["isTestMode"] = this.isTestMode;
        data["webhookUrl"] = this.webhookUrl;
        data["returnUrl"] = this.returnUrl;
        data["cancelUrl"] = this.cancelUrl;
        data["apiKey"] = this.apiKey;
        data["secretKey"] = this.secretKey;
        data["passPhrase"] = this.passPhrase;
        return data;
    }
}

export interface IPaymentGatewayConfigDto {
    id: string;
    tenantId: string;
    provider: PaymentGatewayProvider;
    merchantId: string | undefined;
    siteCode: string | undefined;
    isActive: boolean;
    isTestMode: boolean;
    webhookUrl: string | undefined;
    returnUrl: string | undefined;
    cancelUrl: string | undefined;
    apiKey: string | undefined;
    secretKey: string | undefined;
    passPhrase: string | undefined;
}

export enum PaymentGatewayProvider {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum PaymentMethodType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum PaymentStatus {
    _0 = 0,
    _1 = 1,
}

export class PdfFieldMappingDto implements IPdfFieldMappingDto {
    id!: string;
    tenantId!: string;
    sourceField!: string | undefined;
    pdfFieldName!: string | undefined;
    mappingType!: string | undefined;
    isEnabled!: boolean;
    displayOrder!: number;
    description!: string | undefined;
    conditionalRulesJson!: string | undefined;
    transformRule!: string | undefined;
    defaultValue!: string | undefined;
    checkedValue!: string | undefined;
    uncheckedValue!: string | undefined;
    category!: string | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: IPdfFieldMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.sourceField = _data["sourceField"];
            this.pdfFieldName = _data["pdfFieldName"];
            this.mappingType = _data["mappingType"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.description = _data["description"];
            this.conditionalRulesJson = _data["conditionalRulesJson"];
            this.transformRule = _data["transformRule"];
            this.defaultValue = _data["defaultValue"];
            this.checkedValue = _data["checkedValue"];
            this.uncheckedValue = _data["uncheckedValue"];
            this.category = _data["category"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): PdfFieldMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfFieldMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["sourceField"] = this.sourceField;
        data["pdfFieldName"] = this.pdfFieldName;
        data["mappingType"] = this.mappingType;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["description"] = this.description;
        data["conditionalRulesJson"] = this.conditionalRulesJson;
        data["transformRule"] = this.transformRule;
        data["defaultValue"] = this.defaultValue;
        data["checkedValue"] = this.checkedValue;
        data["uncheckedValue"] = this.uncheckedValue;
        data["category"] = this.category;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IPdfFieldMappingDto {
    id: string;
    tenantId: string;
    sourceField: string | undefined;
    pdfFieldName: string | undefined;
    mappingType: string | undefined;
    isEnabled: boolean;
    displayOrder: number;
    description: string | undefined;
    conditionalRulesJson: string | undefined;
    transformRule: string | undefined;
    defaultValue: string | undefined;
    checkedValue: string | undefined;
    uncheckedValue: string | undefined;
    category: string | undefined;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class PdfTemplateAnalysisResult implements IPdfTemplateAnalysisResult {
    templateFileId!: string;
    totalFields!: number;
    mappedFields!: number;
    unmappedFields!: number;
    fields!: PdfTemplateFieldInfo[] | undefined;
    suggestedSourceFields!: string[] | undefined;

    constructor(data?: IPdfTemplateAnalysisResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateFileId = _data["templateFileId"];
            this.totalFields = _data["totalFields"];
            this.mappedFields = _data["mappedFields"];
            this.unmappedFields = _data["unmappedFields"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(PdfTemplateFieldInfo.fromJS(item));
            }
            if (Array.isArray(_data["suggestedSourceFields"])) {
                this.suggestedSourceFields = [] as any;
                for (let item of _data["suggestedSourceFields"])
                    this.suggestedSourceFields!.push(item);
            }
        }
    }

    static fromJS(data: any): PdfTemplateAnalysisResult {
        data = typeof data === 'object' ? data : {};
        let result = new PdfTemplateAnalysisResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateFileId"] = this.templateFileId;
        data["totalFields"] = this.totalFields;
        data["mappedFields"] = this.mappedFields;
        data["unmappedFields"] = this.unmappedFields;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.suggestedSourceFields)) {
            data["suggestedSourceFields"] = [];
            for (let item of this.suggestedSourceFields)
                data["suggestedSourceFields"].push(item);
        }
        return data;
    }
}

export interface IPdfTemplateAnalysisResult {
    templateFileId: string;
    totalFields: number;
    mappedFields: number;
    unmappedFields: number;
    fields: PdfTemplateFieldInfo[] | undefined;
    suggestedSourceFields: string[] | undefined;
}

export class PdfTemplateFieldInfo implements IPdfTemplateFieldInfo {
    fieldName!: string | undefined;
    fieldType!: string | undefined;
    isMapped!: boolean;
    mappedSourceField!: string | undefined;
    mappingType!: string | undefined;

    constructor(data?: IPdfTemplateFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.fieldType = _data["fieldType"];
            this.isMapped = _data["isMapped"];
            this.mappedSourceField = _data["mappedSourceField"];
            this.mappingType = _data["mappingType"];
        }
    }

    static fromJS(data: any): PdfTemplateFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PdfTemplateFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["fieldType"] = this.fieldType;
        data["isMapped"] = this.isMapped;
        data["mappedSourceField"] = this.mappedSourceField;
        data["mappingType"] = this.mappingType;
        return data;
    }
}

export interface IPdfTemplateFieldInfo {
    fieldName: string | undefined;
    fieldType: string | undefined;
    isMapped: boolean;
    mappedSourceField: string | undefined;
    mappingType: string | undefined;
}

export class PendingMemberDto implements IPendingMemberDto {
    id!: string;
    title!: string | undefined;
    firstNames!: string | undefined;
    surname!: string | undefined;
    identificationNumber!: string | undefined;
    email!: string | undefined;
    phone1!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    city!: string | undefined;
    province!: string | undefined;
    createdDate!: DateTime | undefined;
    status!: string | undefined;
    isIdVerified!: boolean;
    daysWaiting!: number;
    policyNames!: string[] | undefined;

    constructor(data?: IPendingMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.firstNames = _data["firstNames"];
            this.surname = _data["surname"];
            this.identificationNumber = _data["identificationNumber"];
            this.email = _data["email"];
            this.phone1 = _data["phone1"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.city = _data["city"];
            this.province = _data["province"];
            this.createdDate = _data["createdDate"] ? DateTime.fromISO(_data["createdDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.isIdVerified = _data["isIdVerified"];
            this.daysWaiting = _data["daysWaiting"];
            if (Array.isArray(_data["policyNames"])) {
                this.policyNames = [] as any;
                for (let item of _data["policyNames"])
                    this.policyNames!.push(item);
            }
        }
    }

    static fromJS(data: any): PendingMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new PendingMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["firstNames"] = this.firstNames;
        data["surname"] = this.surname;
        data["identificationNumber"] = this.identificationNumber;
        data["email"] = this.email;
        data["phone1"] = this.phone1;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["city"] = this.city;
        data["province"] = this.province;
        data["createdDate"] = this.createdDate ? this.createdDate.toString() : undefined as any;
        data["status"] = this.status;
        data["isIdVerified"] = this.isIdVerified;
        data["daysWaiting"] = this.daysWaiting;
        if (Array.isArray(this.policyNames)) {
            data["policyNames"] = [];
            for (let item of this.policyNames)
                data["policyNames"].push(item);
        }
        return data;
    }
}

export interface IPendingMemberDto {
    id: string;
    title: string | undefined;
    firstNames: string | undefined;
    surname: string | undefined;
    identificationNumber: string | undefined;
    email: string | undefined;
    phone1: string | undefined;
    dateOfBirth: DateTime | undefined;
    city: string | undefined;
    province: string | undefined;
    createdDate: DateTime | undefined;
    status: string | undefined;
    isIdVerified: boolean;
    daysWaiting: number;
    policyNames: string[] | undefined;
}

export class Permission implements IPermission {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    name!: string;
    tenantId!: string;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IPermission {
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    name: string;
    tenantId: string;
}

export class PermissionDto implements IPermissionDto {
    id!: string;
    name!: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IPermissionDto {
    id: string;
    name: string | undefined;
}

export class PermissionInput implements IPermissionInput {
    name!: string | undefined;
    id!: string;

    constructor(data?: IPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IPermissionInput {
    name: string | undefined;
    id: string;
}

export class PolicyAttributeDto implements IPolicyAttributeDto {
    id!: string;
    property!: string | undefined;
    value!: string | undefined;
    dataType!: string | undefined;
    description!: string | undefined;
    isIncluded!: boolean;
    policyId!: string;

    constructor(data?: IPolicyAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.property = _data["property"];
            this.value = _data["value"];
            this.dataType = _data["dataType"];
            this.description = _data["description"];
            this.isIncluded = _data["isIncluded"];
            this.policyId = _data["policyId"];
        }
    }

    static fromJS(data: any): PolicyAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["property"] = this.property;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["description"] = this.description;
        data["isIncluded"] = this.isIncluded;
        data["policyId"] = this.policyId;
        return data;
    }
}

export interface IPolicyAttributeDto {
    id: string;
    property: string | undefined;
    value: string | undefined;
    dataType: string | undefined;
    description: string | undefined;
    isIncluded: boolean;
    policyId: string;
}

export class PolicyCoverAgeBracketDto implements IPolicyCoverAgeBracketDto {
    maxAge!: number;
    label!: string | undefined;
    premium!: number;

    constructor(data?: IPolicyCoverAgeBracketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxAge = _data["maxAge"];
            this.label = _data["label"];
            this.premium = _data["premium"];
        }
    }

    static fromJS(data: any): PolicyCoverAgeBracketDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyCoverAgeBracketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxAge"] = this.maxAge;
        data["label"] = this.label;
        data["premium"] = this.premium;
        return data;
    }
}

export interface IPolicyCoverAgeBracketDto {
    maxAge: number;
    label: string | undefined;
    premium: number;
}

export class PolicyCoverPremiumTableDto implements IPolicyCoverPremiumTableDto {
    rows!: PolicyCoverRowDto[] | undefined;

    constructor(data?: IPolicyCoverPremiumTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(PolicyCoverRowDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PolicyCoverPremiumTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyCoverPremiumTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IPolicyCoverPremiumTableDto {
    rows: PolicyCoverRowDto[] | undefined;
}

export class PolicyCoverRowDto implements IPolicyCoverRowDto {
    coverAmount!: number;
    dependentCountTiers!: DependentCountTierDto[] | undefined;
    ageBrackets!: { [key: string]: PolicyCoverAgeBracketDto; } | undefined;
    premium_1To5Dependents_Under65!: number;
    premium_1To5Dependents_Under70!: number;
    premium_1To5Dependents_Under75!: number;
    premium_1To5Dependents_75Plus!: number;

    constructor(data?: IPolicyCoverRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coverAmount = _data["coverAmount"];
            if (Array.isArray(_data["dependentCountTiers"])) {
                this.dependentCountTiers = [] as any;
                for (let item of _data["dependentCountTiers"])
                    this.dependentCountTiers!.push(DependentCountTierDto.fromJS(item));
            }
            if (_data["ageBrackets"]) {
                this.ageBrackets = {} as any;
                for (let key in _data["ageBrackets"]) {
                    if (_data["ageBrackets"].hasOwnProperty(key))
                        (this.ageBrackets as any)![key] = _data["ageBrackets"][key] ? PolicyCoverAgeBracketDto.fromJS(_data["ageBrackets"][key]) : new PolicyCoverAgeBracketDto();
                }
            }
            this.premium_1To5Dependents_Under65 = _data["premium_1To5Dependents_Under65"];
            this.premium_1To5Dependents_Under70 = _data["premium_1To5Dependents_Under70"];
            this.premium_1To5Dependents_Under75 = _data["premium_1To5Dependents_Under75"];
            this.premium_1To5Dependents_75Plus = _data["premium_1To5Dependents_75Plus"];
        }
    }

    static fromJS(data: any): PolicyCoverRowDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyCoverRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coverAmount"] = this.coverAmount;
        if (Array.isArray(this.dependentCountTiers)) {
            data["dependentCountTiers"] = [];
            for (let item of this.dependentCountTiers)
                data["dependentCountTiers"].push(item ? item.toJSON() : undefined as any);
        }
        if (this.ageBrackets) {
            data["ageBrackets"] = {};
            for (let key in this.ageBrackets) {
                if (this.ageBrackets.hasOwnProperty(key))
                    (data["ageBrackets"] as any)[key] = this.ageBrackets[key] ? this.ageBrackets[key].toJSON() : undefined as any;
            }
        }
        data["premium_1To5Dependents_Under65"] = this.premium_1To5Dependents_Under65;
        data["premium_1To5Dependents_Under70"] = this.premium_1To5Dependents_Under70;
        data["premium_1To5Dependents_Under75"] = this.premium_1To5Dependents_Under75;
        data["premium_1To5Dependents_75Plus"] = this.premium_1To5Dependents_75Plus;
        return data;
    }
}

export interface IPolicyCoverRowDto {
    coverAmount: number;
    dependentCountTiers: DependentCountTierDto[] | undefined;
    ageBrackets: { [key: string]: PolicyCoverAgeBracketDto; } | undefined;
    premium_1To5Dependents_Under65: number;
    premium_1To5Dependents_Under70: number;
    premium_1To5Dependents_Under75: number;
    premium_1To5Dependents_75Plus: number;
}

export class PolicyDto implements IPolicyDto {
    id!: string;
    name!: string | undefined;
    price!: number;
    payoutAmount!: number;
    policyAttributes!: PolicyAttributeDto[] | undefined;

    constructor(data?: IPolicyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.payoutAmount = _data["payoutAmount"];
            if (Array.isArray(_data["policyAttributes"])) {
                this.policyAttributes = [] as any;
                for (let item of _data["policyAttributes"])
                    this.policyAttributes!.push(PolicyAttributeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PolicyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        data["payoutAmount"] = this.payoutAmount;
        if (Array.isArray(this.policyAttributes)) {
            data["policyAttributes"] = [];
            for (let item of this.policyAttributes)
                data["policyAttributes"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IPolicyDto {
    id: string;
    name: string | undefined;
    price: number;
    payoutAmount: number;
    policyAttributes: PolicyAttributeDto[] | undefined;
}

export class PolicyEnrollmentDto implements IPolicyEnrollmentDto {
    id!: string;
    memberId!: string;
    policyId!: string;
    enrollmentDate!: DateTime;
    endDate!: DateTime | undefined;
    status!: PolicyEnrollmentStatus;
    referenceNumber!: string | undefined;
    policyNumber!: string | undefined;
    approvedDate!: DateTime | undefined;
    rejectionReason!: string | undefined;
    statusChangedDate!: DateTime | undefined;

    constructor(data?: IPolicyEnrollmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.policyId = _data["policyId"];
            this.enrollmentDate = _data["enrollmentDate"] ? DateTime.fromISO(_data["enrollmentDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.referenceNumber = _data["referenceNumber"];
            this.policyNumber = _data["policyNumber"];
            this.approvedDate = _data["approvedDate"] ? DateTime.fromISO(_data["approvedDate"].toString()) : undefined as any;
            this.rejectionReason = _data["rejectionReason"];
            this.statusChangedDate = _data["statusChangedDate"] ? DateTime.fromISO(_data["statusChangedDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): PolicyEnrollmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyEnrollmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["policyId"] = this.policyId;
        data["enrollmentDate"] = this.enrollmentDate ? this.enrollmentDate.toString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toString() : undefined as any;
        data["status"] = this.status;
        data["referenceNumber"] = this.referenceNumber;
        data["policyNumber"] = this.policyNumber;
        data["approvedDate"] = this.approvedDate ? this.approvedDate.toString() : undefined as any;
        data["rejectionReason"] = this.rejectionReason;
        data["statusChangedDate"] = this.statusChangedDate ? this.statusChangedDate.toString() : undefined as any;
        return data;
    }
}

export interface IPolicyEnrollmentDto {
    id: string;
    memberId: string;
    policyId: string;
    enrollmentDate: DateTime;
    endDate: DateTime | undefined;
    status: PolicyEnrollmentStatus;
    referenceNumber: string | undefined;
    policyNumber: string | undefined;
    approvedDate: DateTime | undefined;
    rejectionReason: string | undefined;
    statusChangedDate: DateTime | undefined;
}

export enum PolicyEnrollmentStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class PolicyEnrollmentSummary implements IPolicyEnrollmentSummary {
    id!: string;
    policyName!: string | undefined;
    monthlyPremium!: number | undefined;
    status!: string | undefined;
    enrollmentDate!: DateTime | undefined;

    constructor(data?: IPolicyEnrollmentSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.policyName = _data["policyName"];
            this.monthlyPremium = _data["monthlyPremium"];
            this.status = _data["status"];
            this.enrollmentDate = _data["enrollmentDate"] ? DateTime.fromISO(_data["enrollmentDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): PolicyEnrollmentSummary {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyEnrollmentSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["policyName"] = this.policyName;
        data["monthlyPremium"] = this.monthlyPremium;
        data["status"] = this.status;
        data["enrollmentDate"] = this.enrollmentDate ? this.enrollmentDate.toString() : undefined as any;
        return data;
    }
}

export interface IPolicyEnrollmentSummary {
    id: string;
    policyName: string | undefined;
    monthlyPremium: number | undefined;
    status: string | undefined;
    enrollmentDate: DateTime | undefined;
}

export class PolicyNumberConfigDto implements IPolicyNumberConfigDto {
    generationStrategy!: string;
    prefix!: string | undefined;
    separator!: string | undefined;
    startingNumber!: number;
    currentNumber!: number;
    sequentialDigits!: number;
    randomLength!: number;
    includeLetters!: boolean;
    uppercase!: boolean;
    maxRetryAttempts!: number;
    exampleFormat!: string | undefined;

    constructor(data?: IPolicyNumberConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.generationStrategy = _data["generationStrategy"];
            this.prefix = _data["prefix"];
            this.separator = _data["separator"];
            this.startingNumber = _data["startingNumber"];
            this.currentNumber = _data["currentNumber"];
            this.sequentialDigits = _data["sequentialDigits"];
            this.randomLength = _data["randomLength"];
            this.includeLetters = _data["includeLetters"];
            this.uppercase = _data["uppercase"];
            this.maxRetryAttempts = _data["maxRetryAttempts"];
            this.exampleFormat = _data["exampleFormat"];
        }
    }

    static fromJS(data: any): PolicyNumberConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyNumberConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generationStrategy"] = this.generationStrategy;
        data["prefix"] = this.prefix;
        data["separator"] = this.separator;
        data["startingNumber"] = this.startingNumber;
        data["currentNumber"] = this.currentNumber;
        data["sequentialDigits"] = this.sequentialDigits;
        data["randomLength"] = this.randomLength;
        data["includeLetters"] = this.includeLetters;
        data["uppercase"] = this.uppercase;
        data["maxRetryAttempts"] = this.maxRetryAttempts;
        data["exampleFormat"] = this.exampleFormat;
        return data;
    }
}

export interface IPolicyNumberConfigDto {
    generationStrategy: string;
    prefix: string | undefined;
    separator: string | undefined;
    startingNumber: number;
    currentNumber: number;
    sequentialDigits: number;
    randomLength: number;
    includeLetters: boolean;
    uppercase: boolean;
    maxRetryAttempts: number;
    exampleFormat: string | undefined;
}

export class PolicyOptionDto implements IPolicyOptionDto {
    coverAmount!: number;
    monthlyPremium!: number;
    description!: string | undefined;
    isRecommended!: boolean;

    constructor(data?: IPolicyOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coverAmount = _data["coverAmount"];
            this.monthlyPremium = _data["monthlyPremium"];
            this.description = _data["description"];
            this.isRecommended = _data["isRecommended"];
        }
    }

    static fromJS(data: any): PolicyOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coverAmount"] = this.coverAmount;
        data["monthlyPremium"] = this.monthlyPremium;
        data["description"] = this.description;
        data["isRecommended"] = this.isRecommended;
        return data;
    }
}

export interface IPolicyOptionDto {
    coverAmount: number;
    monthlyPremium: number;
    description: string | undefined;
    isRecommended: boolean;
}

export class PremiumBreakdownItemDto implements IPremiumBreakdownItemDto {
    description!: string | undefined;
    amount!: number;
    category!: string | undefined;
    details!: string | undefined;

    constructor(data?: IPremiumBreakdownItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.category = _data["category"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): PremiumBreakdownItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PremiumBreakdownItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["category"] = this.category;
        data["details"] = this.details;
        return data;
    }
}

export interface IPremiumBreakdownItemDto {
    description: string | undefined;
    amount: number;
    category: string | undefined;
    details: string | undefined;
}

export class PremiumCalculationResultDto implements IPremiumCalculationResultDto {
    basePremium!: number;
    extendedFamilyPremium!: number;
    totalMonthlyPremium!: number;
    breakdown!: PremiumBreakdownItemDto[] | undefined;
    message!: string | undefined;

    constructor(data?: IPremiumCalculationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basePremium = _data["basePremium"];
            this.extendedFamilyPremium = _data["extendedFamilyPremium"];
            this.totalMonthlyPremium = _data["totalMonthlyPremium"];
            if (Array.isArray(_data["breakdown"])) {
                this.breakdown = [] as any;
                for (let item of _data["breakdown"])
                    this.breakdown!.push(PremiumBreakdownItemDto.fromJS(item));
            }
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): PremiumCalculationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PremiumCalculationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basePremium"] = this.basePremium;
        data["extendedFamilyPremium"] = this.extendedFamilyPremium;
        data["totalMonthlyPremium"] = this.totalMonthlyPremium;
        if (Array.isArray(this.breakdown)) {
            data["breakdown"] = [];
            for (let item of this.breakdown)
                data["breakdown"].push(item ? item.toJSON() : undefined as any);
        }
        data["message"] = this.message;
        return data;
    }
}

export interface IPremiumCalculationResultDto {
    basePremium: number;
    extendedFamilyPremium: number;
    totalMonthlyPremium: number;
    breakdown: PremiumBreakdownItemDto[] | undefined;
    message: string | undefined;
}

export class PremiumCalculationSettingsDto implements IPremiumCalculationSettingsDto {
    policyCoverTable!: PolicyCoverPremiumTableDto;
    extendedFamilyTable!: ExtendedFamilyBenefitTableDto;
    maxExtendedFamilyMembers!: number;

    constructor(data?: IPremiumCalculationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.policyCoverTable = _data["policyCoverTable"] ? PolicyCoverPremiumTableDto.fromJS(_data["policyCoverTable"]) : undefined as any;
            this.extendedFamilyTable = _data["extendedFamilyTable"] ? ExtendedFamilyBenefitTableDto.fromJS(_data["extendedFamilyTable"]) : undefined as any;
            this.maxExtendedFamilyMembers = _data["maxExtendedFamilyMembers"];
        }
    }

    static fromJS(data: any): PremiumCalculationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PremiumCalculationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyCoverTable"] = this.policyCoverTable ? this.policyCoverTable.toJSON() : undefined as any;
        data["extendedFamilyTable"] = this.extendedFamilyTable ? this.extendedFamilyTable.toJSON() : undefined as any;
        data["maxExtendedFamilyMembers"] = this.maxExtendedFamilyMembers;
        return data;
    }
}

export interface IPremiumCalculationSettingsDto {
    policyCoverTable: PolicyCoverPremiumTableDto;
    extendedFamilyTable: ExtendedFamilyBenefitTableDto;
    maxExtendedFamilyMembers: number;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | undefined;
    title!: string | undefined;
    status!: number | undefined;
    detail!: string | undefined;
    instance!: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type: string | undefined;
    title: string | undefined;
    status: number | undefined;
    detail: string | undefined;
    instance: string | undefined;

    [key: string]: any;
}

export class ProfileCompletionStatusDto implements IProfileCompletionStatusDto {
    isComplete!: boolean;
    completionPercentage!: number;
    completedSteps!: string[] | undefined;
    remainingSteps!: string[] | undefined;
    nextStepRecommendation!: string | undefined;
    profileCompletion!: MemberProfileCompletionDto;
    dependentsCount!: number;
    beneficiariesCount!: number;
    uploadedDocumentsCount!: number;
    requiredDocumentsCount!: number;
    hasAcceptedLatestTerms!: boolean;
    memberStatus!: string | undefined;

    constructor(data?: IProfileCompletionStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isComplete = _data["isComplete"];
            this.completionPercentage = _data["completionPercentage"];
            if (Array.isArray(_data["completedSteps"])) {
                this.completedSteps = [] as any;
                for (let item of _data["completedSteps"])
                    this.completedSteps!.push(item);
            }
            if (Array.isArray(_data["remainingSteps"])) {
                this.remainingSteps = [] as any;
                for (let item of _data["remainingSteps"])
                    this.remainingSteps!.push(item);
            }
            this.nextStepRecommendation = _data["nextStepRecommendation"];
            this.profileCompletion = _data["profileCompletion"] ? MemberProfileCompletionDto.fromJS(_data["profileCompletion"]) : undefined as any;
            this.dependentsCount = _data["dependentsCount"];
            this.beneficiariesCount = _data["beneficiariesCount"];
            this.uploadedDocumentsCount = _data["uploadedDocumentsCount"];
            this.requiredDocumentsCount = _data["requiredDocumentsCount"];
            this.hasAcceptedLatestTerms = _data["hasAcceptedLatestTerms"];
            this.memberStatus = _data["memberStatus"];
        }
    }

    static fromJS(data: any): ProfileCompletionStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileCompletionStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isComplete"] = this.isComplete;
        data["completionPercentage"] = this.completionPercentage;
        if (Array.isArray(this.completedSteps)) {
            data["completedSteps"] = [];
            for (let item of this.completedSteps)
                data["completedSteps"].push(item);
        }
        if (Array.isArray(this.remainingSteps)) {
            data["remainingSteps"] = [];
            for (let item of this.remainingSteps)
                data["remainingSteps"].push(item);
        }
        data["nextStepRecommendation"] = this.nextStepRecommendation;
        data["profileCompletion"] = this.profileCompletion ? this.profileCompletion.toJSON() : undefined as any;
        data["dependentsCount"] = this.dependentsCount;
        data["beneficiariesCount"] = this.beneficiariesCount;
        data["uploadedDocumentsCount"] = this.uploadedDocumentsCount;
        data["requiredDocumentsCount"] = this.requiredDocumentsCount;
        data["hasAcceptedLatestTerms"] = this.hasAcceptedLatestTerms;
        data["memberStatus"] = this.memberStatus;
        return data;
    }
}

export interface IProfileCompletionStatusDto {
    isComplete: boolean;
    completionPercentage: number;
    completedSteps: string[] | undefined;
    remainingSteps: string[] | undefined;
    nextStepRecommendation: string | undefined;
    profileCompletion: MemberProfileCompletionDto;
    dependentsCount: number;
    beneficiariesCount: number;
    uploadedDocumentsCount: number;
    requiredDocumentsCount: number;
    hasAcceptedLatestTerms: boolean;
    memberStatus: string | undefined;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    refreshToken!: string | undefined;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenRequest {
    refreshToken: string | undefined;
}

export class RegisterNewMemberDto implements IRegisterNewMemberDto {
    idNumber!: string;
    email!: string;
    password!: string;
    firstNames!: string;
    surname!: string;
    phoneNumber!: string;
    selectedCoverAmount!: number;
    dateOfBirth!: DateTime | undefined;

    constructor(data?: IRegisterNewMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstNames = _data["firstNames"];
            this.surname = _data["surname"];
            this.phoneNumber = _data["phoneNumber"];
            this.selectedCoverAmount = _data["selectedCoverAmount"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): RegisterNewMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterNewMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstNames"] = this.firstNames;
        data["surname"] = this.surname;
        data["phoneNumber"] = this.phoneNumber;
        data["selectedCoverAmount"] = this.selectedCoverAmount;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        return data;
    }
}

export interface IRegisterNewMemberDto {
    idNumber: string;
    email: string;
    password: string;
    firstNames: string;
    surname: string;
    phoneNumber: string;
    selectedCoverAmount: number;
    dateOfBirth: DateTime | undefined;
}

export class RegisterRequest implements IRegisterRequest {
    email!: string;
    password!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    identificationNumber!: string | undefined;
    policyId!: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.identificationNumber = _data["identificationNumber"];
            this.policyId = _data["policyId"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["identificationNumber"] = this.identificationNumber;
        data["policyId"] = this.policyId;
        return data;
    }
}

export interface IRegisterRequest {
    email: string;
    password: string;
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    identificationNumber: string | undefined;
    policyId: string | undefined;
}

export class RejectEnrollmentDto implements IRejectEnrollmentDto {
    reason!: string | undefined;

    constructor(data?: IRejectEnrollmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): RejectEnrollmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RejectEnrollmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        return data;
    }
}

export interface IRejectEnrollmentDto {
    reason: string | undefined;
}

export class RejectMemberRequest implements IRejectMemberRequest {
    memberId!: string;
    rejectionReason!: string | undefined;

    constructor(data?: IRejectMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.rejectionReason = _data["rejectionReason"];
        }
    }

    static fromJS(data: any): RejectMemberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RejectMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["rejectionReason"] = this.rejectionReason;
        return data;
    }
}

export interface IRejectMemberRequest {
    memberId: string;
    rejectionReason: string | undefined;
}

export class RejectTenantDto implements IRejectTenantDto {
    tenantId!: string;
    rejectionReason!: string | undefined;

    constructor(data?: IRejectTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.rejectionReason = _data["rejectionReason"];
        }
    }

    static fromJS(data: any): RejectTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new RejectTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["rejectionReason"] = this.rejectionReason;
        return data;
    }
}

export interface IRejectTenantDto {
    tenantId: string;
    rejectionReason: string | undefined;
}

export class RequestChangesDto implements IRequestChangesDto {
    reason!: string | undefined;

    constructor(data?: IRequestChangesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): RequestChangesDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestChangesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        return data;
    }
}

export interface IRequestChangesDto {
    reason: string | undefined;
}

export class RequestDependentOtpDto implements IRequestDependentOtpDto {
    idNumber!: string;
    contactMethod!: string;

    constructor(data?: IRequestDependentOtpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
            this.contactMethod = _data["contactMethod"];
        }
    }

    static fromJS(data: any): RequestDependentOtpDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDependentOtpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        data["contactMethod"] = this.contactMethod;
        return data;
    }
}

export interface IRequestDependentOtpDto {
    idNumber: string;
    contactMethod: string;
}

export class RequestMemberUpdatesRequest implements IRequestMemberUpdatesRequest {
    memberId!: string;
    updatesRequired!: string | undefined;
    requiredFields!: string[] | undefined;

    constructor(data?: IRequestMemberUpdatesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.updatesRequired = _data["updatesRequired"];
            if (Array.isArray(_data["requiredFields"])) {
                this.requiredFields = [] as any;
                for (let item of _data["requiredFields"])
                    this.requiredFields!.push(item);
            }
        }
    }

    static fromJS(data: any): RequestMemberUpdatesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RequestMemberUpdatesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["updatesRequired"] = this.updatesRequired;
        if (Array.isArray(this.requiredFields)) {
            data["requiredFields"] = [];
            for (let item of this.requiredFields)
                data["requiredFields"].push(item);
        }
        return data;
    }
}

export interface IRequestMemberUpdatesRequest {
    memberId: string;
    updatesRequired: string | undefined;
    requiredFields: string[] | undefined;
}

export class RequestTenantChangeDto implements IRequestTenantChangeDto {
    tenantId!: string;
    changeRequestReason!: string | undefined;

    constructor(data?: IRequestTenantChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.changeRequestReason = _data["changeRequestReason"];
        }
    }

    static fromJS(data: any): RequestTenantChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTenantChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["changeRequestReason"] = this.changeRequestReason;
        return data;
    }
}

export interface IRequestTenantChangeDto {
    tenantId: string;
    changeRequestReason: string | undefined;
}

export class RequiredDocumentDto implements IRequiredDocumentDto {
    id!: string;
    documentName!: string | undefined;
    description!: string | undefined;
    documentType!: RequiredDocumentType;
    entityType!: RequiredDocumentEntityType;
    isRequired!: boolean;
    allowedFileTypes!: string | undefined;
    maxFileSizeBytes!: number | undefined;

    constructor(data?: IRequiredDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentName = _data["documentName"];
            this.description = _data["description"];
            this.documentType = _data["documentType"];
            this.entityType = _data["entityType"];
            this.isRequired = _data["isRequired"];
            this.allowedFileTypes = _data["allowedFileTypes"];
            this.maxFileSizeBytes = _data["maxFileSizeBytes"];
        }
    }

    static fromJS(data: any): RequiredDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequiredDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentName"] = this.documentName;
        data["description"] = this.description;
        data["documentType"] = this.documentType;
        data["entityType"] = this.entityType;
        data["isRequired"] = this.isRequired;
        data["allowedFileTypes"] = this.allowedFileTypes;
        data["maxFileSizeBytes"] = this.maxFileSizeBytes;
        return data;
    }
}

export interface IRequiredDocumentDto {
    id: string;
    documentName: string | undefined;
    description: string | undefined;
    documentType: RequiredDocumentType;
    entityType: RequiredDocumentEntityType;
    isRequired: boolean;
    allowedFileTypes: string | undefined;
    maxFileSizeBytes: number | undefined;
}

export enum RequiredDocumentEntityType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum RequiredDocumentType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email!: string | undefined;
    code!: string | undefined;
    newPassword!: string | undefined;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.code = _data["code"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["code"] = this.code;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email: string | undefined;
    code: string | undefined;
    newPassword: string | undefined;
}

export class ResourceBookingDto implements IResourceBookingDto {
    id!: string;
    funeralEventId!: string;
    resourceId!: string;
    startTime!: DateTime;
    endTime!: DateTime;

    constructor(data?: IResourceBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.funeralEventId = _data["funeralEventId"];
            this.resourceId = _data["resourceId"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : undefined as any;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ResourceBookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceBookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["funeralEventId"] = this.funeralEventId;
        data["resourceId"] = this.resourceId;
        data["startTime"] = this.startTime ? this.startTime.toString() : undefined as any;
        data["endTime"] = this.endTime ? this.endTime.toString() : undefined as any;
        return data;
    }
}

export interface IResourceBookingDto {
    id: string;
    funeralEventId: string;
    resourceId: string;
    startTime: DateTime;
    endTime: DateTime;
}

export class ResourceDto implements IResourceDto {
    id!: string;
    name!: string | undefined;
    type!: string | undefined;
    description!: string | undefined;
    isAvailable!: boolean;

    constructor(data?: IResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["description"] = this.description;
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IResourceDto {
    id: string;
    name: string | undefined;
    type: string | undefined;
    description: string | undefined;
    isAvailable: boolean;
}

export class RevokeTokenRequest implements IRevokeTokenRequest {
    refreshToken!: string | undefined;

    constructor(data?: IRevokeTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RevokeTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RevokeTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRevokeTokenRequest {
    refreshToken: string | undefined;
}

export class Role implements IRole {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    tenantId!: string;
    name!: string;
    rolePermissions!: RolePermission[] | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            if (Array.isArray(_data["rolePermissions"])) {
                this.rolePermissions = [] as any;
                for (let item of _data["rolePermissions"])
                    this.rolePermissions!.push(RolePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        if (Array.isArray(this.rolePermissions)) {
            data["rolePermissions"] = [];
            for (let item of this.rolePermissions)
                data["rolePermissions"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRole {
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    tenantId: string;
    name: string;
    rolePermissions: RolePermission[] | undefined;
}

export class RoleDto implements IRoleDto {
    id!: string;
    name!: string | undefined;
    permissions!: PermissionDto[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRoleDto {
    id: string;
    name: string | undefined;
    permissions: PermissionDto[] | undefined;
}

export class RoleInput implements IRoleInput {
    name!: string;

    constructor(data?: IRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new RoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IRoleInput {
    name: string;
}

export class RolePermission implements IRolePermission {
    id!: string;
    roleId!: string;
    permissionId!: string;
    role!: Role;
    permission!: Permission;

    constructor(data?: IRolePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.permissionId = _data["permissionId"];
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : undefined as any;
            this.permission = _data["permission"] ? Permission.fromJS(_data["permission"]) : undefined as any;
        }
    }

    static fromJS(data: any): RolePermission {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["permissionId"] = this.permissionId;
        data["role"] = this.role ? this.role.toJSON() : undefined as any;
        data["permission"] = this.permission ? this.permission.toJSON() : undefined as any;
        return data;
    }
}

export interface IRolePermission {
    id: string;
    roleId: string;
    permissionId: string;
    role: Role;
    permission: Permission;
}

export class SaveMemberOnboardingDataDto implements ISaveMemberOnboardingDataDto {
    fieldValues!: { [key: string]: string; };

    constructor(data?: ISaveMemberOnboardingDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.fieldValues = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["fieldValues"]) {
                this.fieldValues = {} as any;
                for (let key in _data["fieldValues"]) {
                    if (_data["fieldValues"].hasOwnProperty(key))
                        (this.fieldValues as any)![key] = _data["fieldValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): SaveMemberOnboardingDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveMemberOnboardingDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fieldValues) {
            data["fieldValues"] = {};
            for (let key in this.fieldValues) {
                if (this.fieldValues.hasOwnProperty(key))
                    (data["fieldValues"] as any)[key] = (this.fieldValues as any)[key];
            }
        }
        return data;
    }
}

export interface ISaveMemberOnboardingDataDto {
    fieldValues: { [key: string]: string; };
}

export class SaveSignatureDto implements ISaveSignatureDto {
    signatureDataUrl!: string;

    constructor(data?: ISaveSignatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signatureDataUrl = _data["signatureDataUrl"];
        }
    }

    static fromJS(data: any): SaveSignatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveSignatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signatureDataUrl"] = this.signatureDataUrl;
        return data;
    }
}

export interface ISaveSignatureDto {
    signatureDataUrl: string;
}

export class ScheduleMaintenanceDto implements IScheduleMaintenanceDto {
    assetId!: string;
    maintenanceDate!: DateTime;
    notes!: string | undefined;

    constructor(data?: IScheduleMaintenanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetId = _data["assetId"];
            this.maintenanceDate = _data["maintenanceDate"] ? DateTime.fromISO(_data["maintenanceDate"].toString()) : undefined as any;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ScheduleMaintenanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleMaintenanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetId"] = this.assetId;
        data["maintenanceDate"] = this.maintenanceDate ? this.maintenanceDate.toString() : undefined as any;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IScheduleMaintenanceDto {
    assetId: string;
    maintenanceDate: DateTime;
    notes: string | undefined;
}

export class SignContractRequest implements ISignContractRequest {
    contractId!: string;
    signatureBase64!: string | undefined;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;
    geoLocation!: string | undefined;
    signatureX!: number;
    signatureY!: number;
    signatureWidth!: number;
    signatureHeight!: number;

    constructor(data?: ISignContractRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.signatureBase64 = _data["signatureBase64"];
            this.ipAddress = _data["ipAddress"];
            this.userAgent = _data["userAgent"];
            this.geoLocation = _data["geoLocation"];
            this.signatureX = _data["signatureX"];
            this.signatureY = _data["signatureY"];
            this.signatureWidth = _data["signatureWidth"];
            this.signatureHeight = _data["signatureHeight"];
        }
    }

    static fromJS(data: any): SignContractRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignContractRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["signatureBase64"] = this.signatureBase64;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["geoLocation"] = this.geoLocation;
        data["signatureX"] = this.signatureX;
        data["signatureY"] = this.signatureY;
        data["signatureWidth"] = this.signatureWidth;
        data["signatureHeight"] = this.signatureHeight;
        return data;
    }
}

export interface ISignContractRequest {
    contractId: string;
    signatureBase64: string | undefined;
    ipAddress: string | undefined;
    userAgent: string | undefined;
    geoLocation: string | undefined;
    signatureX: number;
    signatureY: number;
    signatureWidth: number;
    signatureHeight: number;
}

export enum SourceOfIncome {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum SouthAfricanProvince {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
}

export class SubscriptionPlanDto implements ISubscriptionPlanDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    monthlyPrice!: number;
    allowedTenantType!: TenantType;
    features!: string | undefined;
    supportsIdentityVerification!: boolean;
    maxVerificationsPerMonth!: number;
    enhancedVerification!: boolean;
    quickIdCheck!: boolean;
    bulkVerification!: boolean;
    verificationHistory!: boolean;

    constructor(data?: ISubscriptionPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.allowedTenantType = _data["allowedTenantType"];
            this.features = _data["features"];
            this.supportsIdentityVerification = _data["supportsIdentityVerification"];
            this.maxVerificationsPerMonth = _data["maxVerificationsPerMonth"];
            this.enhancedVerification = _data["enhancedVerification"];
            this.quickIdCheck = _data["quickIdCheck"];
            this.bulkVerification = _data["bulkVerification"];
            this.verificationHistory = _data["verificationHistory"];
        }
    }

    static fromJS(data: any): SubscriptionPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["monthlyPrice"] = this.monthlyPrice;
        data["allowedTenantType"] = this.allowedTenantType;
        data["features"] = this.features;
        data["supportsIdentityVerification"] = this.supportsIdentityVerification;
        data["maxVerificationsPerMonth"] = this.maxVerificationsPerMonth;
        data["enhancedVerification"] = this.enhancedVerification;
        data["quickIdCheck"] = this.quickIdCheck;
        data["bulkVerification"] = this.bulkVerification;
        data["verificationHistory"] = this.verificationHistory;
        return data;
    }
}

export interface ISubscriptionPlanDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    monthlyPrice: number;
    allowedTenantType: TenantType;
    features: string | undefined;
    supportsIdentityVerification: boolean;
    maxVerificationsPerMonth: number;
    enhancedVerification: boolean;
    quickIdCheck: boolean;
    bulkVerification: boolean;
    verificationHistory: boolean;
}

export class TenantApprovalDetailDto implements ITenantApprovalDetailDto {
    id!: string;
    name!: string | undefined;
    domain!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    registrationNumber!: string | undefined;
    type!: TenantType;
    approvalStatus!: TenantApprovalStatus;
    rejectionReason!: string | undefined;
    changeRequestReason!: string | undefined;
    createdAt!: DateTime | undefined;
    reviewedAt!: DateTime | undefined;
    reviewedByName!: string | undefined;

    constructor(data?: ITenantApprovalDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.domain = _data["domain"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.registrationNumber = _data["registrationNumber"];
            this.type = _data["type"];
            this.approvalStatus = _data["approvalStatus"];
            this.rejectionReason = _data["rejectionReason"];
            this.changeRequestReason = _data["changeRequestReason"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.reviewedAt = _data["reviewedAt"] ? DateTime.fromISO(_data["reviewedAt"].toString()) : undefined as any;
            this.reviewedByName = _data["reviewedByName"];
        }
    }

    static fromJS(data: any): TenantApprovalDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantApprovalDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["domain"] = this.domain;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["registrationNumber"] = this.registrationNumber;
        data["type"] = this.type;
        data["approvalStatus"] = this.approvalStatus;
        data["rejectionReason"] = this.rejectionReason;
        data["changeRequestReason"] = this.changeRequestReason;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["reviewedAt"] = this.reviewedAt ? this.reviewedAt.toString() : undefined as any;
        data["reviewedByName"] = this.reviewedByName;
        return data;
    }
}

export interface ITenantApprovalDetailDto {
    id: string;
    name: string | undefined;
    domain: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    registrationNumber: string | undefined;
    type: TenantType;
    approvalStatus: TenantApprovalStatus;
    rejectionReason: string | undefined;
    changeRequestReason: string | undefined;
    createdAt: DateTime | undefined;
    reviewedAt: DateTime | undefined;
    reviewedByName: string | undefined;
}

export class TenantApprovalListDto implements ITenantApprovalListDto {
    id!: string;
    name!: string | undefined;
    domain!: string | undefined;
    email!: string | undefined;
    phone1!: string | undefined;
    registrationNumber!: string | undefined;
    address!: string | undefined;
    approvalStatus!: TenantApprovalStatus;
    createdAt!: DateTime | undefined;
    rejectionReason!: string | undefined;
    changeRequestReason!: string | undefined;

    constructor(data?: ITenantApprovalListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.domain = _data["domain"];
            this.email = _data["email"];
            this.phone1 = _data["phone1"];
            this.registrationNumber = _data["registrationNumber"];
            this.address = _data["address"];
            this.approvalStatus = _data["approvalStatus"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.rejectionReason = _data["rejectionReason"];
            this.changeRequestReason = _data["changeRequestReason"];
        }
    }

    static fromJS(data: any): TenantApprovalListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantApprovalListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["domain"] = this.domain;
        data["email"] = this.email;
        data["phone1"] = this.phone1;
        data["registrationNumber"] = this.registrationNumber;
        data["address"] = this.address;
        data["approvalStatus"] = this.approvalStatus;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["rejectionReason"] = this.rejectionReason;
        data["changeRequestReason"] = this.changeRequestReason;
        return data;
    }
}

export interface ITenantApprovalListDto {
    id: string;
    name: string | undefined;
    domain: string | undefined;
    email: string | undefined;
    phone1: string | undefined;
    registrationNumber: string | undefined;
    address: string | undefined;
    approvalStatus: TenantApprovalStatus;
    createdAt: DateTime | undefined;
    rejectionReason: string | undefined;
    changeRequestReason: string | undefined;
}

export enum TenantApprovalStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantBankingDetailDto implements ITenantBankingDetailDto {
    id!: string;
    tenantId!: string;
    bankName!: string | undefined;
    accountNumber!: string | undefined;
    accountType!: string | undefined;
    branchCode!: string | undefined;
    branchName!: string | undefined;
    accountHolderName!: string | undefined;
    debitDay!: number | undefined;
    paymentMethod!: PaymentMethodType;
    mandateReference!: string | undefined;
    mandateSignedDate!: DateTime | undefined;
    isVerified!: boolean;
    isActive!: boolean;

    constructor(data?: ITenantBankingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.accountType = _data["accountType"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.accountHolderName = _data["accountHolderName"];
            this.debitDay = _data["debitDay"];
            this.paymentMethod = _data["paymentMethod"];
            this.mandateReference = _data["mandateReference"];
            this.mandateSignedDate = _data["mandateSignedDate"] ? DateTime.fromISO(_data["mandateSignedDate"].toString()) : undefined as any;
            this.isVerified = _data["isVerified"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantBankingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBankingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["accountType"] = this.accountType;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["accountHolderName"] = this.accountHolderName;
        data["debitDay"] = this.debitDay;
        data["paymentMethod"] = this.paymentMethod;
        data["mandateReference"] = this.mandateReference;
        data["mandateSignedDate"] = this.mandateSignedDate ? this.mandateSignedDate.toString() : undefined as any;
        data["isVerified"] = this.isVerified;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITenantBankingDetailDto {
    id: string;
    tenantId: string;
    bankName: string | undefined;
    accountNumber: string | undefined;
    accountType: string | undefined;
    branchCode: string | undefined;
    branchName: string | undefined;
    accountHolderName: string | undefined;
    debitDay: number | undefined;
    paymentMethod: PaymentMethodType;
    mandateReference: string | undefined;
    mandateSignedDate: DateTime | undefined;
    isVerified: boolean;
    isActive: boolean;
}

export class TenantCreateUpdateDto implements ITenantCreateUpdateDto {
    id!: string;
    email!: string;
    password!: string | undefined;
    name!: string;
    domain!: string;
    address!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    registrationNumber!: string | undefined;
    type!: TenantType;
    subscriptionPlanId!: string | undefined;
    isStaticSite!: boolean;

    constructor(data?: ITenantCreateUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.name = _data["name"];
            this.domain = _data["domain"];
            this.address = _data["address"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.registrationNumber = _data["registrationNumber"];
            this.type = _data["type"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.isStaticSite = _data["isStaticSite"];
        }
    }

    static fromJS(data: any): TenantCreateUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantCreateUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["password"] = this.password;
        data["name"] = this.name;
        data["domain"] = this.domain;
        data["address"] = this.address;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["registrationNumber"] = this.registrationNumber;
        data["type"] = this.type;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["isStaticSite"] = this.isStaticSite;
        return data;
    }
}

export interface ITenantCreateUpdateDto {
    id: string;
    email: string;
    password: string | undefined;
    name: string;
    domain: string;
    address: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    registrationNumber: string | undefined;
    type: TenantType;
    subscriptionPlanId: string | undefined;
    isStaticSite: boolean;
}

export class TenantSettingDto implements ITenantSettingDto {
    id!: string;
    settings!: string | undefined;
    ozowApiKey!: string | undefined;
    ozowSiteCode!: string | undefined;
    ozowPrivateKey!: string | undefined;
    logo!: string | undefined;
    favicon!: string | undefined;
    tenantName!: string | undefined;
    contractTemplateFileId!: string | undefined;
    enableIdVerification!: boolean;
    requireIdVerificationForRegistration!: boolean;

    constructor(data?: ITenantSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.settings = _data["settings"];
            this.ozowApiKey = _data["ozowApiKey"];
            this.ozowSiteCode = _data["ozowSiteCode"];
            this.ozowPrivateKey = _data["ozowPrivateKey"];
            this.logo = _data["logo"];
            this.favicon = _data["favicon"];
            this.tenantName = _data["tenantName"];
            this.contractTemplateFileId = _data["contractTemplateFileId"];
            this.enableIdVerification = _data["enableIdVerification"];
            this.requireIdVerificationForRegistration = _data["requireIdVerificationForRegistration"];
        }
    }

    static fromJS(data: any): TenantSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["settings"] = this.settings;
        data["ozowApiKey"] = this.ozowApiKey;
        data["ozowSiteCode"] = this.ozowSiteCode;
        data["ozowPrivateKey"] = this.ozowPrivateKey;
        data["logo"] = this.logo;
        data["favicon"] = this.favicon;
        data["tenantName"] = this.tenantName;
        data["contractTemplateFileId"] = this.contractTemplateFileId;
        data["enableIdVerification"] = this.enableIdVerification;
        data["requireIdVerificationForRegistration"] = this.requireIdVerificationForRegistration;
        return data;
    }
}

export interface ITenantSettingDto {
    id: string;
    settings: string | undefined;
    ozowApiKey: string | undefined;
    ozowSiteCode: string | undefined;
    ozowPrivateKey: string | undefined;
    logo: string | undefined;
    favicon: string | undefined;
    tenantName: string | undefined;
    contractTemplateFileId: string | undefined;
    enableIdVerification: boolean;
    requireIdVerificationForRegistration: boolean;
}

export enum TenantType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class TermsAcceptanceDto implements ITermsAcceptanceDto {
    id!: string;
    memberId!: string;
    termsAndConditionsId!: string;
    acceptedAt!: DateTime;
    acceptedVersion!: string | undefined;
    ipAddress!: string | undefined;

    constructor(data?: ITermsAcceptanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.termsAndConditionsId = _data["termsAndConditionsId"];
            this.acceptedAt = _data["acceptedAt"] ? DateTime.fromISO(_data["acceptedAt"].toString()) : undefined as any;
            this.acceptedVersion = _data["acceptedVersion"];
            this.ipAddress = _data["ipAddress"];
        }
    }

    static fromJS(data: any): TermsAcceptanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TermsAcceptanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["termsAndConditionsId"] = this.termsAndConditionsId;
        data["acceptedAt"] = this.acceptedAt ? this.acceptedAt.toString() : undefined as any;
        data["acceptedVersion"] = this.acceptedVersion;
        data["ipAddress"] = this.ipAddress;
        return data;
    }
}

export interface ITermsAcceptanceDto {
    id: string;
    memberId: string;
    termsAndConditionsId: string;
    acceptedAt: DateTime;
    acceptedVersion: string | undefined;
    ipAddress: string | undefined;
}

export class TermsAndConditionsDto implements ITermsAndConditionsDto {
    id!: string;
    title!: string | undefined;
    content!: string | undefined;
    version!: string | undefined;
    isActive!: boolean;
    effectiveDate!: DateTime;
    expiryDate!: DateTime | undefined;

    constructor(data?: ITermsAndConditionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.version = _data["version"];
            this.isActive = _data["isActive"];
            this.effectiveDate = _data["effectiveDate"] ? DateTime.fromISO(_data["effectiveDate"].toString()) : undefined as any;
            this.expiryDate = _data["expiryDate"] ? DateTime.fromISO(_data["expiryDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): TermsAndConditionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TermsAndConditionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["version"] = this.version;
        data["isActive"] = this.isActive;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toString() : undefined as any;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toString() : undefined as any;
        return data;
    }
}

export interface ITermsAndConditionsDto {
    id: string;
    title: string | undefined;
    content: string | undefined;
    version: string | undefined;
    isActive: boolean;
    effectiveDate: DateTime;
    expiryDate: DateTime | undefined;
}

export class TimesheetEntryDto implements ITimesheetEntryDto {
    id!: string;
    userId!: string;
    date!: DateTime;
    hoursWorked!: string;
    description!: string | undefined;

    constructor(data?: ITimesheetEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : undefined as any;
            this.hoursWorked = _data["hoursWorked"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TimesheetEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimesheetEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["date"] = this.date ? this.date.toString() : undefined as any;
        data["hoursWorked"] = this.hoursWorked;
        data["description"] = this.description;
        return data;
    }
}

export interface ITimesheetEntryDto {
    id: string;
    userId: string;
    date: DateTime;
    hoursWorked: string;
    description: string | undefined;
}

export class UpdateAssetDto implements IUpdateAssetDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    assetType!: AssetType;
    status!: AssetStatus;
    identificationNumber!: string | undefined;
    make!: string | undefined;
    model!: string | undefined;
    year!: number | undefined;
    quantity!: number;
    currentLocation!: string | undefined;
    requiresInspection!: boolean;
    inspectionCheckpoints!: string[] | undefined;
    lastMaintenanceDate!: DateTime | undefined;
    nextMaintenanceDate!: DateTime | undefined;
    conditionNotes!: string | undefined;

    constructor(data?: IUpdateAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.assetType = _data["assetType"];
            this.status = _data["status"];
            this.identificationNumber = _data["identificationNumber"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.year = _data["year"];
            this.quantity = _data["quantity"];
            this.currentLocation = _data["currentLocation"];
            this.requiresInspection = _data["requiresInspection"];
            if (Array.isArray(_data["inspectionCheckpoints"])) {
                this.inspectionCheckpoints = [] as any;
                for (let item of _data["inspectionCheckpoints"])
                    this.inspectionCheckpoints!.push(item);
            }
            this.lastMaintenanceDate = _data["lastMaintenanceDate"] ? DateTime.fromISO(_data["lastMaintenanceDate"].toString()) : undefined as any;
            this.nextMaintenanceDate = _data["nextMaintenanceDate"] ? DateTime.fromISO(_data["nextMaintenanceDate"].toString()) : undefined as any;
            this.conditionNotes = _data["conditionNotes"];
        }
    }

    static fromJS(data: any): UpdateAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["assetType"] = this.assetType;
        data["status"] = this.status;
        data["identificationNumber"] = this.identificationNumber;
        data["make"] = this.make;
        data["model"] = this.model;
        data["year"] = this.year;
        data["quantity"] = this.quantity;
        data["currentLocation"] = this.currentLocation;
        data["requiresInspection"] = this.requiresInspection;
        if (Array.isArray(this.inspectionCheckpoints)) {
            data["inspectionCheckpoints"] = [];
            for (let item of this.inspectionCheckpoints)
                data["inspectionCheckpoints"].push(item);
        }
        data["lastMaintenanceDate"] = this.lastMaintenanceDate ? this.lastMaintenanceDate.toString() : undefined as any;
        data["nextMaintenanceDate"] = this.nextMaintenanceDate ? this.nextMaintenanceDate.toString() : undefined as any;
        data["conditionNotes"] = this.conditionNotes;
        return data;
    }
}

export interface IUpdateAssetDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    assetType: AssetType;
    status: AssetStatus;
    identificationNumber: string | undefined;
    make: string | undefined;
    model: string | undefined;
    year: number | undefined;
    quantity: number;
    currentLocation: string | undefined;
    requiresInspection: boolean;
    inspectionCheckpoints: string[] | undefined;
    lastMaintenanceDate: DateTime | undefined;
    nextMaintenanceDate: DateTime | undefined;
    conditionNotes: string | undefined;
}

export class UpdateDashboardWidgetSettingDto implements IUpdateDashboardWidgetSettingDto {
    id!: string;
    isVisible!: boolean;
    allowedRoles!: string[] | undefined;
    displayOrder!: number;

    constructor(data?: IUpdateDashboardWidgetSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isVisible = _data["isVisible"];
            if (Array.isArray(_data["allowedRoles"])) {
                this.allowedRoles = [] as any;
                for (let item of _data["allowedRoles"])
                    this.allowedRoles!.push(item);
            }
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): UpdateDashboardWidgetSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDashboardWidgetSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isVisible"] = this.isVisible;
        if (Array.isArray(this.allowedRoles)) {
            data["allowedRoles"] = [];
            for (let item of this.allowedRoles)
                data["allowedRoles"].push(item);
        }
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IUpdateDashboardWidgetSettingDto {
    id: string;
    isVisible: boolean;
    allowedRoles: string[] | undefined;
    displayOrder: number;
}

export class UpdateFieldOrderDto implements IUpdateFieldOrderDto {
    fieldId!: string;
    displayOrder!: number;

    constructor(data?: IUpdateFieldOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): UpdateFieldOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFieldOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IUpdateFieldOrderDto {
    fieldId: string;
    displayOrder: number;
}

export class UpdateMemberBankingDetailDto implements IUpdateMemberBankingDetailDto {
    bankName!: string | undefined;
    accountNumber!: string | undefined;
    accountType!: string | undefined;
    branchCode!: string | undefined;
    branchName!: string | undefined;
    accountHolderName!: string | undefined;
    debitDay!: number | undefined;
    paymentMethod!: PaymentMethodType;

    constructor(data?: IUpdateMemberBankingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.accountType = _data["accountType"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.accountHolderName = _data["accountHolderName"];
            this.debitDay = _data["debitDay"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): UpdateMemberBankingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMemberBankingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["accountType"] = this.accountType;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["accountHolderName"] = this.accountHolderName;
        data["debitDay"] = this.debitDay;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }
}

export interface IUpdateMemberBankingDetailDto {
    bankName: string | undefined;
    accountNumber: string | undefined;
    accountType: string | undefined;
    branchCode: string | undefined;
    branchName: string | undefined;
    accountHolderName: string | undefined;
    debitDay: number | undefined;
    paymentMethod: PaymentMethodType;
}

export class UpdateOnboardingFieldConfigurationDto implements IUpdateOnboardingFieldConfigurationDto {
    id!: string;
    fieldKey!: string;
    fieldLabel!: string;
    fieldType!: string;
    category!: string | undefined;
    isRequired!: boolean;
    isEnabled!: boolean;
    displayOrder!: number;
    placeholder!: string | undefined;
    helpText!: string | undefined;
    optionsJson!: string | undefined;
    validationRulesJson!: string | undefined;
    defaultValue!: string | undefined;
    maxLength!: number | undefined;
    minLength!: number | undefined;

    constructor(data?: IUpdateOnboardingFieldConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldKey = _data["fieldKey"];
            this.fieldLabel = _data["fieldLabel"];
            this.fieldType = _data["fieldType"];
            this.category = _data["category"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.placeholder = _data["placeholder"];
            this.helpText = _data["helpText"];
            this.optionsJson = _data["optionsJson"];
            this.validationRulesJson = _data["validationRulesJson"];
            this.defaultValue = _data["defaultValue"];
            this.maxLength = _data["maxLength"];
            this.minLength = _data["minLength"];
        }
    }

    static fromJS(data: any): UpdateOnboardingFieldConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOnboardingFieldConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldKey"] = this.fieldKey;
        data["fieldLabel"] = this.fieldLabel;
        data["fieldType"] = this.fieldType;
        data["category"] = this.category;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["placeholder"] = this.placeholder;
        data["helpText"] = this.helpText;
        data["optionsJson"] = this.optionsJson;
        data["validationRulesJson"] = this.validationRulesJson;
        data["defaultValue"] = this.defaultValue;
        data["maxLength"] = this.maxLength;
        data["minLength"] = this.minLength;
        return data;
    }
}

export interface IUpdateOnboardingFieldConfigurationDto {
    id: string;
    fieldKey: string;
    fieldLabel: string;
    fieldType: string;
    category: string | undefined;
    isRequired: boolean;
    isEnabled: boolean;
    displayOrder: number;
    placeholder: string | undefined;
    helpText: string | undefined;
    optionsJson: string | undefined;
    validationRulesJson: string | undefined;
    defaultValue: string | undefined;
    maxLength: number | undefined;
    minLength: number | undefined;
}

export class UpdatePdfFieldMappingRequest implements IUpdatePdfFieldMappingRequest {
    sourceField!: string | undefined;
    pdfFieldName!: string | undefined;
    mappingType!: string | undefined;
    isEnabled!: boolean | undefined;
    displayOrder!: number | undefined;
    description!: string | undefined;
    conditionalRulesJson!: string | undefined;
    transformRule!: string | undefined;
    defaultValue!: string | undefined;
    checkedValue!: string | undefined;
    uncheckedValue!: string | undefined;
    category!: string | undefined;

    constructor(data?: IUpdatePdfFieldMappingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceField = _data["sourceField"];
            this.pdfFieldName = _data["pdfFieldName"];
            this.mappingType = _data["mappingType"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.description = _data["description"];
            this.conditionalRulesJson = _data["conditionalRulesJson"];
            this.transformRule = _data["transformRule"];
            this.defaultValue = _data["defaultValue"];
            this.checkedValue = _data["checkedValue"];
            this.uncheckedValue = _data["uncheckedValue"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): UpdatePdfFieldMappingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePdfFieldMappingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceField"] = this.sourceField;
        data["pdfFieldName"] = this.pdfFieldName;
        data["mappingType"] = this.mappingType;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["description"] = this.description;
        data["conditionalRulesJson"] = this.conditionalRulesJson;
        data["transformRule"] = this.transformRule;
        data["defaultValue"] = this.defaultValue;
        data["checkedValue"] = this.checkedValue;
        data["uncheckedValue"] = this.uncheckedValue;
        data["category"] = this.category;
        return data;
    }
}

export interface IUpdatePdfFieldMappingRequest {
    sourceField: string | undefined;
    pdfFieldName: string | undefined;
    mappingType: string | undefined;
    isEnabled: boolean | undefined;
    displayOrder: number | undefined;
    description: string | undefined;
    conditionalRulesJson: string | undefined;
    transformRule: string | undefined;
    defaultValue: string | undefined;
    checkedValue: string | undefined;
    uncheckedValue: string | undefined;
    category: string | undefined;
}

export class UpdateProfileCompletionStepDto implements IUpdateProfileCompletionStepDto {
    memberId!: string;
    stepName!: string | undefined;
    isCompleted!: boolean;

    constructor(data?: IUpdateProfileCompletionStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.stepName = _data["stepName"];
            this.isCompleted = _data["isCompleted"];
        }
    }

    static fromJS(data: any): UpdateProfileCompletionStepDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileCompletionStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["stepName"] = this.stepName;
        data["isCompleted"] = this.isCompleted;
        return data;
    }
}

export interface IUpdateProfileCompletionStepDto {
    memberId: string;
    stepName: string | undefined;
    isCompleted: boolean;
}

export class UpdateUserProfileDto implements IUpdateUserProfileDto {
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    address!: string | undefined;
    idNumber!: string | undefined;
    dateOfBirth!: DateTime | undefined;

    constructor(data?: IUpdateUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.idNumber = _data["idNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UpdateUserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["idNumber"] = this.idNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        return data;
    }
}

export interface IUpdateUserProfileDto {
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    idNumber: string | undefined;
    dateOfBirth: DateTime | undefined;
}

export class UserDto implements IUserDto {
    id!: string;
    email!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    address!: string | undefined;
    userRoles!: UserRoleDto[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IUserDto {
    id: string;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    userRoles: UserRoleDto[] | undefined;
}

export class UserProfileDto implements IUserProfileDto {
    id!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    address!: string | undefined;
    idNumber!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    isIdVerified!: boolean;
    idVerifiedAt!: DateTime | undefined;

    constructor(data?: IUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.idNumber = _data["idNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.isIdVerified = _data["isIdVerified"];
            this.idVerifiedAt = _data["idVerifiedAt"] ? DateTime.fromISO(_data["idVerifiedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["idNumber"] = this.idNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["isIdVerified"] = this.isIdVerified;
        data["idVerifiedAt"] = this.idVerifiedAt ? this.idVerifiedAt.toString() : undefined as any;
        return data;
    }
}

export interface IUserProfileDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    idNumber: string | undefined;
    dateOfBirth: DateTime | undefined;
    isIdVerified: boolean;
    idVerifiedAt: DateTime | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    id!: string;
    userId!: string;
    userName!: string | undefined;
    roleId!: string;
    roleName!: string | undefined;
    permissions!: PermissionDto[] | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IUserRoleDto {
    id: string;
    userId: string;
    userName: string | undefined;
    roleId: string;
    roleName: string | undefined;
    permissions: PermissionDto[] | undefined;
}

export class UserRoleInputDto implements IUserRoleInputDto {
    userId!: string;
    roleId!: string;

    constructor(data?: IUserRoleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRoleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IUserRoleInputDto {
    userId: string;
    roleId: string;
}

export class ValidatePolicyNumberRequestDto implements IValidatePolicyNumberRequestDto {
    policyNumber!: string;

    constructor(data?: IValidatePolicyNumberRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.policyNumber = _data["policyNumber"];
        }
    }

    static fromJS(data: any): ValidatePolicyNumberRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidatePolicyNumberRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyNumber"] = this.policyNumber;
        return data;
    }
}

export interface IValidatePolicyNumberRequestDto {
    policyNumber: string;
}

export class ValidatePolicyNumberResponseDto implements IValidatePolicyNumberResponseDto {
    isAvailable!: boolean;
    message!: string | undefined;
    existingMemberId!: string | undefined;
    existingPolicyId!: string | undefined;

    constructor(data?: IValidatePolicyNumberResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
            this.message = _data["message"];
            this.existingMemberId = _data["existingMemberId"];
            this.existingPolicyId = _data["existingPolicyId"];
        }
    }

    static fromJS(data: any): ValidatePolicyNumberResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidatePolicyNumberResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        data["message"] = this.message;
        data["existingMemberId"] = this.existingMemberId;
        data["existingPolicyId"] = this.existingPolicyId;
        return data;
    }
}

export interface IValidatePolicyNumberResponseDto {
    isAvailable: boolean;
    message: string | undefined;
    existingMemberId: string | undefined;
    existingPolicyId: string | undefined;
}

export class VerificationRequestDto implements IVerificationRequestDto {
    id!: string;
    idNumber!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    verificationType!: string | undefined;
    status!: string | undefined;
    verifyIdTransactionId!: string | undefined;
    verifiedAt!: DateTime | undefined;
    userId!: string | undefined;
    memberId!: string | undefined;
    claimId!: string | undefined;

    constructor(data?: IVerificationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idNumber = _data["idNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.verificationType = _data["verificationType"];
            this.status = _data["status"];
            this.verifyIdTransactionId = _data["verifyIdTransactionId"];
            this.verifiedAt = _data["verifiedAt"] ? DateTime.fromISO(_data["verifiedAt"].toString()) : undefined as any;
            this.userId = _data["userId"];
            this.memberId = _data["memberId"];
            this.claimId = _data["claimId"];
        }
    }

    static fromJS(data: any): VerificationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idNumber"] = this.idNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["verificationType"] = this.verificationType;
        data["status"] = this.status;
        data["verifyIdTransactionId"] = this.verifyIdTransactionId;
        data["verifiedAt"] = this.verifiedAt ? this.verifiedAt.toString() : undefined as any;
        data["userId"] = this.userId;
        data["memberId"] = this.memberId;
        data["claimId"] = this.claimId;
        return data;
    }
}

export interface IVerificationRequestDto {
    id: string;
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    dateOfBirth: DateTime | undefined;
    verificationType: string | undefined;
    status: string | undefined;
    verifyIdTransactionId: string | undefined;
    verifiedAt: DateTime | undefined;
    userId: string | undefined;
    memberId: string | undefined;
    claimId: string | undefined;
}

export class VerifyDependentOtpDto implements IVerifyDependentOtpDto {
    idNumber!: string;
    otpCode!: string;
    email!: string;
    password!: string;

    constructor(data?: IVerifyDependentOtpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
            this.otpCode = _data["otpCode"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): VerifyDependentOtpDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyDependentOtpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        data["otpCode"] = this.otpCode;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IVerifyDependentOtpDto {
    idNumber: string;
    otpCode: string;
    email: string;
    password: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
