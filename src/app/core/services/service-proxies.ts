//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AssetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    asset_CreateAsset(body: AssetDto | undefined): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/Asset/Asset_CreateAsset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsset_CreateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsset_CreateAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAsset_CreateAsset(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    asset_GetAssetById(id: string): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/Asset/Asset_GetAssetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsset_GetAssetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsset_GetAssetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAsset_GetAssetById(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    asset_GetAllAssets(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/Asset/Asset_GetAllAssets?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsset_GetAllAssets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsset_GetAllAssets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAsset_GetAllAssets(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    asset_UpdateAsset(id: string, body: AssetDto | undefined): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/Asset/Asset_UpdateAsset/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsset_UpdateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsset_UpdateAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAsset_UpdateAsset(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    asset_DeleteAsset(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Asset/Asset_DeleteAsset/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsset_DeleteAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsset_DeleteAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAsset_DeleteAsset(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AssetManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    assetManagement_GetAll(): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAssetManagement_GetAll(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetById(id: string): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAssetManagement_GetById(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetByType(assetType: AssetType): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetByType/{assetType}";
        if (assetType === undefined || assetType === null)
            throw new globalThis.Error("The parameter 'assetType' must be defined.");
        url_ = url_.replace("{assetType}", encodeURIComponent("" + assetType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAssetManagement_GetByType(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetByStatus(status: AssetStatus): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetByStatus/{status}";
        if (status === undefined || status === null)
            throw new globalThis.Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetByStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetByStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAssetManagement_GetByStatus(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetAvailable(): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetAvailable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAssetManagement_GetAvailable(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_Create(body: CreateAssetDto | undefined): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAssetManagement_Create(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_Update(body: UpdateAssetDto | undefined): Observable<AssetDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto>;
        }));
    }

    protected processAssetManagement_Update(response: HttpResponseBase): Observable<AssetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssetManagement_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetStats(): Observable<AssetStatsDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetStatsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetStatsDto>;
        }));
    }

    protected processAssetManagement_GetStats(response: HttpResponseBase): Observable<AssetStatsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetStatsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_Checkout(body: CheckoutAssetDto | undefined): Observable<AssetCheckoutDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_Checkout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_Checkout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_Checkout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto>;
        }));
    }

    protected processAssetManagement_Checkout(response: HttpResponseBase): Observable<AssetCheckoutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetCheckoutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_Checkin(body: CheckinAssetDto | undefined): Observable<AssetCheckoutDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_Checkin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_Checkin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_Checkin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto>;
        }));
    }

    protected processAssetManagement_Checkin(response: HttpResponseBase): Observable<AssetCheckoutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetCheckoutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetAllCheckouts(): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetAllCheckouts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetAllCheckouts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetAllCheckouts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetAllCheckouts(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetActiveCheckouts(): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetActiveCheckouts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetActiveCheckouts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetActiveCheckouts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetActiveCheckouts(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetOverdueCheckouts(): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetOverdueCheckouts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetOverdueCheckouts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetOverdueCheckouts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetOverdueCheckouts(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetMyCheckouts(): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetMyCheckouts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetMyCheckouts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetMyCheckouts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetMyCheckouts(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetCheckoutsByUser(userId: string): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetCheckoutsByUser/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetCheckoutsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetCheckoutsByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetCheckoutsByUser(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetCheckoutsByAsset(assetId: string): Observable<AssetCheckoutDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetCheckoutsByAsset/{assetId}";
        if (assetId === undefined || assetId === null)
            throw new globalThis.Error("The parameter 'assetId' must be defined.");
        url_ = url_.replace("{assetId}", encodeURIComponent("" + assetId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetCheckoutsByAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetCheckoutsByAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto[]>;
        }));
    }

    protected processAssetManagement_GetCheckoutsByAsset(response: HttpResponseBase): Observable<AssetCheckoutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCheckoutDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetCheckoutById(id: string): Observable<AssetCheckoutDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetCheckoutById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetCheckoutById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetCheckoutById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetCheckoutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetCheckoutDto>;
        }));
    }

    protected processAssetManagement_GetCheckoutById(response: HttpResponseBase): Observable<AssetCheckoutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetCheckoutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_CancelCheckout(checkoutId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_CancelCheckout/{checkoutId}";
        if (checkoutId === undefined || checkoutId === null)
            throw new globalThis.Error("The parameter 'checkoutId' must be defined.");
        url_ = url_.replace("{checkoutId}", encodeURIComponent("" + checkoutId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_CancelCheckout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_CancelCheckout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssetManagement_CancelCheckout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_CreateInspection(assetId: string, body: InspectionLogDto | undefined): Observable<AssetInspectionLogDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_CreateInspection/{assetId}";
        if (assetId === undefined || assetId === null)
            throw new globalThis.Error("The parameter 'assetId' must be defined.");
        url_ = url_.replace("{assetId}", encodeURIComponent("" + assetId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_CreateInspection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_CreateInspection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetInspectionLogDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetInspectionLogDto>;
        }));
    }

    protected processAssetManagement_CreateInspection(response: HttpResponseBase): Observable<AssetInspectionLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetInspectionLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetInspectionsByAsset(assetId: string): Observable<AssetInspectionLogDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetInspectionsByAsset/{assetId}";
        if (assetId === undefined || assetId === null)
            throw new globalThis.Error("The parameter 'assetId' must be defined.");
        url_ = url_.replace("{assetId}", encodeURIComponent("" + assetId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetInspectionsByAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetInspectionsByAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetInspectionLogDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetInspectionLogDto[]>;
        }));
    }

    protected processAssetManagement_GetInspectionsByAsset(response: HttpResponseBase): Observable<AssetInspectionLogDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetInspectionLogDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetInspectionsByCheckout(checkoutId: string): Observable<AssetInspectionLogDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetInspectionsByCheckout/{checkoutId}";
        if (checkoutId === undefined || checkoutId === null)
            throw new globalThis.Error("The parameter 'checkoutId' must be defined.");
        url_ = url_.replace("{checkoutId}", encodeURIComponent("" + checkoutId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetInspectionsByCheckout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetInspectionsByCheckout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetInspectionLogDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetInspectionLogDto[]>;
        }));
    }

    protected processAssetManagement_GetInspectionsByCheckout(response: HttpResponseBase): Observable<AssetInspectionLogDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetInspectionLogDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetInspectionById(id: string): Observable<AssetInspectionLogDto> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetInspectionById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetInspectionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetInspectionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetInspectionLogDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetInspectionLogDto>;
        }));
    }

    protected processAssetManagement_GetInspectionById(response: HttpResponseBase): Observable<AssetInspectionLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetInspectionLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_ScheduleMaintenance(body: ScheduleMaintenanceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_ScheduleMaintenance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_ScheduleMaintenance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_ScheduleMaintenance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssetManagement_ScheduleMaintenance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assetManagement_CompleteMaintenance(body: CompleteMaintenanceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_CompleteMaintenance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_CompleteMaintenance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_CompleteMaintenance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssetManagement_CompleteMaintenance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assetManagement_GetAssetsNeedingMaintenance(): Observable<AssetDto[]> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetManagement_GetAssetsNeedingMaintenance";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetManagement_GetAssetsNeedingMaintenance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetManagement_GetAssetsNeedingMaintenance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetDto[]>;
        }));
    }

    protected processAssetManagement_GetAssetsNeedingMaintenance(response: HttpResponseBase): Observable<AssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_RegisterTenant(body: TenantCreateUpdateDto | undefined): Observable<AuthResult> {
        let url_ = this.baseUrl + "/api/Auth/Auth_RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_RegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_RegisterTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResult>;
        }));
    }

    protected processAuth_RegisterTenant(response: HttpResponseBase): Observable<AuthResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param domain (optional) 
     * @return OK
     */
    auth_CheckTenantRegistration(domain: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_CheckTenantRegistration?";
        if (domain === null)
            throw new globalThis.Error("The parameter 'domain' cannot be null.");
        else if (domain !== undefined)
            url_ += "domain=" + encodeURIComponent("" + domain) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_CheckTenantRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_CheckTenantRegistration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_CheckTenantRegistration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_Register(body: RegisterRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Register(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Register(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_Register(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    auth_TestIdentity(): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_TestIdentity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_TestIdentity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_TestIdentity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_TestIdentity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    auth_DebugClaims(): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_DebugClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_DebugClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_DebugClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_DebugClaims(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_Login(body: LoginRequest | undefined): Observable<AuthResult> {
        let url_ = this.baseUrl + "/api/Auth/Auth_Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Login(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Login(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResult>;
        }));
    }

    protected processAuth_Login(response: HttpResponseBase): Observable<AuthResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_Refresh(body: RefreshTokenRequest | undefined): Observable<AuthResult> {
        let url_ = this.baseUrl + "/api/Auth/Auth_Refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Refresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Refresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResult>;
        }));
    }

    protected processAuth_Refresh(response: HttpResponseBase): Observable<AuthResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_Revoke(body: RevokeTokenRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_Revoke";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Revoke(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Revoke(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_Revoke(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_ForgotPassword(body: ForgotPasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_ForgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_ForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_ForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_ForgotPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_ResetPassword(body: ResetPasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_ResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_ResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_ResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth_ChangePassword(body: ChangePasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Auth_ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_ChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_ChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_ChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BeneficiaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    beneficiary_GetById(id: string): Observable<BeneficiaryDto> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto>;
        }));
    }

    protected processBeneficiary_GetById(response: HttpResponseBase): Observable<BeneficiaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    beneficiary_GetAllBeneficiaries(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<BeneficiaryDto[]> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_GetAllBeneficiaries?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_GetAllBeneficiaries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_GetAllBeneficiaries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto[]>;
        }));
    }

    protected processBeneficiary_GetAllBeneficiaries(response: HttpResponseBase): Observable<BeneficiaryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BeneficiaryDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    beneficiary_GetMyBeneficiaries(): Observable<BeneficiaryDto[]> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_GetMyBeneficiaries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_GetMyBeneficiaries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_GetMyBeneficiaries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto[]>;
        }));
    }

    protected processBeneficiary_GetMyBeneficiaries(response: HttpResponseBase): Observable<BeneficiaryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BeneficiaryDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    beneficiary_GetBeneficiariesByMemberId(memberId: string): Observable<BeneficiaryDto[]> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_GetBeneficiariesByMemberId/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_GetBeneficiariesByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_GetBeneficiariesByMemberId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto[]>;
        }));
    }

    protected processBeneficiary_GetBeneficiariesByMemberId(response: HttpResponseBase): Observable<BeneficiaryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BeneficiaryDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    beneficiary_CreateBeneficiary(body: BeneficiaryDto | undefined): Observable<BeneficiaryDto> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_CreateBeneficiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_CreateBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_CreateBeneficiary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto>;
        }));
    }

    protected processBeneficiary_CreateBeneficiary(response: HttpResponseBase): Observable<BeneficiaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = BeneficiaryDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    beneficiary_UpdateBeneficiary(body: BeneficiaryDto | undefined): Observable<BeneficiaryDto> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_UpdateBeneficiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_UpdateBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_UpdateBeneficiary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeneficiaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeneficiaryDto>;
        }));
    }

    protected processBeneficiary_UpdateBeneficiary(response: HttpResponseBase): Observable<BeneficiaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    beneficiary_DeleteBeneficiary(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Beneficiary/Beneficiary_DeleteBeneficiary/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeneficiary_DeleteBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeneficiary_DeleteBeneficiary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBeneficiary_DeleteBeneficiary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BookingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateBookingDto | undefined): Observable<BookingDto> {
        let url_ = this.baseUrl + "/api/Booking/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BookingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BookingDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BookingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BookingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param status (optional) 
     * @return OK
     */
    list(startDate: DateTime | undefined, endDate: DateTime | undefined, status: string | undefined): Observable<BookingDto[]> {
        let url_ = this.baseUrl + "/api/Booking/list?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BookingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BookingDto[]>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<BookingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BookingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(id: string, body: UpdateBookingStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Booking/{id}/status";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    configGet(): Observable<BookingConfigDto> {
        let url_ = this.baseUrl + "/api/Booking/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfigGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfigGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BookingConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BookingConfigDto>;
        }));
    }

    protected processConfigGet(response: HttpResponseBase): Observable<BookingConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BookingConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    configPut(body: BookingConfigDto | undefined): Observable<BookingConfigDto> {
        let url_ = this.baseUrl + "/api/Booking/config";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfigPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfigPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BookingConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BookingConfigDto>;
        }));
    }

    protected processConfigPut(response: HttpResponseBase): Observable<BookingConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BookingConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendNotifications(body: SendBookingNotificationDto | undefined): Observable<BookingNotificationResponseDto> {
        let url_ = this.baseUrl + "/api/Booking/send-notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BookingNotificationResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BookingNotificationResponseDto>;
        }));
    }

    protected processSendNotifications(response: HttpResponseBase): Observable<BookingNotificationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BookingNotificationResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    bookingGet(id: string): Observable<BookingDto> {
        let url_ = this.baseUrl + "/api/Booking/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBookingGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBookingGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BookingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BookingDto>;
        }));
    }

    protected processBookingGet(response: HttpResponseBase): Observable<BookingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BookingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    bookingDelete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Booking/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBookingDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBookingDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBookingDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    customPagesGet(id: string): Observable<CustomPageDto> {
        let url_ = this.baseUrl + "/api/CustomPages/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomPagesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomPagesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomPageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomPageDto>;
        }));
    }

    protected processCustomPagesGet(response: HttpResponseBase): Observable<CustomPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomPageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    customPagesPut(id: string, body: UpdatePageDto | undefined): Observable<CustomPageDto> {
        let url_ = this.baseUrl + "/api/CustomPages/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomPagesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomPagesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomPageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomPageDto>;
        }));
    }

    protected processCustomPagesPut(response: HttpResponseBase): Observable<CustomPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomPageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    customPagesDelete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/CustomPages/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomPagesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomPagesDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCustomPagesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    customPagesPost(body: CreatePageDto | undefined): Observable<CustomPageDto> {
        let url_ = this.baseUrl + "/api/CustomPages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomPagesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomPagesPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomPageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomPageDto>;
        }));
    }

    protected processCustomPagesPost(response: HttpResponseBase): Observable<CustomPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomPageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    fileUpload(fileId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/FileUpload/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new globalThis.Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFileUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFileUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFileUpload(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantBankingPost(body: TenantBankingDetailDto | undefined): Observable<TenantBankingDetailDto> {
        let url_ = this.baseUrl + "/api/tenant-banking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantBankingPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantBankingPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantBankingDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantBankingDetailDto>;
        }));
    }

    protected processTenantBankingPost(response: HttpResponseBase): Observable<TenantBankingDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantBankingDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantBankingGet(): Observable<TenantBankingDetailDto> {
        let url_ = this.baseUrl + "/api/tenant-banking";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantBankingGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantBankingGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantBankingDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantBankingDetailDto>;
        }));
    }

    protected processTenantBankingGet(response: HttpResponseBase): Observable<TenantBankingDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantBankingDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantBankingDelete(bankingDetailId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/tenant-banking/{bankingDetailId}";
        if (bankingDetailId === undefined || bankingDetailId === null)
            throw new globalThis.Error("The parameter 'bankingDetailId' must be defined.");
        url_ = url_.replace("{bankingDetailId}", encodeURIComponent("" + bankingDetailId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantBankingDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantBankingDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processTenantBankingDelete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ClaimServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    claim_CheckEligibility(body: ClaimEligibilityCheckDto | undefined): Observable<ClaimEligibilityResultDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_CheckEligibility";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_CheckEligibility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_CheckEligibility(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimEligibilityResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimEligibilityResultDto>;
        }));
    }

    protected processClaim_CheckEligibility(response: HttpResponseBase): Observable<ClaimEligibilityResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimEligibilityResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    claim_CreateEnhancedClaim(body: EnhancedCreateClaimDto | undefined): Observable<ClaimDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_CreateEnhancedClaim";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_CreateEnhancedClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_CreateEnhancedClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto>;
        }));
    }

    protected processClaim_CreateEnhancedClaim(response: HttpResponseBase): Observable<ClaimDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    claim_GetProcessTracking(id: string): Observable<ClaimProcessTrackingDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_GetProcessTracking/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_GetProcessTracking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_GetProcessTracking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimProcessTrackingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimProcessTrackingDto>;
        }));
    }

    protected processClaim_GetProcessTracking(response: HttpResponseBase): Observable<ClaimProcessTrackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimProcessTrackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    claim_GetByBeneficiary(beneficiaryId: string): Observable<ClaimDto[]> {
        let url_ = this.baseUrl + "/api/Claim/Claim_GetByBeneficiary/{beneficiaryId}";
        if (beneficiaryId === undefined || beneficiaryId === null)
            throw new globalThis.Error("The parameter 'beneficiaryId' must be defined.");
        url_ = url_.replace("{beneficiaryId}", encodeURIComponent("" + beneficiaryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_GetByBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_GetByBeneficiary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto[]>;
        }));
    }

    protected processClaim_GetByBeneficiary(response: HttpResponseBase): Observable<ClaimDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    claim_GetByMember(memberId: string): Observable<ClaimDto[]> {
        let url_ = this.baseUrl + "/api/Claim/Claim_GetByMember/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_GetByMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_GetByMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto[]>;
        }));
    }

    protected processClaim_GetByMember(response: HttpResponseBase): Observable<ClaimDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    claim_UpdateClaimDocuments(id: string, body: { [key: string]: boolean; } | undefined): Observable<ClaimDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_UpdateClaimDocuments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_UpdateClaimDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_UpdateClaimDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto>;
        }));
    }

    protected processClaim_UpdateClaimDocuments(response: HttpResponseBase): Observable<ClaimDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    claim_CreateClaim(body: CreateClaimDto | undefined): Observable<ClaimDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_CreateClaim";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_CreateClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_CreateClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto>;
        }));
    }

    protected processClaim_CreateClaim(response: HttpResponseBase): Observable<ClaimDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    claim_GetClaimById(id: string): Observable<ClaimDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_GetClaimById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_GetClaimById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_GetClaimById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto>;
        }));
    }

    protected processClaim_GetClaimById(response: HttpResponseBase): Observable<ClaimDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    claim_GetAllClaims(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<ClaimDto[]> {
        let url_ = this.baseUrl + "/api/Claim/Claim_GetAllClaims?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_GetAllClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_GetAllClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto[]>;
        }));
    }

    protected processClaim_GetAllClaims(response: HttpResponseBase): Observable<ClaimDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param status (optional) 
     * @param notes (optional) 
     * @return OK
     */
    claim_UpdateClaimStatus(id: string, status: ClaimStatus | undefined, notes: string | undefined): Observable<ClaimDto> {
        let url_ = this.baseUrl + "/api/Claim/Claim_UpdateClaimStatus/{id}?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (notes === null)
            throw new globalThis.Error("The parameter 'notes' cannot be null.");
        else if (notes !== undefined)
            url_ += "notes=" + encodeURIComponent("" + notes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_UpdateClaimStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_UpdateClaimStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimDto>;
        }));
    }

    protected processClaim_UpdateClaimStatus(response: HttpResponseBase): Observable<ClaimDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    claim_DeleteClaim(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Claim/Claim_DeleteClaim/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim_DeleteClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim_DeleteClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processClaim_DeleteClaim(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ContactFormServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    submit(body: ContactFormDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ContactForm/submit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CouponServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    coupon_GetAll(pageNumber: number | undefined, pageSize: number | undefined, isActive: boolean | undefined): Observable<CouponListResponseDto> {
        let url_ = this.baseUrl + "/api/Coupon/Coupon_GetAll?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoupon_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoupon_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponListResponseDto>;
        }));
    }

    protected processCoupon_GetAll(response: HttpResponseBase): Observable<CouponListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    coupon_GetActive(): Observable<Coupon[]> {
        let url_ = this.baseUrl + "/api/Coupon/Coupon_GetActive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoupon_GetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoupon_GetActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Coupon[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Coupon[]>;
        }));
    }

    protected processCoupon_GetActive(response: HttpResponseBase): Observable<Coupon[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Coupon.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    coupon_GetByCode(code: string): Observable<Coupon> {
        let url_ = this.baseUrl + "/api/Coupon/Coupon_GetByCode/{code}";
        if (code === undefined || code === null)
            throw new globalThis.Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoupon_GetByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoupon_GetByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Coupon>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Coupon>;
        }));
    }

    protected processCoupon_GetByCode(response: HttpResponseBase): Observable<Coupon> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Coupon.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    coupon_Create(body: CreateCouponDto | undefined): Observable<Coupon> {
        let url_ = this.baseUrl + "/api/Coupon/Coupon_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoupon_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoupon_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Coupon>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Coupon>;
        }));
    }

    protected processCoupon_Create(response: HttpResponseBase): Observable<Coupon> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Coupon.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    coupon_Update(id: string, body: UpdateCouponDto | undefined): Observable<Coupon> {
        let url_ = this.baseUrl + "/api/Coupon/Coupon_Update/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoupon_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoupon_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Coupon>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Coupon>;
        }));
    }

    protected processCoupon_Update(response: HttpResponseBase): Observable<Coupon> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Coupon.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    coupon_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Coupon/Coupon_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoupon_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoupon_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCoupon_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    coupon_Validate(body: ValidateCouponDto | undefined): Observable<CouponValidationResult> {
        let url_ = this.baseUrl + "/api/Coupon/Coupon_Validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoupon_Validate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoupon_Validate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponValidationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponValidationResult>;
        }));
    }

    protected processCoupon_Validate(response: HttpResponseBase): Observable<CouponValidationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponValidationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    coupon_CalculateDiscount(body: ValidateCouponDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Coupon/Coupon_CalculateDiscount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoupon_CalculateDiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoupon_CalculateDiscount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCoupon_CalculateDiscount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    coupon_GetStats(): Observable<CouponStatsDto> {
        let url_ = this.baseUrl + "/api/Coupon/Coupon_GetStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoupon_GetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoupon_GetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponStatsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponStatsDto>;
        }));
    }

    protected processCoupon_GetStats(response: HttpResponseBase): Observable<CouponStatsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponStatsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    coupon_GetRedemptions(couponId: string): Observable<CouponRedemption[]> {
        let url_ = this.baseUrl + "/api/Coupon/Coupon_GetRedemptions/{couponId}";
        if (couponId === undefined || couponId === null)
            throw new globalThis.Error("The parameter 'couponId' must be defined.");
        url_ = url_.replace("{couponId}", encodeURIComponent("" + couponId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoupon_GetRedemptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoupon_GetRedemptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponRedemption[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponRedemption[]>;
        }));
    }

    protected processCoupon_GetRedemptions(response: HttpResponseBase): Observable<CouponRedemption[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CouponRedemption.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CustomerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param isActive (optional) 
     * @param search (optional) 
     * @return OK
     */
    customer_GetAll(isActive: boolean | undefined, search: string | undefined): Observable<CustomerDto[]> {
        let url_ = this.baseUrl + "/api/Customer/Customer_GetAll?";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (search === null)
            throw new globalThis.Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomer_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomer_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto[]>;
        }));
    }

    protected processCustomer_GetAll(response: HttpResponseBase): Observable<CustomerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    customer_GetById(id: string): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/Customer/Customer_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomer_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomer_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto>;
        }));
    }

    protected processCustomer_GetById(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    customer_Create(body: CreateCustomerDto | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/Customer/Customer_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomer_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomer_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto>;
        }));
    }

    protected processCustomer_Create(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CustomerDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    customer_Update(body: UpdateCustomerDto | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/Customer/Customer_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomer_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomer_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto>;
        }));
    }

    protected processCustomer_Update(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    customer_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Customer/Customer_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomer_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomer_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCustomer_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    customer_GetStats(): Observable<CustomerStatsDto> {
        let url_ = this.baseUrl + "/api/Customer/Customer_GetStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomer_GetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomer_GetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerStatsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerStatsDto>;
        }));
    }

    protected processCustomer_GetStats(response: HttpResponseBase): Observable<CustomerStatsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerStatsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CustomPagesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    all(): Observable<PageListItemDto[]> {
        let url_ = this.baseUrl + "/api/CustomPages/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageListItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageListItemDto[]>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<PageListItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PageListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    slug(slug: string): Observable<CustomPageDto> {
        let url_ = this.baseUrl + "/api/CustomPages/slug/{slug}";
        if (slug === undefined || slug === null)
            throw new globalThis.Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomPageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomPageDto>;
        }));
    }

    protected processSlug(response: HttpResponseBase): Observable<CustomPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomPageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    public(): Observable<PageListItemDto[]> {
        let url_ = this.baseUrl + "/api/CustomPages/public";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageListItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageListItemDto[]>;
        }));
    }

    protected processPublic(response: HttpResponseBase): Observable<PageListItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PageListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    navbar(): Observable<PageListItemDto[]> {
        let url_ = this.baseUrl + "/api/CustomPages/navbar";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNavbar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNavbar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageListItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageListItemDto[]>;
        }));
    }

    protected processNavbar(response: HttpResponseBase): Observable<PageListItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PageListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    footer(): Observable<PageListItemDto[]> {
        let url_ = this.baseUrl + "/api/CustomPages/footer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFooter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFooter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageListItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageListItemDto[]>;
        }));
    }

    protected processFooter(response: HttpResponseBase): Observable<PageListItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PageListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    duplicate(id: string): Observable<CustomPageDto> {
        let url_ = this.baseUrl + "/api/CustomPages/{id}/duplicate";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDuplicate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDuplicate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomPageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomPageDto>;
        }));
    }

    protected processDuplicate(response: HttpResponseBase): Observable<CustomPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomPageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(id: string, body: ToggleStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/CustomPages/{id}/status";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    order(id: string, body: UpdateOrderDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/CustomPages/{id}/order";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    limits(): Observable<PageLimitsDto> {
        let url_ = this.baseUrl + "/api/CustomPages/limits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLimits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLimits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageLimitsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageLimitsDto>;
        }));
    }

    protected processLimits(response: HttpResponseBase): Observable<PageLimitsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageLimitsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param slug (optional) 
     * @param excludeId (optional) 
     * @return OK
     */
    validateSlug(slug: string | undefined, excludeId: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/CustomPages/validate-slug?";
        if (slug === null)
            throw new globalThis.Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "slug=" + encodeURIComponent("" + slug) + "&";
        if (excludeId === null)
            throw new globalThis.Error("The parameter 'excludeId' cannot be null.");
        else if (excludeId !== undefined)
            url_ += "excludeId=" + encodeURIComponent("" + excludeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateSlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateSlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processValidateSlug(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DashboardWidgetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    dashboardWidget_GetAll(): Observable<DashboardWidgetSettingDto[]> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardWidgetSettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardWidgetSettingDto[]>;
        }));
    }

    protected processDashboardWidget_GetAll(response: HttpResponseBase): Observable<DashboardWidgetSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DashboardWidgetSettingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dashboardWidget_GetVisibleByRoles(body: string[] | undefined): Observable<DashboardWidgetSettingDto[]> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_GetVisibleByRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_GetVisibleByRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_GetVisibleByRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardWidgetSettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardWidgetSettingDto[]>;
        }));
    }

    protected processDashboardWidget_GetVisibleByRoles(response: HttpResponseBase): Observable<DashboardWidgetSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DashboardWidgetSettingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dashboardWidget_Create(body: CreateDashboardWidgetSettingDto | undefined): Observable<DashboardWidgetSettingDto> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardWidgetSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardWidgetSettingDto>;
        }));
    }

    protected processDashboardWidget_Create(response: HttpResponseBase): Observable<DashboardWidgetSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardWidgetSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dashboardWidget_Update(body: UpdateDashboardWidgetSettingDto | undefined): Observable<DashboardWidgetSettingDto> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardWidgetSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardWidgetSettingDto>;
        }));
    }

    protected processDashboardWidget_Update(response: HttpResponseBase): Observable<DashboardWidgetSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardWidgetSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dashboardWidget_Delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDashboardWidget_Delete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dashboardWidget_InitializeDefaults(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/DashboardWidget/DashboardWidget_InitializeDefaults";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardWidget_InitializeDefaults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardWidget_InitializeDefaults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDashboardWidget_InitializeDefaults(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BatchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateBatchRequest | undefined): Observable<DebitOrderBatchDto> {
        let url_ = this.baseUrl + "/api/debit-order/batch/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DebitOrderBatchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DebitOrderBatchDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DebitOrderBatchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DebitOrderBatchDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    generateFile(batchId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/debit-order/batch/{batchId}/generate-file";
        if (batchId === undefined || batchId === null)
            throw new globalThis.Error("The parameter 'batchId' must be defined.");
        url_ = url_.replace("{batchId}", encodeURIComponent("" + batchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param responseFile (optional) 
     * @return OK
     */
    processResponse(responseFile: FileParameter | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/debit-order/batch/process-response";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (responseFile === null || responseFile === undefined)
            throw new globalThis.Error("The parameter 'responseFile' cannot be null.");
        else
            content_.append("responseFile", responseFile.data, responseFile.fileName ? responseFile.fileName : "responseFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessResponse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processProcessResponse(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class Debit_orderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    batchList(page: number | undefined, pageSize: number | undefined): Observable<DebitOrderBatchDto[]> {
        let url_ = this.baseUrl + "/api/debit-order/batch-list?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DebitOrderBatchDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DebitOrderBatchDto[]>;
        }));
    }

    protected processBatchList(response: HttpResponseBase): Observable<DebitOrderBatchDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DebitOrderBatchDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    batchById(batchId: string): Observable<DebitOrderBatchDto> {
        let url_ = this.baseUrl + "/api/debit-order/batch-by-id/{batchId}";
        if (batchId === undefined || batchId === null)
            throw new globalThis.Error("The parameter 'batchId' must be defined.");
        url_ = url_.replace("{batchId}", encodeURIComponent("" + batchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DebitOrderBatchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DebitOrderBatchDto>;
        }));
    }

    protected processBatchById(response: HttpResponseBase): Observable<DebitOrderBatchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DebitOrderBatchDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    batchTransactions(batchId: string): Observable<DebitOrderTransactionDto[]> {
        let url_ = this.baseUrl + "/api/debit-order/batch-transactions/{batchId}";
        if (batchId === undefined || batchId === null)
            throw new globalThis.Error("The parameter 'batchId' must be defined.");
        url_ = url_.replace("{batchId}", encodeURIComponent("" + batchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DebitOrderTransactionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DebitOrderTransactionDto[]>;
        }));
    }

    protected processBatchTransactions(response: HttpResponseBase): Observable<DebitOrderTransactionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DebitOrderTransactionDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DependentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    dependent_GetById(id: string): Observable<DependentDto> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto>;
        }));
    }

    protected processDependent_GetById(response: HttpResponseBase): Observable<DependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DependentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    dependent_GetAllDependents(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<DependentDto[]> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_GetAllDependents?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_GetAllDependents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_GetAllDependents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto[]>;
        }));
    }

    protected processDependent_GetAllDependents(response: HttpResponseBase): Observable<DependentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DependentDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dependent_GetMyDependents(): Observable<DependentDto[]> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_GetMyDependents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_GetMyDependents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_GetMyDependents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto[]>;
        }));
    }

    protected processDependent_GetMyDependents(response: HttpResponseBase): Observable<DependentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DependentDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dependent_GetDependentsByMemberId(memberId: string): Observable<DependentDto[]> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_GetDependentsByMemberId/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_GetDependentsByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_GetDependentsByMemberId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto[]>;
        }));
    }

    protected processDependent_GetDependentsByMemberId(response: HttpResponseBase): Observable<DependentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DependentDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    dependent_CreateDependent(body: DependentDto | undefined): Observable<DependentDto> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_CreateDependent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_CreateDependent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_CreateDependent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto>;
        }));
    }

    protected processDependent_CreateDependent(response: HttpResponseBase): Observable<DependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DependentDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dependent_UpdateDependent(body: DependentDto | undefined): Observable<DependentDto> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_UpdateDependent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_UpdateDependent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_UpdateDependent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DependentDto>;
        }));
    }

    protected processDependent_UpdateDependent(response: HttpResponseBase): Observable<DependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DependentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    dependent_DeleteDependent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Dependent/Dependent_DeleteDependent/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependent_DeleteDependent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependent_DeleteDependent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDependent_DeleteDependent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DocumentRequirementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    documentRequirement_GetRequiredDocuments(memberId: string): Observable<DocumentRequirement[]> {
        let url_ = this.baseUrl + "/api/DocumentRequirement/DocumentRequirement_GetRequiredDocuments/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentRequirement_GetRequiredDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentRequirement_GetRequiredDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentRequirement[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentRequirement[]>;
        }));
    }

    protected processDocumentRequirement_GetRequiredDocuments(response: HttpResponseBase): Observable<DocumentRequirement[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentRequirement.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    documentRequirement_GetComplianceStatus(memberId: string): Observable<DocumentComplianceStatus> {
        let url_ = this.baseUrl + "/api/DocumentRequirement/DocumentRequirement_GetComplianceStatus/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentRequirement_GetComplianceStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentRequirement_GetComplianceStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentComplianceStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentComplianceStatus>;
        }));
    }

    protected processDocumentRequirement_GetComplianceStatus(response: HttpResponseBase): Observable<DocumentComplianceStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentComplianceStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    documentRequirement_GetMissingDocuments(memberId: string): Observable<DocumentRequirement[]> {
        let url_ = this.baseUrl + "/api/DocumentRequirement/DocumentRequirement_GetMissingDocuments/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentRequirement_GetMissingDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentRequirement_GetMissingDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentRequirement[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentRequirement[]>;
        }));
    }

    protected processDocumentRequirement_GetMissingDocuments(response: HttpResponseBase): Observable<DocumentRequirement[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentRequirement.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FileUploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param entityType (optional) 
     * @param entityId (optional) 
     * @param documentType (optional) 
     * @param memberDocumentType (optional) 
     * @param isRequired (optional) 
     * @param file (optional) 
     * @return OK
     */
    file_UploadFile(entityType: string | undefined, entityId: string | undefined, documentType: string | undefined, memberDocumentType: number | undefined, isRequired: boolean | undefined, file: FileParameter | undefined): Observable<FileMetadataDto> {
        let url_ = this.baseUrl + "/api/FileUpload/File_UploadFile?";
        if (entityType === null)
            throw new globalThis.Error("The parameter 'entityType' cannot be null.");
        else if (entityType !== undefined)
            url_ += "entityType=" + encodeURIComponent("" + entityType) + "&";
        if (entityId === null)
            throw new globalThis.Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (documentType === null)
            throw new globalThis.Error("The parameter 'documentType' cannot be null.");
        else if (documentType !== undefined)
            url_ += "documentType=" + encodeURIComponent("" + documentType) + "&";
        if (memberDocumentType === null)
            throw new globalThis.Error("The parameter 'memberDocumentType' cannot be null.");
        else if (memberDocumentType !== undefined)
            url_ += "memberDocumentType=" + encodeURIComponent("" + memberDocumentType) + "&";
        if (isRequired === null)
            throw new globalThis.Error("The parameter 'isRequired' cannot be null.");
        else if (isRequired !== undefined)
            url_ += "isRequired=" + encodeURIComponent("" + isRequired) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_UploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_UploadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileMetadataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileMetadataDto>;
        }));
    }

    protected processFile_UploadFile(response: HttpResponseBase): Observable<FileMetadataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileMetadataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    file_GetMyFiles(): Observable<FileMetadataDto[]> {
        let url_ = this.baseUrl + "/api/FileUpload/File_GetMyFiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_GetMyFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_GetMyFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileMetadataDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileMetadataDto[]>;
        }));
    }

    protected processFile_GetMyFiles(response: HttpResponseBase): Observable<FileMetadataDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileMetadataDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    file_GetFilesByMemberId(memberId: string): Observable<FileMetadataDto[]> {
        let url_ = this.baseUrl + "/api/FileUpload/File_GetFilesByMemberId/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_GetFilesByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_GetFilesByMemberId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileMetadataDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileMetadataDto[]>;
        }));
    }

    protected processFile_GetFilesByMemberId(response: HttpResponseBase): Observable<FileMetadataDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileMetadataDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    file_GetByFileId(fileId: string): Observable<FileMetadataDto> {
        let url_ = this.baseUrl + "/api/FileUpload/File_GetByFileId/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new globalThis.Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_GetByFileId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_GetByFileId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileMetadataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileMetadataDto>;
        }));
    }

    protected processFile_GetByFileId(response: HttpResponseBase): Observable<FileMetadataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileMetadataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    file_DeleteFile(fileId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/FileUpload/File_DeleteFile/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new globalThis.Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_DeleteFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_DeleteFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFile_DeleteFile(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    file_DownloadFile(fileId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/FileUpload/File_DownloadFile/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new globalThis.Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_DownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_DownloadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFile_DownloadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FuneralEventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    funeralEvent_CreateFuneralEvent(body: FuneralEventDto | undefined): Observable<FuneralEventDto> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_CreateFuneralEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_CreateFuneralEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_CreateFuneralEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto>;
        }));
    }

    protected processFuneralEvent_CreateFuneralEvent(response: HttpResponseBase): Observable<FuneralEventDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuneralEventDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    funeralEvent_GetFuneralEventById(id: string): Observable<FuneralEventDto> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_GetFuneralEventById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_GetFuneralEventById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_GetFuneralEventById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto>;
        }));
    }

    protected processFuneralEvent_GetFuneralEventById(response: HttpResponseBase): Observable<FuneralEventDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuneralEventDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    funeralEvent_GetAllFuneralEvents(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<FuneralEventDto[]> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_GetAllFuneralEvents?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_GetAllFuneralEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_GetAllFuneralEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto[]>;
        }));
    }

    protected processFuneralEvent_GetAllFuneralEvents(response: HttpResponseBase): Observable<FuneralEventDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FuneralEventDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    funeralEvent_UpdateFuneralEvent(id: string, body: FuneralEventDto | undefined): Observable<FuneralEventDto> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_UpdateFuneralEvent/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_UpdateFuneralEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_UpdateFuneralEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto>;
        }));
    }

    protected processFuneralEvent_UpdateFuneralEvent(response: HttpResponseBase): Observable<FuneralEventDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuneralEventDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param status (optional) 
     * @return OK
     */
    funeralEvent_UpdateFuneralEventStatus(id: string, status: FuneralEventStatus | undefined): Observable<FuneralEventDto> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_UpdateFuneralEventStatus/{id}?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_UpdateFuneralEventStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_UpdateFuneralEventStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto>;
        }));
    }

    protected processFuneralEvent_UpdateFuneralEventStatus(response: HttpResponseBase): Observable<FuneralEventDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuneralEventDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    funeralEvent_DeleteFuneralEvent(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/FuneralEvent/FuneralEvent_DeleteFuneralEvent/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFuneralEvent_DeleteFuneralEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFuneralEvent_DeleteFuneralEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFuneralEvent_DeleteFuneralEvent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    invoice_GetById(id: string): Observable<Invoice> {
        let url_ = this.baseUrl + "/api/Invoice/Invoice_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Invoice>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Invoice>;
        }));
    }

    protected processInvoice_GetById(response: HttpResponseBase): Observable<Invoice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    invoice_GetMy(pageNumber: number | undefined, pageSize: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoice/Invoice_GetMy?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_GetMy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_GetMy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoice_GetMy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    invoice_Download(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoice/Invoice_Download/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_Download(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_Download(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoice_Download(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    invoice_Resend(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoice/Invoice_Resend/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_Resend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_Resend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoice_Resend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param status (optional) 
     * @param searchTerm (optional) 
     * @return OK
     */
    invoice_GetAll(pageNumber: number | undefined, pageSize: number | undefined, status: string | undefined, searchTerm: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoice/Invoice_GetAll?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (searchTerm === null)
            throw new globalThis.Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoice_GetAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    invoice_GetByTenant(tenantId: string, pageNumber: number | undefined, pageSize: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoice/Invoice_GetByTenant/{tenantId}?";
        if (tenantId === undefined || tenantId === null)
            throw new globalThis.Error("The parameter 'tenantId' must be defined.");
        url_ = url_.replace("{tenantId}", encodeURIComponent("" + tenantId));
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_GetByTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_GetByTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoice_GetByTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    invoice_GeneratePdf(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoice/Invoice_GeneratePdf/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_GeneratePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_GeneratePdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoice_GeneratePdf(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    invoice_Void(id: string, body: VoidInvoiceRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoice/Invoice_Void/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_Void(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_Void(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoice_Void(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    invoice_GetStats(): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoice/Invoice_GetStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_GetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_GetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoice_GetStats(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LandingPageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    landingPage_GetLandingPage(): Observable<LandingPageDto> {
        let url_ = this.baseUrl + "/api/LandingPage/LandingPage_GetLandingPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLandingPage_GetLandingPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLandingPage_GetLandingPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LandingPageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LandingPageDto>;
        }));
    }

    protected processLandingPage_GetLandingPage(response: HttpResponseBase): Observable<LandingPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LandingPageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    landingPage_CreateOrUpdateLandingPage(body: LandingPageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/LandingPage/LandingPage_CreateOrUpdateLandingPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLandingPage_CreateOrUpdateLandingPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLandingPage_CreateOrUpdateLandingPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLandingPage_CreateOrUpdateLandingPage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getEnumValues(enumTypeName: string): Observable<LookupDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetEnumValues/{enumTypeName}";
        if (enumTypeName === undefined || enumTypeName === null)
            throw new globalThis.Error("The parameter 'enumTypeName' must be defined.");
        url_ = url_.replace("{enumTypeName}", encodeURIComponent("" + enumTypeName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupDto[]>;
        }));
    }

    protected processGetEnumValues(response: HttpResponseBase): Observable<LookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MemberServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    member_GetById(id: string): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_GetById(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    member_GetAllMembers(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<MemberDto[]> {
        let url_ = this.baseUrl + "/api/Member/Member_GetAllMembers?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_GetAllMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_GetAllMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto[]>;
        }));
    }

    protected processMember_GetAllMembers(response: HttpResponseBase): Observable<MemberDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MemberDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    member_Create(body: CreateMemberDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Member/Member_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processMember_Create(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    member_ApproveMember(id: string): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_ApproveMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_ApproveMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_ApproveMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_ApproveMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    member_RejectMember(id: string, body: string | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_RejectMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_RejectMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_RejectMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_RejectMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    member_DisableMember(id: string): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_DisableMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_DisableMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_DisableMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_DisableMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    member_EnableMember(id: string): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_EnableMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_EnableMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_EnableMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_EnableMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    member_UpdateMember(id: string, body: MemberDto | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/Member/Member_UpdateMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_UpdateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_UpdateMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDto>;
        }));
    }

    protected processMember_UpdateMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    member_DeleteMember(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Member/Member_DeleteMember/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_DeleteMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_DeleteMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMember_DeleteMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    member_SaveSignature(body: SaveSignatureDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Member/Member_SaveSignature";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_SaveSignature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_SaveSignature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMember_SaveSignature(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    member_GetMySignature(): Observable<void> {
        let url_ = this.baseUrl + "/api/Member/Member_GetMySignature";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_GetMySignature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_GetMySignature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMember_GetMySignature(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param memberId (optional) 
     * @return OK
     */
    member_GetSignatureForMember(memberId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Member/Member_GetSignatureForMember?";
        if (memberId === null)
            throw new globalThis.Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMember_GetSignatureForMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMember_GetSignatureForMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMember_GetSignatureForMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MemberApprovalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    memberApproval_GetPendingMembers(): Observable<PendingMemberDto[]> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_GetPendingMembers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_GetPendingMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_GetPendingMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingMemberDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingMemberDto[]>;
        }));
    }

    protected processMemberApproval_GetPendingMembers(response: HttpResponseBase): Observable<PendingMemberDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PendingMemberDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberApproval_GetMemberDetail(memberId: string): Observable<MemberApprovalDetailDto> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_GetMemberDetail/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_GetMemberDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_GetMemberDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberApprovalDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberApprovalDetailDto>;
        }));
    }

    protected processMemberApproval_GetMemberDetail(response: HttpResponseBase): Observable<MemberApprovalDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberApprovalDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberApproval_ApproveMember(body: ApproveMemberRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_ApproveMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_ApproveMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_ApproveMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberApproval_ApproveMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberApproval_RejectMember(body: RejectMemberRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_RejectMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_RejectMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_RejectMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberApproval_RejectMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberApproval_RequestUpdates(body: RequestMemberUpdatesRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_RequestUpdates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_RequestUpdates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_RequestUpdates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberApproval_RequestUpdates(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberApproval_GetStats(): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberApproval/MemberApproval_GetStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberApproval_GetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberApproval_GetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberApproval_GetStats(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MemberBankingDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    memberBankingDetail_GetMyBankingDetails(): Observable<MemberBankingDetailDto> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_GetMyBankingDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_GetMyBankingDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_GetMyBankingDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberBankingDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberBankingDetailDto>;
        }));
    }

    protected processMemberBankingDetail_GetMyBankingDetails(response: HttpResponseBase): Observable<MemberBankingDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberBankingDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberBankingDetail_GetBankingDetailsByMemberId(memberId: string): Observable<MemberBankingDetailDto> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_GetBankingDetailsByMemberId/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_GetBankingDetailsByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_GetBankingDetailsByMemberId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberBankingDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberBankingDetailDto>;
        }));
    }

    protected processMemberBankingDetail_GetBankingDetailsByMemberId(response: HttpResponseBase): Observable<MemberBankingDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberBankingDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberBankingDetail_HasBankingDetails(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_HasBankingDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_HasBankingDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_HasBankingDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processMemberBankingDetail_HasBankingDetails(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberBankingDetail_CreateBankingDetails(body: CreateMemberBankingDetailDto | undefined): Observable<MemberBankingDetailDto> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_CreateBankingDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_CreateBankingDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_CreateBankingDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberBankingDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberBankingDetailDto>;
        }));
    }

    protected processMemberBankingDetail_CreateBankingDetails(response: HttpResponseBase): Observable<MemberBankingDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberBankingDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberBankingDetail_UpdateBankingDetails(id: string, body: UpdateMemberBankingDetailDto | undefined): Observable<MemberBankingDetailDto> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_UpdateBankingDetails/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_UpdateBankingDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_UpdateBankingDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberBankingDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberBankingDetailDto>;
        }));
    }

    protected processMemberBankingDetail_UpdateBankingDetails(response: HttpResponseBase): Observable<MemberBankingDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberBankingDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberBankingDetail_DeleteBankingDetails(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberBankingDetail/MemberBankingDetail_DeleteBankingDetails/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberBankingDetail_DeleteBankingDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberBankingDetail_DeleteBankingDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberBankingDetail_DeleteBankingDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MemberProfileCompletionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    profileCompletion_GetStatus(memberId: string): Observable<ProfileCompletionStatusDto> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_GetStatus/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_GetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_GetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileCompletionStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileCompletionStatusDto>;
        }));
    }

    protected processProfileCompletion_GetStatus(response: HttpResponseBase): Observable<ProfileCompletionStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileCompletionStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    profileCompletion_GetMyStatus(): Observable<ProfileCompletionStatusDto> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_GetMyStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_GetMyStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_GetMyStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileCompletionStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileCompletionStatusDto>;
        }));
    }

    protected processProfileCompletion_GetMyStatus(response: HttpResponseBase): Observable<ProfileCompletionStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileCompletionStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    profileCompletion_Initialize(body: string | undefined): Observable<MemberProfileCompletionDto> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_Initialize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_Initialize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_Initialize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberProfileCompletionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberProfileCompletionDto>;
        }));
    }

    protected processProfileCompletion_Initialize(response: HttpResponseBase): Observable<MemberProfileCompletionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberProfileCompletionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    profileCompletion_UpdateStep(body: UpdateProfileCompletionStepDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_UpdateStep";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_UpdateStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_UpdateStep(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProfileCompletion_UpdateStep(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    profileCompletion_Recalculate(memberId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_Recalculate/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_Recalculate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_Recalculate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProfileCompletion_Recalculate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    profileCompletion_RecalculateMy(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_RecalculateMy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_RecalculateMy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_RecalculateMy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProfileCompletion_RecalculateMy(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    profileCompletion_GetIncompleteMembers(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/MemberProfileCompletion/ProfileCompletion_GetIncompleteMembers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileCompletion_GetIncompleteMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileCompletion_GetIncompleteMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processProfileCompletion_GetIncompleteMembers(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MemberRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberRegistration_CheckIdNumber(body: CheckIdNumberDto | undefined): Observable<CheckIdNumberResponseDto> {
        let url_ = this.baseUrl + "/api/MemberRegistration/MemberRegistration_CheckIdNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberRegistration_CheckIdNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberRegistration_CheckIdNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckIdNumberResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckIdNumberResponseDto>;
        }));
    }

    protected processMemberRegistration_CheckIdNumber(response: HttpResponseBase): Observable<CheckIdNumberResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckIdNumberResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    memberRegistration_GetPolicyOptions(): Observable<PolicyOptionDto[]> {
        let url_ = this.baseUrl + "/api/MemberRegistration/MemberRegistration_GetPolicyOptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberRegistration_GetPolicyOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberRegistration_GetPolicyOptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyOptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyOptionDto[]>;
        }));
    }

    protected processMemberRegistration_GetPolicyOptions(response: HttpResponseBase): Observable<PolicyOptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PolicyOptionDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberRegistration_RegisterNewMember(body: RegisterNewMemberDto | undefined): Observable<AuthResult> {
        let url_ = this.baseUrl + "/api/MemberRegistration/MemberRegistration_RegisterNewMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberRegistration_RegisterNewMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberRegistration_RegisterNewMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResult>;
        }));
    }

    protected processMemberRegistration_RegisterNewMember(response: HttpResponseBase): Observable<AuthResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberRegistration_SendDependentOtp(body: RequestDependentOtpDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MemberRegistration/MemberRegistration_SendDependentOtp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberRegistration_SendDependentOtp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberRegistration_SendDependentOtp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMemberRegistration_SendDependentOtp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    memberRegistration_VerifyOtpAndCreateAccount(body: VerifyDependentOtpDto | undefined): Observable<AuthResult> {
        let url_ = this.baseUrl + "/api/MemberRegistration/MemberRegistration_VerifyOtpAndCreateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberRegistration_VerifyOtpAndCreateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberRegistration_VerifyOtpAndCreateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResult>;
        }));
    }

    protected processMemberRegistration_VerifyOtpAndCreateAccount(response: HttpResponseBase): Observable<AuthResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NgoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getGrantApplications(): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/GetGrantApplications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGrantApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGrantApplications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetGrantApplications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createGrantApplication(body: GrantApplication | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/CreateGrantApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGrantApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGrantApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateGrantApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateGrantApplication(id: number, body: GrantApplication | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/UpdateGrantApplication/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGrantApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGrantApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateGrantApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteGrantApplication(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/DeleteGrantApplication/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGrantApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGrantApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteGrantApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getImpactReports(): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/GetImpactReports";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImpactReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImpactReports(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetImpactReports(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createImpactReport(body: ImpactReport | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/CreateImpactReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateImpactReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateImpactReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateImpactReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateImpactReport(id: number, body: ImpactReport | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/UpdateImpactReport/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateImpactReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateImpactReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateImpactReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteImpactReport(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/DeleteImpactReport/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImpactReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImpactReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteImpactReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getDonorRecognitions(): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/GetDonorRecognitions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDonorRecognitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDonorRecognitions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetDonorRecognitions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createDonorRecognition(body: DonorRecognition | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/CreateDonorRecognition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDonorRecognition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDonorRecognition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateDonorRecognition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateDonorRecognition(id: number, body: DonorRecognition | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/UpdateDonorRecognition/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDonorRecognition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDonorRecognition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDonorRecognition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteDonorRecognition(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/DeleteDonorRecognition/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDonorRecognition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDonorRecognition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDonorRecognition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getNgoEvents(): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/GetNgoEvents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNgoEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNgoEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetNgoEvents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createNgoEvent(body: NgoEvent | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/CreateNgoEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNgoEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNgoEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateNgoEvent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateNgoEvent(id: number, body: NgoEvent | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/UpdateNgoEvent/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNgoEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNgoEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNgoEvent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteNgoEvent(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/DeleteNgoEvent/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNgoEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNgoEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteNgoEvent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getNgoBlogPosts(): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/GetNgoBlogPosts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNgoBlogPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNgoBlogPosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetNgoBlogPosts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createNgoBlogPost(body: NgoBlogPost | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/CreateNgoBlogPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNgoBlogPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNgoBlogPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateNgoBlogPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateNgoBlogPost(id: number, body: NgoBlogPost | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/UpdateNgoBlogPost/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNgoBlogPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNgoBlogPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNgoBlogPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteNgoBlogPost(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/DeleteNgoBlogPost/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNgoBlogPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNgoBlogPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteNgoBlogPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getPaymentGatewayConfigs(): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/GetPaymentGatewayConfigs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentGatewayConfigs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentGatewayConfigs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetPaymentGatewayConfigs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updatePaymentGatewayConfig(id: number, body: PaymentGatewayConfig | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ngo/UpdatePaymentGatewayConfig/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePaymentGatewayConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePaymentGatewayConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePaymentGatewayConfig(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OnboardingContractServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    generate(body: GenerateContractRequest | undefined): Observable<ContractGenerationResult> {
        let url_ = this.baseUrl + "/api/OnboardingContract/generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractGenerationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractGenerationResult>;
        }));
    }

    protected processGenerate(response: HttpResponseBase): Observable<ContractGenerationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractGenerationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sign(body: SignContractRequest | undefined): Observable<OnboardingContractDto> {
        let url_ = this.baseUrl + "/api/OnboardingContract/sign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSign(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingContractDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingContractDto>;
        }));
    }

    protected processSign(response: HttpResponseBase): Observable<OnboardingContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    contractById(contractId: string): Observable<OnboardingContractDto> {
        let url_ = this.baseUrl + "/api/OnboardingContract/contract-by-id/{contractId}";
        if (contractId === undefined || contractId === null)
            throw new globalThis.Error("The parameter 'contractId' must be defined.");
        url_ = url_.replace("{contractId}", encodeURIComponent("" + contractId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingContractDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingContractDto>;
        }));
    }

    protected processContractById(response: HttpResponseBase): Observable<OnboardingContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    contractsByMember(memberId: string): Observable<OnboardingContractDto[]> {
        let url_ = this.baseUrl + "/api/OnboardingContract/contracts-by-member/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractsByMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractsByMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingContractDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingContractDto[]>;
        }));
    }

    protected processContractsByMember(response: HttpResponseBase): Observable<OnboardingContractDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OnboardingContractDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    contractDownload(contractId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingContract/contract-download/{contractId}";
        if (contractId === undefined || contractId === null)
            throw new globalThis.Error("The parameter 'contractId' must be defined.");
        url_ = url_.replace("{contractId}", encodeURIComponent("" + contractId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractDownload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processContractDownload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OnboardingFieldConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    onboardingFieldConfiguration_GetAll(): Observable<OnboardingFieldConfigurationDto[]> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingFieldConfigurationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingFieldConfigurationDto[]>;
        }));
    }

    protected processOnboardingFieldConfiguration_GetAll(response: HttpResponseBase): Observable<OnboardingFieldConfigurationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OnboardingFieldConfigurationDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_GetById(id: string | undefined): Observable<OnboardingFieldConfigurationDto> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_GetById?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingFieldConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingFieldConfigurationDto>;
        }));
    }

    protected processOnboardingFieldConfiguration_GetById(response: HttpResponseBase): Observable<OnboardingFieldConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingFieldConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldConfiguration_GetEnabled(): Observable<OnboardingFieldConfigurationDto[]> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_GetEnabled";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_GetEnabled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_GetEnabled(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingFieldConfigurationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingFieldConfigurationDto[]>;
        }));
    }

    protected processOnboardingFieldConfiguration_GetEnabled(response: HttpResponseBase): Observable<OnboardingFieldConfigurationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OnboardingFieldConfigurationDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param context (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_GetEnabledByContext(context: string | undefined): Observable<OnboardingFieldConfigurationDto[]> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_GetEnabledByContext?";
        if (context === null)
            throw new globalThis.Error("The parameter 'context' cannot be null.");
        else if (context !== undefined)
            url_ += "context=" + encodeURIComponent("" + context) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_GetEnabledByContext(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_GetEnabledByContext(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingFieldConfigurationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingFieldConfigurationDto[]>;
        }));
    }

    protected processOnboardingFieldConfiguration_GetEnabledByContext(response: HttpResponseBase): Observable<OnboardingFieldConfigurationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OnboardingFieldConfigurationDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldConfiguration_GetByCategory(): Observable<{ [key: string]: OnboardingFieldConfigurationDto[]; }> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_GetByCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_GetByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_GetByCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: OnboardingFieldConfigurationDto[]; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: OnboardingFieldConfigurationDto[]; }>;
        }));
    }

    protected processOnboardingFieldConfiguration_GetByCategory(response: HttpResponseBase): Observable<{ [key: string]: OnboardingFieldConfigurationDto[]; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (result200 as any)![key] = resultData200[key] ? resultData200[key].map((i: any) => OnboardingFieldConfigurationDto.fromJS(i)) : [];
                }
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_Create(body: CreateOnboardingFieldConfigurationDto | undefined): Observable<OnboardingFieldConfigurationDto> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingFieldConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingFieldConfigurationDto>;
        }));
    }

    protected processOnboardingFieldConfiguration_Create(response: HttpResponseBase): Observable<OnboardingFieldConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingFieldConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_Update(body: UpdateOnboardingFieldConfigurationDto | undefined): Observable<OnboardingFieldConfigurationDto> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnboardingFieldConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnboardingFieldConfigurationDto>;
        }));
    }

    protected processOnboardingFieldConfiguration_Update(response: HttpResponseBase): Observable<OnboardingFieldConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingFieldConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_Delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_Delete?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldConfiguration_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_UpdateOrders(body: UpdateFieldOrderDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_UpdateOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_UpdateOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_UpdateOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldConfiguration_UpdateOrders(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldConfiguration_InitializeDefaults(): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_InitializeDefaults";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_InitializeDefaults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_InitializeDefaults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldConfiguration_InitializeDefaults(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldConfiguration_SaveMemberData(body: SaveMemberOnboardingDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_SaveMemberData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_SaveMemberData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_SaveMemberData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldConfiguration_SaveMemberData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldConfiguration_GetMemberData(): Observable<MemberOnboardingDataDto> {
        let url_ = this.baseUrl + "/api/OnboardingFieldConfiguration/OnboardingFieldConfiguration_GetMemberData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldConfiguration_GetMemberData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldConfiguration_GetMemberData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberOnboardingDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberOnboardingDataDto>;
        }));
    }

    protected processOnboardingFieldConfiguration_GetMemberData(response: HttpResponseBase): Observable<MemberOnboardingDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberOnboardingDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OnboardingFieldDefinitionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    onboardingFieldDefinition_GetAll(): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldDefinition/OnboardingFieldDefinition_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldDefinition_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldDefinition_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldDefinition_GetAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldDefinition_GetById(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldDefinition/OnboardingFieldDefinition_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldDefinition_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldDefinition_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldDefinition_GetById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldDefinition_Create(body: CreateOnboardingFieldDefinitionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldDefinition/OnboardingFieldDefinition_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldDefinition_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldDefinition_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldDefinition_Create(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldDefinition_Update(body: UpdateOnboardingFieldDefinitionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldDefinition/OnboardingFieldDefinition_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldDefinition_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldDefinition_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldDefinition_Update(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldDefinition_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldDefinition/OnboardingFieldDefinition_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldDefinition_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldDefinition_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldDefinition_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldDefinition_Reorder(body: string[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldDefinition/OnboardingFieldDefinition_Reorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldDefinition_Reorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldDefinition_Reorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldDefinition_Reorder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OnboardingFieldGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    onboardingFieldGroup_GetAll(): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldGroup/OnboardingFieldGroup_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldGroup_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldGroup_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldGroup_GetAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldGroup_GetById(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldGroup/OnboardingFieldGroup_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldGroup_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldGroup_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldGroup_GetById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldGroup_Create(body: CreateOnboardingFieldGroupDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldGroup/OnboardingFieldGroup_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldGroup_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldGroup_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldGroup_Create(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldGroup_Update(body: UpdateOnboardingFieldGroupDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldGroup/OnboardingFieldGroup_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldGroup_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldGroup_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldGroup_Update(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingFieldGroup_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldGroup/OnboardingFieldGroup_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldGroup_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldGroup_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldGroup_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingFieldGroup_Reorder(body: string[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingFieldGroup/OnboardingFieldGroup_Reorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingFieldGroup_Reorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingFieldGroup_Reorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingFieldGroup_Reorder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OnboardingPdfServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param memberId (optional) 
     * @return OK
     */
    onboardingPdf_PreviewPdf(memberId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingPdf/OnboardingPdf_PreviewPdf?";
        if (memberId === null)
            throw new globalThis.Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingPdf_PreviewPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingPdf_PreviewPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingPdf_PreviewPdf(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param memberId (optional) 
     * @return OK
     */
    onboardingPdf_DownloadPdf(memberId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingPdf/OnboardingPdf_DownloadPdf?";
        if (memberId === null)
            throw new globalThis.Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingPdf_DownloadPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingPdf_DownloadPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingPdf_DownloadPdf(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OnboardingStepConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    onboardingStepConfiguration_GetAll(): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepConfiguration/OnboardingStepConfiguration_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepConfiguration_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepConfiguration_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepConfiguration_GetAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingStepConfiguration_GetEnabledSteps(): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepConfiguration/OnboardingStepConfiguration_GetEnabledSteps";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepConfiguration_GetEnabledSteps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepConfiguration_GetEnabledSteps(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepConfiguration_GetEnabledSteps(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingStepConfiguration_GetById(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepConfiguration/OnboardingStepConfiguration_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepConfiguration_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepConfiguration_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepConfiguration_GetById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingStepConfiguration_Create(body: CreateOnboardingStepConfigurationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepConfiguration/OnboardingStepConfiguration_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepConfiguration_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepConfiguration_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepConfiguration_Create(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingStepConfiguration_Update(body: UpdateOnboardingStepConfigurationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepConfiguration/OnboardingStepConfiguration_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepConfiguration_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepConfiguration_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepConfiguration_Update(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingStepConfiguration_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepConfiguration/OnboardingStepConfiguration_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepConfiguration_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepConfiguration_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepConfiguration_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingStepConfiguration_Reorder(body: ReorderOnboardingStepsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepConfiguration/OnboardingStepConfiguration_Reorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepConfiguration_Reorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepConfiguration_Reorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepConfiguration_Reorder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingStepConfiguration_InitializeDefaults(): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepConfiguration/OnboardingStepConfiguration_InitializeDefaults";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepConfiguration_InitializeDefaults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepConfiguration_InitializeDefaults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepConfiguration_InitializeDefaults(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OnboardingStepFieldServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    onboardingStepField_GetByStepId(stepId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepField/OnboardingStepField_GetByStepId/{stepId}";
        if (stepId === undefined || stepId === null)
            throw new globalThis.Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepField_GetByStepId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepField_GetByStepId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepField_GetByStepId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingStepField_Create(body: CreateOnboardingStepFieldDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepField/OnboardingStepField_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepField_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepField_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepField_Create(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingStepField_Update(body: UpdateOnboardingStepFieldDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepField/OnboardingStepField_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepField_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepField_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepField_Update(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    onboardingStepField_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepField/OnboardingStepField_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepField_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepField_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepField_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    onboardingStepField_Reorder(body: ReorderStepFieldsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OnboardingStepField/OnboardingStepField_Reorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnboardingStepField_Reorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnboardingStepField_Reorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOnboardingStepField_Reorder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param status (optional) 
     * @return OK
     */
    order_GetAll(status: OrderStatus | undefined): Observable<OrderDto[]> {
        let url_ = this.baseUrl + "/api/Order/Order_GetAll?";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDto[]>;
        }));
    }

    protected processOrder_GetAll(response: HttpResponseBase): Observable<OrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    order_GetById(id: string): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/Order/Order_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDto>;
        }));
    }

    protected processOrder_GetById(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    order_Create(body: CreateOrderDto | undefined): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/Order/Order_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDto>;
        }));
    }

    protected processOrder_Create(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OrderDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    order_UpdateStatus(body: UpdateOrderStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Order/Order_UpdateStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_UpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_UpdateStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOrder_UpdateStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    order_GetStats(): Observable<OrderStatsDto> {
        let url_ = this.baseUrl + "/api/Order/Order_GetStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_GetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_GetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderStatsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderStatsDto>;
        }));
    }

    protected processOrder_GetStats(response: HttpResponseBase): Observable<OrderStatsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderStatsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    payment_CreateSession(body: CreatePaymentSessionDto | undefined): Observable<PaymentSessionDto> {
        let url_ = this.baseUrl + "/api/Payment/Payment_CreateSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment_CreateSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment_CreateSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentSessionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentSessionDto>;
        }));
    }

    protected processPayment_CreateSession(response: HttpResponseBase): Observable<PaymentSessionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentSessionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    payment_GetById(id: string): Observable<Payment> {
        let url_ = this.baseUrl + "/api/Payment/Payment_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment>;
        }));
    }

    protected processPayment_GetById(response: HttpResponseBase): Observable<Payment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Payment.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    payment_GetHistory(pageNumber: number | undefined, pageSize: number | undefined): Observable<Payment[]> {
        let url_ = this.baseUrl + "/api/Payment/Payment_GetHistory?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment_GetHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment_GetHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment[]>;
        }));
    }

    protected processPayment_GetHistory(response: HttpResponseBase): Observable<Payment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Payment.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    payment_GetStatus(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Payment/Payment_GetStatus/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment_GetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment_GetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPayment_GetStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param status (optional) 
     * @param searchTerm (optional) 
     * @return OK
     */
    payment_GetAll(pageNumber: number | undefined, pageSize: number | undefined, status: string | undefined, searchTerm: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Payment/Payment_GetAll?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (searchTerm === null)
            throw new globalThis.Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPayment_GetAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    payment_Refund(id: string, body: RefundPaymentRequest | undefined): Observable<RefundResult> {
        let url_ = this.baseUrl + "/api/Payment/Payment_Refund/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment_Refund(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment_Refund(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefundResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefundResult>;
        }));
    }

    protected processPayment_Refund(response: HttpResponseBase): Observable<RefundResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefundResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    payment_GetStats(): Observable<void> {
        let url_ = this.baseUrl + "/api/Payment/Payment_GetStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment_GetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment_GetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPayment_GetStats(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class Payment_configServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    gatewayList(): Observable<PaymentGatewayConfigDto[]> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentGatewayConfigDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentGatewayConfigDto[]>;
        }));
    }

    protected processGatewayList(response: HttpResponseBase): Observable<PaymentGatewayConfigDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayConfigDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    gatewayById(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-by-id/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGatewayById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    gatewayCreate(body: PaymentGatewayConfigDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGatewayCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    gatewayUpdate(id: string, body: PaymentGatewayConfigDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-update/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGatewayUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    gatewayDelete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGatewayDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    gatewayToggle(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-config/gateway-toggle/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatewayToggle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatewayToggle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGatewayToggle(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    providers(): Observable<any[]> {
        let url_ = this.baseUrl + "/api/payment-config/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processProviders(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class Payment_gatewayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    initiate(body: InitiatePaymentRequest | undefined): Observable<PaymentInitiationResultDto> {
        let url_ = this.baseUrl + "/api/payment-gateway/initiate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitiate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitiate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentInitiationResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentInitiationResultDto>;
        }));
    }

    protected processInitiate(response: HttpResponseBase): Observable<PaymentInitiationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInitiationResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param provider (optional) 
     * @return OK
     */
    verify(transactionId: string, provider: string | undefined): Observable<PaymentVerificationResultDto> {
        let url_ = this.baseUrl + "/api/payment-gateway/verify/{transactionId}?";
        if (transactionId === undefined || transactionId === null)
            throw new globalThis.Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        if (provider === null)
            throw new globalThis.Error("The parameter 'provider' cannot be null.");
        else if (provider !== undefined)
            url_ += "provider=" + encodeURIComponent("" + provider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentVerificationResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentVerificationResultDto>;
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<PaymentVerificationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentVerificationResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param data (optional) 
     * @return OK
     */
    webhook(provider: string, data: { [key: string]: string; } | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/payment-gateway/webhook/{provider}";
        if (provider === undefined || provider === null)
            throw new globalThis.Error("The parameter 'provider' must be defined.");
        url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (data === null || data === undefined)
            throw new globalThis.Error("The parameter 'data' cannot be null.");
        else
            content_.append("data", JSON.stringify(data));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWebhook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWebhook(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PdfFieldMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    pdfFieldMapping_GetAll(): Observable<PdfFieldMappingDto[]> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfFieldMappingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfFieldMappingDto[]>;
        }));
    }

    protected processPdfFieldMapping_GetAll(response: HttpResponseBase): Observable<PdfFieldMappingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PdfFieldMappingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    pdfFieldMapping_GetById(id: string): Observable<PdfFieldMappingDto> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfFieldMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfFieldMappingDto>;
        }));
    }

    protected processPdfFieldMapping_GetById(response: HttpResponseBase): Observable<PdfFieldMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfFieldMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    pdfFieldMapping_Create(body: CreatePdfFieldMappingRequest | undefined): Observable<PdfFieldMappingDto> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfFieldMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfFieldMappingDto>;
        }));
    }

    protected processPdfFieldMapping_Create(response: HttpResponseBase): Observable<PdfFieldMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfFieldMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    pdfFieldMapping_Update(id: string, body: UpdatePdfFieldMappingRequest | undefined): Observable<PdfFieldMappingDto> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_Update/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfFieldMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfFieldMappingDto>;
        }));
    }

    protected processPdfFieldMapping_Update(response: HttpResponseBase): Observable<PdfFieldMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfFieldMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    pdfFieldMapping_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPdfFieldMapping_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    pdfFieldMapping_AnalyzeTemplate(templateFileId: string): Observable<PdfTemplateAnalysisResult> {
        let url_ = this.baseUrl + "/api/PdfFieldMapping/PdfFieldMapping_AnalyzeTemplate/{templateFileId}";
        if (templateFileId === undefined || templateFileId === null)
            throw new globalThis.Error("The parameter 'templateFileId' must be defined.");
        url_ = url_.replace("{templateFileId}", encodeURIComponent("" + templateFileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfFieldMapping_AnalyzeTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfFieldMapping_AnalyzeTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfTemplateAnalysisResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfTemplateAnalysisResult>;
        }));
    }

    protected processPdfFieldMapping_AnalyzeTemplate(response: HttpResponseBase): Observable<PdfTemplateAnalysisResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfTemplateAnalysisResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    permission_GetAllPermissions(): Observable<Permission[]> {
        let url_ = this.baseUrl + "/api/Permission/Permission_GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPermission_GetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPermission_GetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Permission[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Permission[]>;
        }));
    }

    protected processPermission_GetAllPermissions(response: HttpResponseBase): Observable<Permission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Permission.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    permission_CreatePermission(body: PermissionInput | undefined): Observable<Permission> {
        let url_ = this.baseUrl + "/api/Permission/Permission_CreatePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPermission_CreatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPermission_CreatePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Permission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Permission>;
        }));
    }

    protected processPermission_CreatePermission(response: HttpResponseBase): Observable<Permission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Permission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PersonnelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    personnel_GetMySchedule(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<FuneralEventDto[]> {
        let url_ = this.baseUrl + "/api/Personnel/Personnel_GetMySchedule?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonnel_GetMySchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonnel_GetMySchedule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuneralEventDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuneralEventDto[]>;
        }));
    }

    protected processPersonnel_GetMySchedule(response: HttpResponseBase): Observable<FuneralEventDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FuneralEventDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PlanConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    planConfiguration_GetAll(): Observable<SubscriptionPlanConfigurationDto[]> {
        let url_ = this.baseUrl + "/api/PlanConfiguration/PlanConfiguration_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlanConfiguration_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlanConfiguration_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanConfigurationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanConfigurationDto[]>;
        }));
    }

    protected processPlanConfiguration_GetAll(response: HttpResponseBase): Observable<SubscriptionPlanConfigurationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscriptionPlanConfigurationDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    planConfiguration_GetByType(tenantType: number): Observable<SubscriptionPlanConfigurationDto> {
        let url_ = this.baseUrl + "/api/PlanConfiguration/PlanConfiguration_GetByType/{tenantType}";
        if (tenantType === undefined || tenantType === null)
            throw new globalThis.Error("The parameter 'tenantType' must be defined.");
        url_ = url_.replace("{tenantType}", encodeURIComponent("" + tenantType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlanConfiguration_GetByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlanConfiguration_GetByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanConfigurationDto>;
        }));
    }

    protected processPlanConfiguration_GetByType(response: HttpResponseBase): Observable<SubscriptionPlanConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantType (optional) 
     * @return OK
     */
    planConfiguration_GetActive(tenantType: number | undefined): Observable<SubscriptionPlanConfigurationDto[]> {
        let url_ = this.baseUrl + "/api/PlanConfiguration/PlanConfiguration_GetActive?";
        if (tenantType === null)
            throw new globalThis.Error("The parameter 'tenantType' cannot be null.");
        else if (tenantType !== undefined)
            url_ += "tenantType=" + encodeURIComponent("" + tenantType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlanConfiguration_GetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlanConfiguration_GetActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanConfigurationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanConfigurationDto[]>;
        }));
    }

    protected processPlanConfiguration_GetActive(response: HttpResponseBase): Observable<SubscriptionPlanConfigurationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscriptionPlanConfigurationDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    planConfiguration_Create(body: CreatePlanConfigurationDto | undefined): Observable<SubscriptionPlanConfigurationDto> {
        let url_ = this.baseUrl + "/api/PlanConfiguration/PlanConfiguration_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlanConfiguration_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlanConfiguration_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanConfigurationDto>;
        }));
    }

    protected processPlanConfiguration_Create(response: HttpResponseBase): Observable<SubscriptionPlanConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    planConfiguration_Update(body: UpdatePlanConfigurationDto | undefined): Observable<SubscriptionPlanConfigurationDto> {
        let url_ = this.baseUrl + "/api/PlanConfiguration/PlanConfiguration_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlanConfiguration_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlanConfiguration_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanConfigurationDto>;
        }));
    }

    protected processPlanConfiguration_Update(response: HttpResponseBase): Observable<SubscriptionPlanConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    planConfiguration_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/PlanConfiguration/PlanConfiguration_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlanConfiguration_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlanConfiguration_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPlanConfiguration_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    planConfiguration_InitializeDefaults(): Observable<void> {
        let url_ = this.baseUrl + "/api/PlanConfiguration/PlanConfiguration_InitializeDefaults";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlanConfiguration_InitializeDefaults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlanConfiguration_InitializeDefaults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPlanConfiguration_InitializeDefaults(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    planConfiguration_GetProRataSetting(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/PlanConfiguration/PlanConfiguration_GetProRataSetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlanConfiguration_GetProRataSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlanConfiguration_GetProRataSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processPlanConfiguration_GetProRataSetting(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    planConfiguration_UpdateProRataSetting(body: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PlanConfiguration/PlanConfiguration_UpdateProRataSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlanConfiguration_UpdateProRataSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlanConfiguration_UpdateProRataSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPlanConfiguration_UpdateProRataSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    planConfiguration_FixLinks(): Observable<void> {
        let url_ = this.baseUrl + "/api/PlanConfiguration/PlanConfiguration_FixLinks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlanConfiguration_FixLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlanConfiguration_FixLinks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPlanConfiguration_FixLinks(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PolicyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    policy_GetById(id: string): Observable<PolicyDto> {
        let url_ = this.baseUrl + "/api/Policy/Policy_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicy_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicy_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyDto>;
        }));
    }

    protected processPolicy_GetById(response: HttpResponseBase): Observable<PolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    policy_GetAllPolicies(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<PolicyDto[]> {
        let url_ = this.baseUrl + "/api/Policy/Policy_GetAllPolicies?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicy_GetAllPolicies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicy_GetAllPolicies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyDto[]>;
        }));
    }

    protected processPolicy_GetAllPolicies(response: HttpResponseBase): Observable<PolicyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PolicyDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policy_CreatePolicy(body: PolicyDto | undefined): Observable<PolicyDto> {
        let url_ = this.baseUrl + "/api/Policy/Policy_CreatePolicy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicy_CreatePolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicy_CreatePolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyDto>;
        }));
    }

    protected processPolicy_CreatePolicy(response: HttpResponseBase): Observable<PolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policy_UpdatePolicy(body: PolicyDto | undefined): Observable<PolicyDto> {
        let url_ = this.baseUrl + "/api/Policy/Policy_UpdatePolicy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicy_UpdatePolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicy_UpdatePolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyDto>;
        }));
    }

    protected processPolicy_UpdatePolicy(response: HttpResponseBase): Observable<PolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    policy_DeletePolicy(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Policy/Policy_DeletePolicy/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicy_DeletePolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicy_DeletePolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPolicy_DeletePolicy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PolicyAttributeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    policyAttribute_GetById(id: string): Observable<PolicyAttributeDto> {
        let url_ = this.baseUrl + "/api/PolicyAttribute/PolicyAttribute_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyAttribute_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyAttribute_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyAttributeDto>;
        }));
    }

    protected processPolicyAttribute_GetById(response: HttpResponseBase): Observable<PolicyAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param policyId (optional) 
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    policyAttribute_GetAllPolicies(policyId: string | undefined, searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<PolicyAttributeDto[]> {
        let url_ = this.baseUrl + "/api/PolicyAttribute/PolicyAttribute_GetAllPolicies?";
        if (policyId === null)
            throw new globalThis.Error("The parameter 'policyId' cannot be null.");
        else if (policyId !== undefined)
            url_ += "policyId=" + encodeURIComponent("" + policyId) + "&";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyAttribute_GetAllPolicies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyAttribute_GetAllPolicies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyAttributeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyAttributeDto[]>;
        }));
    }

    protected processPolicyAttribute_GetAllPolicies(response: HttpResponseBase): Observable<PolicyAttributeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PolicyAttributeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyAttribute_UpdatePolicyAttribute(body: PolicyAttributeDto | undefined): Observable<PolicyAttributeDto> {
        let url_ = this.baseUrl + "/api/PolicyAttribute/PolicyAttribute_UpdatePolicyAttribute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyAttribute_UpdatePolicyAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyAttribute_UpdatePolicyAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyAttributeDto>;
        }));
    }

    protected processPolicyAttribute_UpdatePolicyAttribute(response: HttpResponseBase): Observable<PolicyAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    policyAttribute_CreatePolicyAttribute(body: PolicyAttributeDto | undefined): Observable<PolicyAttributeDto> {
        let url_ = this.baseUrl + "/api/PolicyAttribute/PolicyAttribute_CreatePolicyAttribute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyAttribute_CreatePolicyAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyAttribute_CreatePolicyAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyAttributeDto>;
        }));
    }

    protected processPolicyAttribute_CreatePolicyAttribute(response: HttpResponseBase): Observable<PolicyAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PolicyAttributeDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    policyAttribute_DeletePolicyAttribute(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/PolicyAttribute/PolicyAttribute_DeletePolicyAttribute/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyAttribute_DeletePolicyAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyAttribute_DeletePolicyAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPolicyAttribute_DeletePolicyAttribute(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PolicyEnrollmentApprovalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    policyApproval_SubmitForApproval(enrollmentId: string): Observable<PolicyEnrollmentDto> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_SubmitForApproval/{enrollmentId}";
        if (enrollmentId === undefined || enrollmentId === null)
            throw new globalThis.Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{enrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_SubmitForApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_SubmitForApproval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto>;
        }));
    }

    protected processPolicyApproval_SubmitForApproval(response: HttpResponseBase): Observable<PolicyEnrollmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyEnrollmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyApproval_Approve(enrollmentId: string, body: ApproveEnrollmentDto | undefined): Observable<PolicyEnrollmentDto> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_Approve/{enrollmentId}";
        if (enrollmentId === undefined || enrollmentId === null)
            throw new globalThis.Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{enrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_Approve(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_Approve(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto>;
        }));
    }

    protected processPolicyApproval_Approve(response: HttpResponseBase): Observable<PolicyEnrollmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyEnrollmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyApproval_Reject(enrollmentId: string, body: RejectEnrollmentDto | undefined): Observable<PolicyEnrollmentDto> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_Reject/{enrollmentId}";
        if (enrollmentId === undefined || enrollmentId === null)
            throw new globalThis.Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{enrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_Reject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_Reject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto>;
        }));
    }

    protected processPolicyApproval_Reject(response: HttpResponseBase): Observable<PolicyEnrollmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyEnrollmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyApproval_RequestChanges(enrollmentId: string, body: RequestChangesDto | undefined): Observable<PolicyEnrollmentDto> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_RequestChanges/{enrollmentId}";
        if (enrollmentId === undefined || enrollmentId === null)
            throw new globalThis.Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{enrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_RequestChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_RequestChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto>;
        }));
    }

    protected processPolicyApproval_RequestChanges(response: HttpResponseBase): Observable<PolicyEnrollmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyEnrollmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    policyApproval_GetByReference(referenceNumber: string): Observable<PolicyEnrollmentDto> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_GetByReference/{referenceNumber}";
        if (referenceNumber === undefined || referenceNumber === null)
            throw new globalThis.Error("The parameter 'referenceNumber' must be defined.");
        url_ = url_.replace("{referenceNumber}", encodeURIComponent("" + referenceNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_GetByReference(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_GetByReference(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto>;
        }));
    }

    protected processPolicyApproval_GetByReference(response: HttpResponseBase): Observable<PolicyEnrollmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyEnrollmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    policyApproval_GetPendingApprovals(): Observable<PolicyEnrollmentDto[]> {
        let url_ = this.baseUrl + "/api/PolicyEnrollmentApproval/PolicyApproval_GetPendingApprovals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyApproval_GetPendingApprovals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyApproval_GetPendingApprovals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyEnrollmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyEnrollmentDto[]>;
        }));
    }

    protected processPolicyApproval_GetPendingApprovals(response: HttpResponseBase): Observable<PolicyEnrollmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PolicyEnrollmentDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PolicyNumberServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    policyNumber_GetConfiguration(): Observable<PolicyNumberConfigDto> {
        let url_ = this.baseUrl + "/api/PolicyNumber/PolicyNumber_GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyNumber_GetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyNumber_GetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PolicyNumberConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PolicyNumberConfigDto>;
        }));
    }

    protected processPolicyNumber_GetConfiguration(response: HttpResponseBase): Observable<PolicyNumberConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyNumberConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyNumber_SaveConfiguration(body: PolicyNumberConfigDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PolicyNumber/PolicyNumber_SaveConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyNumber_SaveConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyNumber_SaveConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPolicyNumber_SaveConfiguration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyNumber_Generate(body: GeneratePolicyNumberRequestDto | undefined): Observable<GeneratePolicyNumberResponseDto> {
        let url_ = this.baseUrl + "/api/PolicyNumber/PolicyNumber_Generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyNumber_Generate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyNumber_Generate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneratePolicyNumberResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneratePolicyNumberResponseDto>;
        }));
    }

    protected processPolicyNumber_Generate(response: HttpResponseBase): Observable<GeneratePolicyNumberResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneratePolicyNumberResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    policyNumber_Validate(body: ValidatePolicyNumberRequestDto | undefined): Observable<ValidatePolicyNumberResponseDto> {
        let url_ = this.baseUrl + "/api/PolicyNumber/PolicyNumber_Validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyNumber_Validate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyNumber_Validate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValidatePolicyNumberResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValidatePolicyNumberResponseDto>;
        }));
    }

    protected processPolicyNumber_Validate(response: HttpResponseBase): Observable<ValidatePolicyNumberResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidatePolicyNumberResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    policyNumber_GetExampleFormat(): Observable<string> {
        let url_ = this.baseUrl + "/api/PolicyNumber/PolicyNumber_GetExampleFormat";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyNumber_GetExampleFormat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyNumber_GetExampleFormat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPolicyNumber_GetExampleFormat(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PremiumCalculationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    premiumCalculation_GetSettings(): Observable<PremiumCalculationSettingsDto> {
        let url_ = this.baseUrl + "/api/PremiumCalculation/PremiumCalculation_GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPremiumCalculation_GetSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPremiumCalculation_GetSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PremiumCalculationSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PremiumCalculationSettingsDto>;
        }));
    }

    protected processPremiumCalculation_GetSettings(response: HttpResponseBase): Observable<PremiumCalculationSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PremiumCalculationSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    premiumCalculation_SaveSettings(body: PremiumCalculationSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PremiumCalculation/PremiumCalculation_SaveSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPremiumCalculation_SaveSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPremiumCalculation_SaveSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPremiumCalculation_SaveSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    premiumCalculation_Calculate(body: CalculatePremiumRequestDto | undefined): Observable<PremiumCalculationResultDto> {
        let url_ = this.baseUrl + "/api/PremiumCalculation/PremiumCalculation_Calculate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPremiumCalculation_Calculate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPremiumCalculation_Calculate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PremiumCalculationResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PremiumCalculationResultDto>;
        }));
    }

    protected processPremiumCalculation_Calculate(response: HttpResponseBase): Observable<PremiumCalculationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PremiumCalculationResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    premiumCalculation_CalculateForMember(memberId: string): Observable<PremiumCalculationResultDto> {
        let url_ = this.baseUrl + "/api/PremiumCalculation/PremiumCalculation_CalculateForMember/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPremiumCalculation_CalculateForMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPremiumCalculation_CalculateForMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PremiumCalculationResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PremiumCalculationResultDto>;
        }));
    }

    protected processPremiumCalculation_CalculateForMember(response: HttpResponseBase): Observable<PremiumCalculationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PremiumCalculationResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    premiumCalculation_GetMyPremium(): Observable<PremiumCalculationResultDto> {
        let url_ = this.baseUrl + "/api/PremiumCalculation/PremiumCalculation_GetMyPremium";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPremiumCalculation_GetMyPremium(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPremiumCalculation_GetMyPremium(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PremiumCalculationResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PremiumCalculationResultDto>;
        }));
    }

    protected processPremiumCalculation_GetMyPremium(response: HttpResponseBase): Observable<PremiumCalculationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PremiumCalculationResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param isActive (optional) 
     * @param categoryId (optional) 
     * @return OK
     */
    product_GetAll(isActive: boolean | undefined, categoryId: string | undefined): Observable<ProductDto[]> {
        let url_ = this.baseUrl + "/api/Product/Product_GetAll?";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto[]>;
        }));
    }

    protected processProduct_GetAll(response: HttpResponseBase): Observable<ProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    product_GetById(id: string): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/Product/Product_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processProduct_GetById(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    product_Create(body: CreateProductDto | undefined): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/Product/Product_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processProduct_Create(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProductDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    product_Update(body: UpdateProductDto | undefined): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/Product/Product_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processProduct_Update(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    product_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Product/Product_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProduct_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    product_GetStats(): Observable<ProductStatsDto> {
        let url_ = this.baseUrl + "/api/Product/Product_GetStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_GetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_GetStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductStatsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductStatsDto>;
        }));
    }

    protected processProduct_GetStats(response: HttpResponseBase): Observable<ProductStatsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStatsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    category_GetAll(): Observable<CategoryDto[]> {
        let url_ = this.baseUrl + "/api/Product/Category_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDto[]>;
        }));
    }

    protected processCategory_GetAll(response: HttpResponseBase): Observable<CategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    category_Create(body: CreateCategoryDto | undefined): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/Product/Category_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDto>;
        }));
    }

    protected processCategory_Create(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CategoryDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RequiredDocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    requiredDocument_GetAll(): Observable<RequiredDocumentDto[]> {
        let url_ = this.baseUrl + "/api/RequiredDocument/RequiredDocument_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequiredDocument_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequiredDocument_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequiredDocumentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequiredDocumentDto[]>;
        }));
    }

    protected processRequiredDocument_GetAll(response: HttpResponseBase): Observable<RequiredDocumentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequiredDocumentDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    requiredDocument_GetMemberStatus(memberId: string): Observable<MemberDocumentStatusDto> {
        let url_ = this.baseUrl + "/api/RequiredDocument/RequiredDocument_GetMemberStatus/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequiredDocument_GetMemberStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequiredDocument_GetMemberStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDocumentStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDocumentStatusDto>;
        }));
    }

    protected processRequiredDocument_GetMemberStatus(response: HttpResponseBase): Observable<MemberDocumentStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDocumentStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    requiredDocument_Create(body: RequiredDocumentDto | undefined): Observable<RequiredDocumentDto> {
        let url_ = this.baseUrl + "/api/RequiredDocument/RequiredDocument_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequiredDocument_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequiredDocument_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequiredDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequiredDocumentDto>;
        }));
    }

    protected processRequiredDocument_Create(response: HttpResponseBase): Observable<RequiredDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequiredDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    requiredDocument_Update(body: RequiredDocumentDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RequiredDocument/RequiredDocument_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequiredDocument_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequiredDocument_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRequiredDocument_Update(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    requiredDocument_Delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RequiredDocument/RequiredDocument_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequiredDocument_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequiredDocument_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRequiredDocument_Delete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ResourceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resource_CreateResource(body: ResourceDto | undefined): Observable<ResourceDto> {
        let url_ = this.baseUrl + "/api/Resource/Resource_CreateResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_CreateResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_CreateResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceDto>;
        }));
    }

    protected processResource_CreateResource(response: HttpResponseBase): Observable<ResourceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    resource_GetResourceById(id: string): Observable<ResourceDto> {
        let url_ = this.baseUrl + "/api/Resource/Resource_GetResourceById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_GetResourceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_GetResourceById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceDto>;
        }));
    }

    protected processResource_GetResourceById(response: HttpResponseBase): Observable<ResourceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    resource_GetAllResources(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<ResourceDto[]> {
        let url_ = this.baseUrl + "/api/Resource/Resource_GetAllResources?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_GetAllResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_GetAllResources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceDto[]>;
        }));
    }

    protected processResource_GetAllResources(response: HttpResponseBase): Observable<ResourceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResourceDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resource_UpdateResource(id: string, body: ResourceDto | undefined): Observable<ResourceDto> {
        let url_ = this.baseUrl + "/api/Resource/Resource_UpdateResource/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_UpdateResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_UpdateResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceDto>;
        }));
    }

    protected processResource_UpdateResource(response: HttpResponseBase): Observable<ResourceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    resource_DeleteResource(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Resource/Resource_DeleteResource/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_DeleteResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_DeleteResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResource_DeleteResource(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resource_BookResource(body: ResourceBookingDto | undefined): Observable<ResourceBookingDto> {
        let url_ = this.baseUrl + "/api/Resource/Resource_BookResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_BookResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_BookResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceBookingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceBookingDto>;
        }));
    }

    protected processResource_BookResource(response: HttpResponseBase): Observable<ResourceBookingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceBookingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    resource_CancelResourceBooking(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Resource/Resource_CancelResourceBooking/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_CancelResourceBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_CancelResourceBooking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResource_CancelResourceBooking(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    resource_GetResourceBookings(funeralEventId: string): Observable<ResourceBookingDto[]> {
        let url_ = this.baseUrl + "/api/Resource/Resource_GetResourceBookings/{funeralEventId}";
        if (funeralEventId === undefined || funeralEventId === null)
            throw new globalThis.Error("The parameter 'funeralEventId' must be defined.");
        url_ = url_.replace("{funeralEventId}", encodeURIComponent("" + funeralEventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResource_GetResourceBookings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResource_GetResourceBookings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResourceBookingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResourceBookingDto[]>;
        }));
    }

    protected processResource_GetResourceBookings(response: HttpResponseBase): Observable<ResourceBookingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResourceBookingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    role_GetAllRoles(): Observable<RoleDto[]> {
        let url_ = this.baseUrl + "/api/Role/Role_GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole_GetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole_GetAllRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto[]>;
        }));
    }

    protected processRole_GetAllRoles(response: HttpResponseBase): Observable<RoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    role_CreateRole(body: RoleInput | undefined): Observable<Role> {
        let url_ = this.baseUrl + "/api/Role/Role_CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole_CreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole_CreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role>;
        }));
    }

    protected processRole_CreateRole(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    role_UpdateRole(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/Role/Role_UpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole_UpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole_UpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processRole_UpdateRole(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RolePermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    rolePermission_GetAllRolePermissions(): Observable<RolePermission[]> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermission_GetAllRolePermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermission_GetAllRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermission_GetAllRolePermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RolePermission[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RolePermission[]>;
        }));
    }

    protected processRolePermission_GetAllRolePermissions(response: HttpResponseBase): Observable<RolePermission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RolePermission.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    rolePermission_CreateRolePermission(body: CreateRolePermissionDto | undefined): Observable<RolePermission> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermission_CreateRolePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermission_CreateRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermission_CreateRolePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RolePermission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RolePermission>;
        }));
    }

    protected processRolePermission_CreateRolePermission(response: HttpResponseBase): Observable<RolePermission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    rolePermission_DeleteRolePermission(roleId: string, permissionId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermission_DeleteRolePermission/{roleId}/{permissionId}";
        if (roleId === undefined || roleId === null)
            throw new globalThis.Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (permissionId === undefined || permissionId === null)
            throw new globalThis.Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermission_DeleteRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermission_DeleteRolePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRolePermission_DeleteRolePermission(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SubscriptionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    subscriptionPlan_Create(body: SubscriptionPlanDto | undefined): Observable<SubscriptionPlanDto> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/SubscriptionPlan_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionPlan_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionPlan_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanDto>;
        }));
    }

    protected processSubscriptionPlan_Create(response: HttpResponseBase): Observable<SubscriptionPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    subscriptionPlan_GetById(id: string): Observable<SubscriptionPlanDto> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/SubscriptionPlan_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionPlan_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionPlan_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanDto>;
        }));
    }

    protected processSubscriptionPlan_GetById(response: HttpResponseBase): Observable<SubscriptionPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    subscriptionPlan_GetAll(): Observable<SubscriptionPlanDto[]> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/SubscriptionPlan_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionPlan_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionPlan_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanDto[]>;
        }));
    }

    protected processSubscriptionPlan_GetAll(response: HttpResponseBase): Observable<SubscriptionPlanDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscriptionPlanDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    subscriptionPlan_Update(id: string, body: SubscriptionPlanDto | undefined): Observable<SubscriptionPlanDto> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/SubscriptionPlan_Update/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionPlan_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionPlan_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPlanDto>;
        }));
    }

    protected processSubscriptionPlan_Update(response: HttpResponseBase): Observable<SubscriptionPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    subscriptionPlan_Delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/SubscriptionPlan_Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionPlan_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionPlan_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSubscriptionPlan_Delete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    tenant_GetTenantTypes(): Observable<TenantTypeDto[]> {
        let url_ = this.baseUrl + "/api/Tenant/Tenant_GetTenantTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenant_GetTenantTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenant_GetTenantTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantTypeDto[]>;
        }));
    }

    protected processTenant_GetTenantTypes(response: HttpResponseBase): Observable<TenantTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantTypeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenant_RegisterTenant(body: TenantCreateUpdateDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tenant/Tenant_RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenant_RegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenant_RegisterTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTenant_RegisterTenant(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenant_GetTenantById(id: string): Observable<TenantCreateUpdateDto> {
        let url_ = this.baseUrl + "/api/Tenant/Tenant_GetTenantById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenant_GetTenantById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenant_GetTenantById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantCreateUpdateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantCreateUpdateDto>;
        }));
    }

    protected processTenant_GetTenantById(response: HttpResponseBase): Observable<TenantCreateUpdateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantCreateUpdateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenant_GetAllTenants(): Observable<TenantCreateUpdateDto[]> {
        let url_ = this.baseUrl + "/api/Tenant/Tenant_GetAllTenants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenant_GetAllTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenant_GetAllTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantCreateUpdateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantCreateUpdateDto[]>;
        }));
    }

    protected processTenant_GetAllTenants(response: HttpResponseBase): Observable<TenantCreateUpdateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantCreateUpdateDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenant_UpdateTenant(id: string, body: TenantCreateUpdateDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tenant/Tenant_UpdateTenant/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenant_UpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenant_UpdateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTenant_UpdateTenant(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenant_DeleteTenant(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tenant/Tenant_DeleteTenant/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenant_DeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenant_DeleteTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTenant_DeleteTenant(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantApprovalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    tenantApproval_GetPendingTenants(): Observable<TenantApprovalListDto[]> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_GetPendingTenants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_GetPendingTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_GetPendingTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantApprovalListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantApprovalListDto[]>;
        }));
    }

    protected processTenantApproval_GetPendingTenants(response: HttpResponseBase): Observable<TenantApprovalListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantApprovalListDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantApproval_GetAllTenantRequests(): Observable<TenantApprovalListDto[]> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_GetAllTenantRequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_GetAllTenantRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_GetAllTenantRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantApprovalListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantApprovalListDto[]>;
        }));
    }

    protected processTenantApproval_GetAllTenantRequests(response: HttpResponseBase): Observable<TenantApprovalListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantApprovalListDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantApproval_GetTenantDetail(tenantId: string): Observable<TenantApprovalDetailDto> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_GetTenantDetail/{tenantId}";
        if (tenantId === undefined || tenantId === null)
            throw new globalThis.Error("The parameter 'tenantId' must be defined.");
        url_ = url_.replace("{tenantId}", encodeURIComponent("" + tenantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_GetTenantDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_GetTenantDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantApprovalDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantApprovalDetailDto>;
        }));
    }

    protected processTenantApproval_GetTenantDetail(response: HttpResponseBase): Observable<TenantApprovalDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantApprovalDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantApproval_ApproveTenant(body: ApproveTenantDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_ApproveTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_ApproveTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_ApproveTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantApproval_ApproveTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantApproval_RejectTenant(body: RejectTenantDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_RejectTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_RejectTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_RejectTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantApproval_RejectTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantApproval_RequestChange(body: RequestTenantChangeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantApproval/TenantApproval_RequestChange";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantApproval_RequestChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantApproval_RequestChange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantApproval_RequestChange(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class Tenant_bankingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    verify(bankingDetailId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/tenant-banking/{bankingDetailId}/verify";
        if (bankingDetailId === undefined || bankingDetailId === null)
            throw new globalThis.Error("The parameter 'bankingDetailId' must be defined.");
        url_ = url_.replace("{bankingDetailId}", encodeURIComponent("" + bankingDetailId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class Tenant_invoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param status (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    invoiceList(status: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<InvoiceDto[]> {
        let url_ = this.baseUrl + "/api/tenant-invoice/invoice-list?";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto[]>;
        }));
    }

    protected processInvoiceList(response: HttpResponseBase): Observable<InvoiceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    invoiceById(invoiceId: string): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/tenant-invoice/invoice-by-id/{invoiceId}";
        if (invoiceId === undefined || invoiceId === null)
            throw new globalThis.Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processInvoiceById(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    invoiceUnpaid(): Observable<InvoiceDto[]> {
        let url_ = this.baseUrl + "/api/tenant-invoice/invoice-unpaid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceUnpaid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceUnpaid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto[]>;
        }));
    }

    protected processInvoiceUnpaid(response: HttpResponseBase): Observable<InvoiceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    invoiceSummary(): Observable<any> {
        let url_ = this.baseUrl + "/api/tenant-invoice/invoice-summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processInvoiceSummary(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param status (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    invoiceAll(tenantId: string | undefined, status: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/tenant-invoice/invoice-all?";
        if (tenantId === null)
            throw new globalThis.Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processInvoiceAll(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantSettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    tenantSetting_GetById(id: string): Observable<TenantSettingDto> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingDto>;
        }));
    }

    protected processTenantSetting_GetById(response: HttpResponseBase): Observable<TenantSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantSetting_GetCurrentTenantSettings(): Observable<TenantSettingDto> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_GetCurrentTenantSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_GetCurrentTenantSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_GetCurrentTenantSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingDto>;
        }));
    }

    protected processTenantSetting_GetCurrentTenantSettings(response: HttpResponseBase): Observable<TenantSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    tenantSetting_GetAllTenantSettings(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<TenantSettingDto[]> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_GetAllTenantSettings?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_GetAllTenantSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_GetAllTenantSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingDto[]>;
        }));
    }

    protected processTenantSetting_GetAllTenantSettings(response: HttpResponseBase): Observable<TenantSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantSettingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantSetting_CreateTenantSetting(body: TenantSettingDto | undefined): Observable<TenantSettingDto> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_CreateTenantSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_CreateTenantSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_CreateTenantSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingDto>;
        }));
    }

    protected processTenantSetting_CreateTenantSetting(response: HttpResponseBase): Observable<TenantSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantSetting_UpdateTenantSetting(body: TenantSettingDto | undefined): Observable<TenantSettingDto> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_UpdateTenantSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_UpdateTenantSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_UpdateTenantSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingDto>;
        }));
    }

    protected processTenantSetting_UpdateTenantSetting(response: HttpResponseBase): Observable<TenantSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantSetting_DeleteTenantSetting(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TenantSetting/TenantSetting_DeleteTenantSetting/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSetting_DeleteTenantSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSetting_DeleteTenantSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTenantSetting_DeleteTenantSetting(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    uploadContractTemplate(file: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSetting/upload-contract-template";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadContractTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadContractTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadContractTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    removeContractTemplate(): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSetting/remove-contract-template";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveContractTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveContractTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveContractTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantSubscription_Create(body: CreateSubscriptionDto | undefined): Observable<TenantSubscription> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSubscription>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSubscription>;
        }));
    }

    protected processTenantSubscription_Create(response: HttpResponseBase): Observable<TenantSubscription> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSubscription.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantSubscription_GetById(id: string): Observable<TenantSubscription> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSubscription>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSubscription>;
        }));
    }

    protected processTenantSubscription_GetById(response: HttpResponseBase): Observable<TenantSubscription> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSubscription.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantSubscription_GetActive(): Observable<TenantSubscription> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_GetActive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_GetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_GetActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSubscription>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSubscription>;
        }));
    }

    protected processTenantSubscription_GetActive(response: HttpResponseBase): Observable<TenantSubscription> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSubscription.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantSubscription_IsActive(): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_IsActive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_IsActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_IsActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantSubscription_IsActive(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantSubscription_GetEndDate(): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_GetEndDate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_GetEndDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_GetEndDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantSubscription_GetEndDate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantSubscription_Cancel(body: CancelSubscriptionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_Cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_Cancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_Cancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantSubscription_Cancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantSubscription_ApplyCoupon(subscriptionId: string, body: ApplyCouponRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_ApplyCoupon/{subscriptionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new globalThis.Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_ApplyCoupon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_ApplyCoupon(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantSubscription_ApplyCoupon(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param status (optional) 
     * @param searchTerm (optional) 
     * @return OK
     */
    tenantSubscription_GetAll(pageNumber: number | undefined, pageSize: number | undefined, status: SubscriptionStatus | undefined, searchTerm: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_GetAll?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (searchTerm === null)
            throw new globalThis.Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantSubscription_GetAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantSubscription_Suspend(id: string, body: SuspendSubscriptionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_Suspend/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_Suspend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_Suspend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantSubscription_Suspend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantSubscription_Reactivate(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_Reactivate/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_Reactivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_Reactivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantSubscription_Reactivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tenantSubscription_ChangePlan(id: string, body: ChangePlanDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_ChangePlan/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_ChangePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_ChangePlan(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantSubscription_ChangePlan(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    tenantSubscription_ProcessRenewals(): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantSubscription/TenantSubscription_ProcessRenewals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSubscription_ProcessRenewals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSubscription_ProcessRenewals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTenantSubscription_ProcessRenewals(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantTypePermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get permissions by tenant type
     * @return Permissions retrieved successfully
     */
    getPermissionsByTenantType(tenantType: TenantType): Observable<TenantTypePermission[]> {
        let url_ = this.baseUrl + "/api/TenantTypePermission/GetPermissionsByTenantType/{tenantType}";
        if (tenantType === undefined || tenantType === null)
            throw new globalThis.Error("The parameter 'tenantType' must be defined.");
        url_ = url_.replace("{tenantType}", encodeURIComponent("" + tenantType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionsByTenantType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsByTenantType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantTypePermission[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantTypePermission[]>;
        }));
    }

    protected processGetPermissionsByTenantType(response: HttpResponseBase): Observable<TenantTypePermission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantTypePermission.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal server error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assignPermissionToTenantType(body: AssignPermissionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantTypePermission/AssignPermissionToTenantType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignPermissionToTenantType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignPermissionToTenantType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignPermissionToTenantType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    removePermissionFromTenantType(body: RemovePermissionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantTypePermission/RemovePermissionFromTenantType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovePermissionFromTenantType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovePermissionFromTenantType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemovePermissionFromTenantType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    seedDefaultPermissions(): Observable<void> {
        let url_ = this.baseUrl + "/api/TenantTypePermission/SeedDefaultPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeedDefaultPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeedDefaultPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSeedDefaultPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TermsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    terms_GetActive(): Observable<TermsAndConditionsDto> {
        let url_ = this.baseUrl + "/api/Terms/Terms_GetActive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_GetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_GetActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TermsAndConditionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TermsAndConditionsDto>;
        }));
    }

    protected processTerms_GetActive(response: HttpResponseBase): Observable<TermsAndConditionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TermsAndConditionsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    terms_GetAll(): Observable<TermsAndConditionsDto[]> {
        let url_ = this.baseUrl + "/api/Terms/Terms_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TermsAndConditionsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TermsAndConditionsDto[]>;
        }));
    }

    protected processTerms_GetAll(response: HttpResponseBase): Observable<TermsAndConditionsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TermsAndConditionsDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    terms_Create(body: TermsAndConditionsDto | undefined): Observable<TermsAndConditionsDto> {
        let url_ = this.baseUrl + "/api/Terms/Terms_Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TermsAndConditionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TermsAndConditionsDto>;
        }));
    }

    protected processTerms_Create(response: HttpResponseBase): Observable<TermsAndConditionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TermsAndConditionsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    terms_Accept(body: AcceptTermsDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Terms/Terms_Accept";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_Accept(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_Accept(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTerms_Accept(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    terms_HasAcceptedLatest(memberId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Terms/Terms_HasAcceptedLatest/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_HasAcceptedLatest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_HasAcceptedLatest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTerms_HasAcceptedLatest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    terms_GetMemberAcceptance(memberId: string): Observable<TermsAcceptanceDto> {
        let url_ = this.baseUrl + "/api/Terms/Terms_GetMemberAcceptance/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerms_GetMemberAcceptance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerms_GetMemberAcceptance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TermsAcceptanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TermsAcceptanceDto>;
        }));
    }

    protected processTerms_GetMemberAcceptance(response: HttpResponseBase): Observable<TermsAcceptanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TermsAcceptanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TimesheetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    timesheet_CreateTimesheetEntry(body: TimesheetEntryDto | undefined): Observable<TimesheetEntryDto> {
        let url_ = this.baseUrl + "/api/Timesheet/Timesheet_CreateTimesheetEntry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimesheet_CreateTimesheetEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimesheet_CreateTimesheetEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimesheetEntryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimesheetEntryDto>;
        }));
    }

    protected processTimesheet_CreateTimesheetEntry(response: HttpResponseBase): Observable<TimesheetEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimesheetEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    timesheet_GetTimesheetEntryById(id: string): Observable<TimesheetEntryDto> {
        let url_ = this.baseUrl + "/api/Timesheet/Timesheet_GetTimesheetEntryById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimesheet_GetTimesheetEntryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimesheet_GetTimesheetEntryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimesheetEntryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimesheetEntryDto>;
        }));
    }

    protected processTimesheet_GetTimesheetEntryById(response: HttpResponseBase): Observable<TimesheetEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimesheetEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    timesheet_GetMyTimesheetEntries(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<TimesheetEntryDto[]> {
        let url_ = this.baseUrl + "/api/Timesheet/Timesheet_GetMyTimesheetEntries?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimesheet_GetMyTimesheetEntries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimesheet_GetMyTimesheetEntries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimesheetEntryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimesheetEntryDto[]>;
        }));
    }

    protected processTimesheet_GetMyTimesheetEntries(response: HttpResponseBase): Observable<TimesheetEntryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimesheetEntryDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    timesheet_UpdateTimesheetEntry(id: string, body: TimesheetEntryDto | undefined): Observable<TimesheetEntryDto> {
        let url_ = this.baseUrl + "/api/Timesheet/Timesheet_UpdateTimesheetEntry/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimesheet_UpdateTimesheetEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimesheet_UpdateTimesheetEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimesheetEntryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimesheetEntryDto>;
        }));
    }

    protected processTimesheet_UpdateTimesheetEntry(response: HttpResponseBase): Observable<TimesheetEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimesheetEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    timesheet_DeleteTimesheetEntry(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Timesheet/Timesheet_DeleteTimesheetEntry/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimesheet_DeleteTimesheetEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimesheet_DeleteTimesheetEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTimesheet_DeleteTimesheetEntry(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    user_GetById(id: string | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/User/User_GetById?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUser_GetById(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    user_GetAllUsers(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/User/User_GetAllUsers?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_GetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_GetAllUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processUser_GetAllUsers(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    user_UpdateUser(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/User/User_UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_UpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_UpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUser_UpdateUser(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    user_CreateUser(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/User/User_CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_CreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_CreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUser_CreateUser(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UserDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    user_DeleteUser(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/User/User_DeleteUser/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_DeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_DeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUser_DeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    userProfile_GetCurrentUserProfile(): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_GetCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_GetCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_GetCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processUserProfile_GetCurrentUserProfile(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userProfile_UpdateCurrentUserProfile(body: UpdateUserProfileDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_UpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_UpdateCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUserProfile_UpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userProfile_VerifyIdentity(body: CreateVerificationRequestDto | undefined): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_VerifyIdentity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_VerifyIdentity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_VerifyIdentity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processUserProfile_VerifyIdentity(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    userProfile_GetVerificationStatus(): Observable<void> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_GetVerificationStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_GetVerificationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_GetVerificationStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUserProfile_GetVerificationStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    userProfile_GetVerificationHistory(): Observable<VerificationRequestDto[]> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_GetVerificationHistory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_GetVerificationHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_GetVerificationHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto[]>;
        }));
    }

    protected processUserProfile_GetVerificationHistory(response: HttpResponseBase): Observable<VerificationRequestDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationRequestDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    userProfile_QuickIdCheck(): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_QuickIdCheck";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_QuickIdCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_QuickIdCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processUserProfile_QuickIdCheck(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userProfile_CheckIdExists(body: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserProfile/UserProfile_CheckIdExists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile_CheckIdExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile_CheckIdExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUserProfile_CheckIdExists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    userRole_GetAllUserRoles(): Observable<UserRoleDto[]> {
        let url_ = this.baseUrl + "/api/UserRole/UserRole_GetAllUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRole_GetAllUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRole_GetAllUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleDto[]>;
        }));
    }

    protected processUserRole_GetAllUserRoles(response: HttpResponseBase): Observable<UserRoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRoleDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userRole_CreateUserRole(body: UserRoleInputDto | undefined): Observable<UserRoleDto> {
        let url_ = this.baseUrl + "/api/UserRole/UserRole_CreateUserRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRole_CreateUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRole_CreateUserRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleDto>;
        }));
    }

    protected processUserRole_CreateUserRole(response: HttpResponseBase): Observable<UserRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    userRole_DeleteUserRole(userRoleId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserRole/UserRole_DeleteUserRole/{userRoleId}";
        if (userRoleId === undefined || userRoleId === null)
            throw new globalThis.Error("The parameter 'userRoleId' must be defined.");
        url_ = url_.replace("{userRoleId}", encodeURIComponent("" + userRoleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRole_DeleteUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRole_DeleteUserRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUserRole_DeleteUserRole(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VerificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    verification_CreateRequest(body: CreateVerificationRequestDto | undefined): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/Verification/Verification_CreateRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_CreateRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_CreateRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processVerification_CreateRequest(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_GetRequest(id: string): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/Verification/Verification_GetRequest/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_GetRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_GetRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processVerification_GetRequest(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param offset (optional) 
     * @param limit (optional) 
     * @param order (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    verification_GetAllRequests(searchText: string | undefined, offset: number | undefined, limit: number | undefined, order: string | undefined, pageNumber: number | undefined): Observable<VerificationRequestDto[]> {
        let url_ = this.baseUrl + "/api/Verification/Verification_GetAllRequests?";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (order === null)
            throw new globalThis.Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_GetAllRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_GetAllRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto[]>;
        }));
    }

    protected processVerification_GetAllRequests(response: HttpResponseBase): Observable<VerificationRequestDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationRequestDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_ProcessRequest(id: string): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/Verification/Verification_ProcessRequest/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_ProcessRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_ProcessRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processVerification_ProcessRequest(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_GetByMember(memberId: string): Observable<VerificationRequestDto[]> {
        let url_ = this.baseUrl + "/api/Verification/Verification_GetByMember/{memberId}";
        if (memberId === undefined || memberId === null)
            throw new globalThis.Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_GetByMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_GetByMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto[]>;
        }));
    }

    protected processVerification_GetByMember(response: HttpResponseBase): Observable<VerificationRequestDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationRequestDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_GetByClaim(claimId: string): Observable<VerificationRequestDto[]> {
        let url_ = this.baseUrl + "/api/Verification/Verification_GetByClaim/{claimId}";
        if (claimId === undefined || claimId === null)
            throw new globalThis.Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_GetByClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_GetByClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto[]>;
        }));
    }

    protected processVerification_GetByClaim(response: HttpResponseBase): Observable<VerificationRequestDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationRequestDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_CheckPersonVerified(idNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Verification/Verification_CheckPersonVerified/{idNumber}";
        if (idNumber === undefined || idNumber === null)
            throw new globalThis.Error("The parameter 'idNumber' must be defined.");
        url_ = url_.replace("{idNumber}", encodeURIComponent("" + idNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_CheckPersonVerified(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_CheckPersonVerified(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processVerification_CheckPersonVerified(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    verification_CheckPersonAlive(idNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Verification/Verification_CheckPersonAlive/{idNumber}";
        if (idNumber === undefined || idNumber === null)
            throw new globalThis.Error("The parameter 'idNumber' must be defined.");
        url_ = url_.replace("{idNumber}", encodeURIComponent("" + idNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_CheckPersonAlive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_CheckPersonAlive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processVerification_CheckPersonAlive(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    verification_QuickIdentityCheck(body: CreateVerificationRequestDto | undefined): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/Verification/Verification_QuickIdentityCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_QuickIdentityCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_QuickIdentityCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processVerification_QuickIdentityCheck(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    verification_QuickLifeCheck(body: CreateVerificationRequestDto | undefined): Observable<VerificationRequestDto> {
        let url_ = this.baseUrl + "/api/Verification/Verification_QuickLifeCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerification_QuickLifeCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerification_QuickLifeCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerificationRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerificationRequestDto>;
        }));
    }

    protected processVerification_QuickLifeCheck(response: HttpResponseBase): Observable<VerificationRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebhookServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    webhook_PayFast(): Observable<void> {
        let url_ = this.baseUrl + "/api/Webhook/Webhook_PayFast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWebhook_PayFast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWebhook_PayFast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWebhook_PayFast(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    webhook_PayFastTest(body: { [key: string]: string; } | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Webhook/Webhook_PayFastTest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWebhook_PayFastTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWebhook_PayFastTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWebhook_PayFastTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    webhook_Health(): Observable<void> {
        let url_ = this.baseUrl + "/api/Webhook/Webhook_Health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWebhook_Health(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWebhook_Health(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWebhook_Health(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AcceptTermsDto implements IAcceptTermsDto {
    memberId!: string;
    termsAndConditionsId!: string;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;

    constructor(data?: IAcceptTermsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.termsAndConditionsId = _data["termsAndConditionsId"];
            this.ipAddress = _data["ipAddress"];
            this.userAgent = _data["userAgent"];
        }
    }

    static fromJS(data: any): AcceptTermsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptTermsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["termsAndConditionsId"] = this.termsAndConditionsId;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        return data;
    }
}

export interface IAcceptTermsDto {
    memberId: string;
    termsAndConditionsId: string;
    ipAddress: string | undefined;
    userAgent: string | undefined;
}

export class AddressDto implements IAddressDto {
    addressLine1!: string;
    addressLine2!: string | undefined;
    city!: string;
    state!: string;
    postalCode!: string;
    country!: string;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["country"] = this.country;
        return data;
    }
}

export interface IAddressDto {
    addressLine1: string;
    addressLine2: string | undefined;
    city: string;
    state: string;
    postalCode: string;
    country: string;
}

export class ApplyCouponRequest implements IApplyCouponRequest {
    couponCode!: string | undefined;

    constructor(data?: IApplyCouponRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.couponCode = _data["couponCode"];
        }
    }

    static fromJS(data: any): ApplyCouponRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyCouponRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["couponCode"] = this.couponCode;
        return data;
    }
}

export interface IApplyCouponRequest {
    couponCode: string | undefined;
}

export class ApproveEnrollmentDto implements IApproveEnrollmentDto {
    notes!: string | undefined;

    constructor(data?: IApproveEnrollmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ApproveEnrollmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveEnrollmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notes"] = this.notes;
        return data;
    }
}

export interface IApproveEnrollmentDto {
    notes: string | undefined;
}

export class ApproveMemberRequest implements IApproveMemberRequest {
    memberId!: string;
    approvalNotes!: string | undefined;

    constructor(data?: IApproveMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.approvalNotes = _data["approvalNotes"];
        }
    }

    static fromJS(data: any): ApproveMemberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["approvalNotes"] = this.approvalNotes;
        return data;
    }
}

export interface IApproveMemberRequest {
    memberId: string;
    approvalNotes: string | undefined;
}

export class ApproveTenantDto implements IApproveTenantDto {
    tenantId!: string;

    constructor(data?: IApproveTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): ApproveTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IApproveTenantDto {
    tenantId: string;
}

export class AssetCheckoutDto implements IAssetCheckoutDto {
    id!: string;
    assetId!: string;
    assetName!: string | undefined;
    assetIdentificationNumber!: string | undefined;
    checkedOutByUserId!: string;
    checkedOutByName!: string | undefined;
    checkedOutByRole!: string | undefined;
    checkoutDate!: DateTime;
    expectedReturnDate!: DateTime | undefined;
    purpose!: string | undefined;
    destination!: string | undefined;
    startingOdometer!: number | undefined;
    endingOdometer!: number | undefined;
    fuelLevelCheckout!: number | undefined;
    fuelLevelCheckin!: number | undefined;
    status!: CheckoutStatus;
    readonly statusName!: string | undefined;
    checkinDate!: DateTime | undefined;
    checkedInByUserId!: string | undefined;
    checkedInByName!: string | undefined;
    checkoutNotes!: string | undefined;
    checkinNotes!: string | undefined;
    returnedInGoodCondition!: boolean | undefined;
    damageReported!: string | undefined;
    readonly isOverdue!: boolean;
    createdAt!: DateTime;

    constructor(data?: IAssetCheckoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetId = _data["assetId"];
            this.assetName = _data["assetName"];
            this.assetIdentificationNumber = _data["assetIdentificationNumber"];
            this.checkedOutByUserId = _data["checkedOutByUserId"];
            this.checkedOutByName = _data["checkedOutByName"];
            this.checkedOutByRole = _data["checkedOutByRole"];
            this.checkoutDate = _data["checkoutDate"] ? DateTime.fromISO(_data["checkoutDate"].toString()) : undefined as any;
            this.expectedReturnDate = _data["expectedReturnDate"] ? DateTime.fromISO(_data["expectedReturnDate"].toString()) : undefined as any;
            this.purpose = _data["purpose"];
            this.destination = _data["destination"];
            this.startingOdometer = _data["startingOdometer"];
            this.endingOdometer = _data["endingOdometer"];
            this.fuelLevelCheckout = _data["fuelLevelCheckout"];
            this.fuelLevelCheckin = _data["fuelLevelCheckin"];
            this.status = _data["status"];
            (this as any).statusName = _data["statusName"];
            this.checkinDate = _data["checkinDate"] ? DateTime.fromISO(_data["checkinDate"].toString()) : undefined as any;
            this.checkedInByUserId = _data["checkedInByUserId"];
            this.checkedInByName = _data["checkedInByName"];
            this.checkoutNotes = _data["checkoutNotes"];
            this.checkinNotes = _data["checkinNotes"];
            this.returnedInGoodCondition = _data["returnedInGoodCondition"];
            this.damageReported = _data["damageReported"];
            (this as any).isOverdue = _data["isOverdue"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): AssetCheckoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCheckoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetId"] = this.assetId;
        data["assetName"] = this.assetName;
        data["assetIdentificationNumber"] = this.assetIdentificationNumber;
        data["checkedOutByUserId"] = this.checkedOutByUserId;
        data["checkedOutByName"] = this.checkedOutByName;
        data["checkedOutByRole"] = this.checkedOutByRole;
        data["checkoutDate"] = this.checkoutDate ? this.checkoutDate.toString() : undefined as any;
        data["expectedReturnDate"] = this.expectedReturnDate ? this.expectedReturnDate.toString() : undefined as any;
        data["purpose"] = this.purpose;
        data["destination"] = this.destination;
        data["startingOdometer"] = this.startingOdometer;
        data["endingOdometer"] = this.endingOdometer;
        data["fuelLevelCheckout"] = this.fuelLevelCheckout;
        data["fuelLevelCheckin"] = this.fuelLevelCheckin;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["checkinDate"] = this.checkinDate ? this.checkinDate.toString() : undefined as any;
        data["checkedInByUserId"] = this.checkedInByUserId;
        data["checkedInByName"] = this.checkedInByName;
        data["checkoutNotes"] = this.checkoutNotes;
        data["checkinNotes"] = this.checkinNotes;
        data["returnedInGoodCondition"] = this.returnedInGoodCondition;
        data["damageReported"] = this.damageReported;
        data["isOverdue"] = this.isOverdue;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        return data;
    }
}

export interface IAssetCheckoutDto {
    id: string;
    assetId: string;
    assetName: string | undefined;
    assetIdentificationNumber: string | undefined;
    checkedOutByUserId: string;
    checkedOutByName: string | undefined;
    checkedOutByRole: string | undefined;
    checkoutDate: DateTime;
    expectedReturnDate: DateTime | undefined;
    purpose: string | undefined;
    destination: string | undefined;
    startingOdometer: number | undefined;
    endingOdometer: number | undefined;
    fuelLevelCheckout: number | undefined;
    fuelLevelCheckin: number | undefined;
    status: CheckoutStatus;
    statusName: string | undefined;
    checkinDate: DateTime | undefined;
    checkedInByUserId: string | undefined;
    checkedInByName: string | undefined;
    checkoutNotes: string | undefined;
    checkinNotes: string | undefined;
    returnedInGoodCondition: boolean | undefined;
    damageReported: string | undefined;
    isOverdue: boolean;
    createdAt: DateTime;
}

export class AssetDto implements IAssetDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    assetType!: AssetType;
    readonly assetTypeName!: string | undefined;
    status!: AssetStatus;
    readonly statusName!: string | undefined;
    identificationNumber!: string | undefined;
    make!: string | undefined;
    model!: string | undefined;
    year!: number | undefined;
    quantity!: number;
    currentLocation!: string | undefined;
    requiresInspection!: boolean;
    inspectionCheckpoints!: string[] | undefined;
    lastMaintenanceDate!: DateTime | undefined;
    nextMaintenanceDate!: DateTime | undefined;
    purchaseDate!: DateTime | undefined;
    purchaseCost!: number | undefined;
    conditionNotes!: string | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime | undefined;

    constructor(data?: IAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.assetType = _data["assetType"];
            (this as any).assetTypeName = _data["assetTypeName"];
            this.status = _data["status"];
            (this as any).statusName = _data["statusName"];
            this.identificationNumber = _data["identificationNumber"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.year = _data["year"];
            this.quantity = _data["quantity"];
            this.currentLocation = _data["currentLocation"];
            this.requiresInspection = _data["requiresInspection"];
            if (Array.isArray(_data["inspectionCheckpoints"])) {
                this.inspectionCheckpoints = [] as any;
                for (let item of _data["inspectionCheckpoints"])
                    this.inspectionCheckpoints!.push(item);
            }
            this.lastMaintenanceDate = _data["lastMaintenanceDate"] ? DateTime.fromISO(_data["lastMaintenanceDate"].toString()) : undefined as any;
            this.nextMaintenanceDate = _data["nextMaintenanceDate"] ? DateTime.fromISO(_data["nextMaintenanceDate"].toString()) : undefined as any;
            this.purchaseDate = _data["purchaseDate"] ? DateTime.fromISO(_data["purchaseDate"].toString()) : undefined as any;
            this.purchaseCost = _data["purchaseCost"];
            this.conditionNotes = _data["conditionNotes"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): AssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["assetType"] = this.assetType;
        data["assetTypeName"] = this.assetTypeName;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["identificationNumber"] = this.identificationNumber;
        data["make"] = this.make;
        data["model"] = this.model;
        data["year"] = this.year;
        data["quantity"] = this.quantity;
        data["currentLocation"] = this.currentLocation;
        data["requiresInspection"] = this.requiresInspection;
        if (Array.isArray(this.inspectionCheckpoints)) {
            data["inspectionCheckpoints"] = [];
            for (let item of this.inspectionCheckpoints)
                data["inspectionCheckpoints"].push(item);
        }
        data["lastMaintenanceDate"] = this.lastMaintenanceDate ? this.lastMaintenanceDate.toString() : undefined as any;
        data["nextMaintenanceDate"] = this.nextMaintenanceDate ? this.nextMaintenanceDate.toString() : undefined as any;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toString() : undefined as any;
        data["purchaseCost"] = this.purchaseCost;
        data["conditionNotes"] = this.conditionNotes;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IAssetDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    assetType: AssetType;
    assetTypeName: string | undefined;
    status: AssetStatus;
    statusName: string | undefined;
    identificationNumber: string | undefined;
    make: string | undefined;
    model: string | undefined;
    year: number | undefined;
    quantity: number;
    currentLocation: string | undefined;
    requiresInspection: boolean;
    inspectionCheckpoints: string[] | undefined;
    lastMaintenanceDate: DateTime | undefined;
    nextMaintenanceDate: DateTime | undefined;
    purchaseDate: DateTime | undefined;
    purchaseCost: number | undefined;
    conditionNotes: string | undefined;
    createdAt: DateTime;
    updatedAt: DateTime | undefined;
}

export class AssetInspectionLogDto implements IAssetInspectionLogDto {
    id!: string;
    assetId!: string;
    assetName!: string | undefined;
    checkoutId!: string | undefined;
    inspectionType!: InspectionType;
    readonly inspectionTypeName!: string | undefined;
    inspectionDate!: DateTime;
    inspectedByUserId!: string;
    inspectedByName!: string | undefined;
    checkpoints!: InspectionCheckpoint[] | undefined;
    overallResult!: InspectionResult;
    readonly overallResultName!: string | undefined;
    notes!: string | undefined;
    attachments!: string[] | undefined;
    issuesFound!: boolean;
    issueDescription!: string | undefined;
    inspectorSignature!: string | undefined;
    createdAt!: DateTime;

    constructor(data?: IAssetInspectionLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetId = _data["assetId"];
            this.assetName = _data["assetName"];
            this.checkoutId = _data["checkoutId"];
            this.inspectionType = _data["inspectionType"];
            (this as any).inspectionTypeName = _data["inspectionTypeName"];
            this.inspectionDate = _data["inspectionDate"] ? DateTime.fromISO(_data["inspectionDate"].toString()) : undefined as any;
            this.inspectedByUserId = _data["inspectedByUserId"];
            this.inspectedByName = _data["inspectedByName"];
            if (Array.isArray(_data["checkpoints"])) {
                this.checkpoints = [] as any;
                for (let item of _data["checkpoints"])
                    this.checkpoints!.push(InspectionCheckpoint.fromJS(item));
            }
            this.overallResult = _data["overallResult"];
            (this as any).overallResultName = _data["overallResultName"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(item);
            }
            this.issuesFound = _data["issuesFound"];
            this.issueDescription = _data["issueDescription"];
            this.inspectorSignature = _data["inspectorSignature"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): AssetInspectionLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetInspectionLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetId"] = this.assetId;
        data["assetName"] = this.assetName;
        data["checkoutId"] = this.checkoutId;
        data["inspectionType"] = this.inspectionType;
        data["inspectionTypeName"] = this.inspectionTypeName;
        data["inspectionDate"] = this.inspectionDate ? this.inspectionDate.toString() : undefined as any;
        data["inspectedByUserId"] = this.inspectedByUserId;
        data["inspectedByName"] = this.inspectedByName;
        if (Array.isArray(this.checkpoints)) {
            data["checkpoints"] = [];
            for (let item of this.checkpoints)
                data["checkpoints"].push(item ? item.toJSON() : undefined as any);
        }
        data["overallResult"] = this.overallResult;
        data["overallResultName"] = this.overallResultName;
        data["notes"] = this.notes;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item);
        }
        data["issuesFound"] = this.issuesFound;
        data["issueDescription"] = this.issueDescription;
        data["inspectorSignature"] = this.inspectorSignature;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        return data;
    }
}

export interface IAssetInspectionLogDto {
    id: string;
    assetId: string;
    assetName: string | undefined;
    checkoutId: string | undefined;
    inspectionType: InspectionType;
    inspectionTypeName: string | undefined;
    inspectionDate: DateTime;
    inspectedByUserId: string;
    inspectedByName: string | undefined;
    checkpoints: InspectionCheckpoint[] | undefined;
    overallResult: InspectionResult;
    overallResultName: string | undefined;
    notes: string | undefined;
    attachments: string[] | undefined;
    issuesFound: boolean;
    issueDescription: string | undefined;
    inspectorSignature: string | undefined;
    createdAt: DateTime;
}

export class AssetStatsDto implements IAssetStatsDto {
    totalAssets!: number;
    availableAssets!: number;
    checkedOutAssets!: number;
    underMaintenanceAssets!: number;
    overdueCheckouts!: number;
    assetsByType!: { [key: string]: number; } | undefined;
    recentCheckouts!: AssetCheckoutDto[] | undefined;
    assetsNeedingMaintenance!: AssetDto[] | undefined;

    constructor(data?: IAssetStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalAssets = _data["totalAssets"];
            this.availableAssets = _data["availableAssets"];
            this.checkedOutAssets = _data["checkedOutAssets"];
            this.underMaintenanceAssets = _data["underMaintenanceAssets"];
            this.overdueCheckouts = _data["overdueCheckouts"];
            if (_data["assetsByType"]) {
                this.assetsByType = {} as any;
                for (let key in _data["assetsByType"]) {
                    if (_data["assetsByType"].hasOwnProperty(key))
                        (this.assetsByType as any)![key] = _data["assetsByType"][key];
                }
            }
            if (Array.isArray(_data["recentCheckouts"])) {
                this.recentCheckouts = [] as any;
                for (let item of _data["recentCheckouts"])
                    this.recentCheckouts!.push(AssetCheckoutDto.fromJS(item));
            }
            if (Array.isArray(_data["assetsNeedingMaintenance"])) {
                this.assetsNeedingMaintenance = [] as any;
                for (let item of _data["assetsNeedingMaintenance"])
                    this.assetsNeedingMaintenance!.push(AssetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssetStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalAssets"] = this.totalAssets;
        data["availableAssets"] = this.availableAssets;
        data["checkedOutAssets"] = this.checkedOutAssets;
        data["underMaintenanceAssets"] = this.underMaintenanceAssets;
        data["overdueCheckouts"] = this.overdueCheckouts;
        if (this.assetsByType) {
            data["assetsByType"] = {};
            for (let key in this.assetsByType) {
                if (this.assetsByType.hasOwnProperty(key))
                    (data["assetsByType"] as any)[key] = (this.assetsByType as any)[key];
            }
        }
        if (Array.isArray(this.recentCheckouts)) {
            data["recentCheckouts"] = [];
            for (let item of this.recentCheckouts)
                data["recentCheckouts"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.assetsNeedingMaintenance)) {
            data["assetsNeedingMaintenance"] = [];
            for (let item of this.assetsNeedingMaintenance)
                data["assetsNeedingMaintenance"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IAssetStatsDto {
    totalAssets: number;
    availableAssets: number;
    checkedOutAssets: number;
    underMaintenanceAssets: number;
    overdueCheckouts: number;
    assetsByType: { [key: string]: number; } | undefined;
    recentCheckouts: AssetCheckoutDto[] | undefined;
    assetsNeedingMaintenance: AssetDto[] | undefined;
}

export enum AssetStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum AssetType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class AssignPermissionDto implements IAssignPermissionDto {
    tenantType!: TenantType;
    permissionName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IAssignPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantType = _data["tenantType"];
            this.permissionName = _data["permissionName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AssignPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssignPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantType"] = this.tenantType;
        data["permissionName"] = this.permissionName;
        data["description"] = this.description;
        return data;
    }
}

export interface IAssignPermissionDto {
    tenantType: TenantType;
    permissionName: string | undefined;
    description: string | undefined;
}

export class AuthResult implements IAuthResult {
    succeeded!: boolean;
    message!: string | undefined;
    token!: string | undefined;
    refreshToken!: string | undefined;
    expiresAt!: DateTime | undefined;
    mustChangePassword!: boolean;
    tenantId!: string | undefined;

    constructor(data?: IAuthResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            this.expiresAt = _data["expiresAt"] ? DateTime.fromISO(_data["expiresAt"].toString()) : undefined as any;
            this.mustChangePassword = _data["mustChangePassword"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AuthResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toString() : undefined as any;
        data["mustChangePassword"] = this.mustChangePassword;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IAuthResult {
    succeeded: boolean;
    message: string | undefined;
    token: string | undefined;
    refreshToken: string | undefined;
    expiresAt: DateTime | undefined;
    mustChangePassword: boolean;
    tenantId: string | undefined;
}

export class Beneficiary implements IBeneficiary {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    name!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    identificationNumber!: string | undefined;
    relationship!: string | undefined;
    benefitPercentage!: number | undefined;
    memberId!: string;
    member!: Member;
    tenantId!: string;
    tenant!: Tenant;
    isVerified!: boolean;
    verifiedAt!: DateTime | undefined;
    claims!: Claim[] | undefined;

    constructor(data?: IBeneficiary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.identificationNumber = _data["identificationNumber"];
            this.relationship = _data["relationship"];
            this.benefitPercentage = _data["benefitPercentage"];
            this.memberId = _data["memberId"];
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : undefined as any;
            this.tenantId = _data["tenantId"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : undefined as any;
            this.isVerified = _data["isVerified"];
            this.verifiedAt = _data["verifiedAt"] ? DateTime.fromISO(_data["verifiedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Beneficiary {
        data = typeof data === 'object' ? data : {};
        let result = new Beneficiary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["identificationNumber"] = this.identificationNumber;
        data["relationship"] = this.relationship;
        data["benefitPercentage"] = this.benefitPercentage;
        data["memberId"] = this.memberId;
        data["member"] = this.member ? this.member.toJSON() : undefined as any;
        data["tenantId"] = this.tenantId;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : undefined as any;
        data["isVerified"] = this.isVerified;
        data["verifiedAt"] = this.verifiedAt ? this.verifiedAt.toString() : undefined as any;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IBeneficiary {
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    name: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    identificationNumber: string | undefined;
    relationship: string | undefined;
    benefitPercentage: number | undefined;
    memberId: string;
    member: Member;
    tenantId: string;
    tenant: Tenant;
    isVerified: boolean;
    verifiedAt: DateTime | undefined;
    claims: Claim[] | undefined;
}

export class BeneficiaryDto implements IBeneficiaryDto {
    id!: string;
    memberId!: string;
    name!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    identificationNumber!: string | undefined;
    relationship!: string | undefined;
    benefitPercentage!: number | undefined;

    constructor(data?: IBeneficiaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.identificationNumber = _data["identificationNumber"];
            this.relationship = _data["relationship"];
            this.benefitPercentage = _data["benefitPercentage"];
        }
    }

    static fromJS(data: any): BeneficiaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["identificationNumber"] = this.identificationNumber;
        data["relationship"] = this.relationship;
        data["benefitPercentage"] = this.benefitPercentage;
        return data;
    }
}

export interface IBeneficiaryDto {
    id: string;
    memberId: string;
    name: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    identificationNumber: string | undefined;
    relationship: string | undefined;
    benefitPercentage: number | undefined;
}

export class BeneficiaryInfoDto implements IBeneficiaryInfoDto {
    id!: string;
    age!: number;
    dateOfBirth!: DateTime;
    firstName!: string | undefined;
    lastName!: string | undefined;

    constructor(data?: IBeneficiaryInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.age = _data["age"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): BeneficiaryInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiaryInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["age"] = this.age;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IBeneficiaryInfoDto {
    id: string;
    age: number;
    dateOfBirth: DateTime;
    firstName: string | undefined;
    lastName: string | undefined;
}

export class BeneficiarySummary implements IBeneficiarySummary {
    id!: string;
    name!: string | undefined;
    relationship!: string | undefined;
    allocationPercentage!: number | undefined;

    constructor(data?: IBeneficiarySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.relationship = _data["relationship"];
            this.allocationPercentage = _data["allocationPercentage"];
        }
    }

    static fromJS(data: any): BeneficiarySummary {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiarySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["relationship"] = this.relationship;
        data["allocationPercentage"] = this.allocationPercentage;
        return data;
    }
}

export interface IBeneficiarySummary {
    id: string;
    name: string | undefined;
    relationship: string | undefined;
    allocationPercentage: number | undefined;
}

export enum BillingCycle {
    _0 = 0,
    _1 = 1,
}

export class BookingConfigDto implements IBookingConfigDto {
    enableBooking!: boolean;
    bookingLeadTime!: number;
    maxBookingDuration!: number;
    workingHours!: { [key: string]: WorkingHoursDto; } | undefined;
    services!: BookingServiceDto[] | undefined;
    enableCalendarReminders!: boolean;
    calendarProvider!: string | undefined;
    enableEmailNotifications!: boolean;
    notificationEmail!: string | undefined;
    sendCustomerConfirmation!: boolean;
    sendAdminNotification!: boolean;

    constructor(data?: IBookingConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableBooking = _data["enableBooking"];
            this.bookingLeadTime = _data["bookingLeadTime"];
            this.maxBookingDuration = _data["maxBookingDuration"];
            if (_data["workingHours"]) {
                this.workingHours = {} as any;
                for (let key in _data["workingHours"]) {
                    if (_data["workingHours"].hasOwnProperty(key))
                        (this.workingHours as any)![key] = _data["workingHours"][key] ? WorkingHoursDto.fromJS(_data["workingHours"][key]) : new WorkingHoursDto();
                }
            }
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(BookingServiceDto.fromJS(item));
            }
            this.enableCalendarReminders = _data["enableCalendarReminders"];
            this.calendarProvider = _data["calendarProvider"];
            this.enableEmailNotifications = _data["enableEmailNotifications"];
            this.notificationEmail = _data["notificationEmail"];
            this.sendCustomerConfirmation = _data["sendCustomerConfirmation"];
            this.sendAdminNotification = _data["sendAdminNotification"];
        }
    }

    static fromJS(data: any): BookingConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookingConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableBooking"] = this.enableBooking;
        data["bookingLeadTime"] = this.bookingLeadTime;
        data["maxBookingDuration"] = this.maxBookingDuration;
        if (this.workingHours) {
            data["workingHours"] = {};
            for (let key in this.workingHours) {
                if (this.workingHours.hasOwnProperty(key))
                    (data["workingHours"] as any)[key] = this.workingHours[key] ? this.workingHours[key].toJSON() : undefined as any;
            }
        }
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item ? item.toJSON() : undefined as any);
        }
        data["enableCalendarReminders"] = this.enableCalendarReminders;
        data["calendarProvider"] = this.calendarProvider;
        data["enableEmailNotifications"] = this.enableEmailNotifications;
        data["notificationEmail"] = this.notificationEmail;
        data["sendCustomerConfirmation"] = this.sendCustomerConfirmation;
        data["sendAdminNotification"] = this.sendAdminNotification;
        return data;
    }
}

export interface IBookingConfigDto {
    enableBooking: boolean;
    bookingLeadTime: number;
    maxBookingDuration: number;
    workingHours: { [key: string]: WorkingHoursDto; } | undefined;
    services: BookingServiceDto[] | undefined;
    enableCalendarReminders: boolean;
    calendarProvider: string | undefined;
    enableEmailNotifications: boolean;
    notificationEmail: string | undefined;
    sendCustomerConfirmation: boolean;
    sendAdminNotification: boolean;
}

export class BookingDto implements IBookingDto {
    id!: string;
    customerName!: string | undefined;
    customerEmail!: string | undefined;
    customerPhone!: string | undefined;
    customerNotes!: string | undefined;
    bookingDate!: DateTime;
    timeSlot!: string | undefined;
    services!: BookingServiceDto[] | undefined;
    status!: string | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime | undefined;

    constructor(data?: IBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerName = _data["customerName"];
            this.customerEmail = _data["customerEmail"];
            this.customerPhone = _data["customerPhone"];
            this.customerNotes = _data["customerNotes"];
            this.bookingDate = _data["bookingDate"] ? DateTime.fromISO(_data["bookingDate"].toString()) : undefined as any;
            this.timeSlot = _data["timeSlot"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(BookingServiceDto.fromJS(item));
            }
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): BookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerName"] = this.customerName;
        data["customerEmail"] = this.customerEmail;
        data["customerPhone"] = this.customerPhone;
        data["customerNotes"] = this.customerNotes;
        data["bookingDate"] = this.bookingDate ? this.bookingDate.toString() : undefined as any;
        data["timeSlot"] = this.timeSlot;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item ? item.toJSON() : undefined as any);
        }
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IBookingDto {
    id: string;
    customerName: string | undefined;
    customerEmail: string | undefined;
    customerPhone: string | undefined;
    customerNotes: string | undefined;
    bookingDate: DateTime;
    timeSlot: string | undefined;
    services: BookingServiceDto[] | undefined;
    status: string | undefined;
    createdAt: DateTime;
    updatedAt: DateTime | undefined;
}

export class BookingNotificationConfigDto implements IBookingNotificationConfigDto {
    sendCustomerConfirmation!: boolean;
    sendAdminNotification!: boolean;
    notificationEmail!: string | undefined;

    constructor(data?: IBookingNotificationConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sendCustomerConfirmation = _data["sendCustomerConfirmation"];
            this.sendAdminNotification = _data["sendAdminNotification"];
            this.notificationEmail = _data["notificationEmail"];
        }
    }

    static fromJS(data: any): BookingNotificationConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookingNotificationConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sendCustomerConfirmation"] = this.sendCustomerConfirmation;
        data["sendAdminNotification"] = this.sendAdminNotification;
        data["notificationEmail"] = this.notificationEmail;
        return data;
    }
}

export interface IBookingNotificationConfigDto {
    sendCustomerConfirmation: boolean;
    sendAdminNotification: boolean;
    notificationEmail: string | undefined;
}

export class BookingNotificationResponseDto implements IBookingNotificationResponseDto {
    success!: boolean;
    customerEmailSent!: boolean;
    adminEmailSent!: boolean;
    message!: string | undefined;

    constructor(data?: IBookingNotificationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.customerEmailSent = _data["customerEmailSent"];
            this.adminEmailSent = _data["adminEmailSent"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): BookingNotificationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookingNotificationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["customerEmailSent"] = this.customerEmailSent;
        data["adminEmailSent"] = this.adminEmailSent;
        data["message"] = this.message;
        return data;
    }
}

export interface IBookingNotificationResponseDto {
    success: boolean;
    customerEmailSent: boolean;
    adminEmailSent: boolean;
    message: string | undefined;
}

export class BookingServiceDto implements IBookingServiceDto {
    id!: string | undefined;
    name!: string | undefined;
    duration!: number;
    price!: number;

    constructor(data?: IBookingServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.duration = _data["duration"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): BookingServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookingServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["duration"] = this.duration;
        data["price"] = this.price;
        return data;
    }
}

export interface IBookingServiceDto {
    id: string | undefined;
    name: string | undefined;
    duration: number;
    price: number;
}

export class CalculatePremiumRequestDto implements ICalculatePremiumRequestDto {
    coverAmount!: number;
    dependents!: DependentInfoDto[] | undefined;
    beneficiaries!: BeneficiaryInfoDto[] | undefined;

    constructor(data?: ICalculatePremiumRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coverAmount = _data["coverAmount"];
            if (Array.isArray(_data["dependents"])) {
                this.dependents = [] as any;
                for (let item of _data["dependents"])
                    this.dependents!.push(DependentInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["beneficiaries"])) {
                this.beneficiaries = [] as any;
                for (let item of _data["beneficiaries"])
                    this.beneficiaries!.push(BeneficiaryInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CalculatePremiumRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalculatePremiumRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coverAmount"] = this.coverAmount;
        if (Array.isArray(this.dependents)) {
            data["dependents"] = [];
            for (let item of this.dependents)
                data["dependents"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.beneficiaries)) {
            data["beneficiaries"] = [];
            for (let item of this.beneficiaries)
                data["beneficiaries"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICalculatePremiumRequestDto {
    coverAmount: number;
    dependents: DependentInfoDto[] | undefined;
    beneficiaries: BeneficiaryInfoDto[] | undefined;
}

export class CancelSubscriptionDto implements ICancelSubscriptionDto {
    subscriptionId!: string;
    tenantId!: string;
    reason!: string | undefined;
    cancelImmediately!: boolean;

    constructor(data?: ICancelSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.tenantId = _data["tenantId"];
            this.reason = _data["reason"];
            this.cancelImmediately = _data["cancelImmediately"];
        }
    }

    static fromJS(data: any): CancelSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["tenantId"] = this.tenantId;
        data["reason"] = this.reason;
        data["cancelImmediately"] = this.cancelImmediately;
        return data;
    }
}

export interface ICancelSubscriptionDto {
    subscriptionId: string;
    tenantId: string;
    reason: string | undefined;
    cancelImmediately: boolean;
}

export class CategoryDto implements ICategoryDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    imageUrl!: string | undefined;
    parentCategoryId!: string | undefined;
    parentCategoryName!: string | undefined;
    displayOrder!: number;
    isActive!: boolean;
    metaTitle!: string | undefined;
    metaDescription!: string | undefined;
    productCount!: number;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.imageUrl = _data["imageUrl"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategoryName = _data["parentCategoryName"];
            this.displayOrder = _data["displayOrder"];
            this.isActive = _data["isActive"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.productCount = _data["productCount"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategoryName"] = this.parentCategoryName;
        data["displayOrder"] = this.displayOrder;
        data["isActive"] = this.isActive;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["productCount"] = this.productCount;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface ICategoryDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    imageUrl: string | undefined;
    parentCategoryId: string | undefined;
    parentCategoryName: string | undefined;
    displayOrder: number;
    isActive: boolean;
    metaTitle: string | undefined;
    metaDescription: string | undefined;
    productCount: number;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    currentPassword!: string;
    newPassword!: string;
    confirmPassword!: string;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IChangePasswordRequest {
    currentPassword: string;
    newPassword: string;
    confirmPassword: string;
}

export class ChangePlanDto implements IChangePlanDto {
    subscriptionId!: string;
    tenantId!: string;
    newPlanId!: string;
    applyImmediately!: boolean;
    effectiveImmediately!: boolean;

    constructor(data?: IChangePlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.tenantId = _data["tenantId"];
            this.newPlanId = _data["newPlanId"];
            this.applyImmediately = _data["applyImmediately"];
            this.effectiveImmediately = _data["effectiveImmediately"];
        }
    }

    static fromJS(data: any): ChangePlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["tenantId"] = this.tenantId;
        data["newPlanId"] = this.newPlanId;
        data["applyImmediately"] = this.applyImmediately;
        data["effectiveImmediately"] = this.effectiveImmediately;
        return data;
    }
}

export interface IChangePlanDto {
    subscriptionId: string;
    tenantId: string;
    newPlanId: string;
    applyImmediately: boolean;
    effectiveImmediately: boolean;
}

export class CheckIdNumberDto implements ICheckIdNumberDto {
    idNumber!: string;

    constructor(data?: ICheckIdNumberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
        }
    }

    static fromJS(data: any): CheckIdNumberDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckIdNumberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        return data;
    }
}

export interface ICheckIdNumberDto {
    idNumber: string;
}

export class CheckIdNumberResponseDto implements ICheckIdNumberResponseDto {
    exists!: boolean;
    isMainMember!: boolean;
    hasUserAccount!: boolean;
    memberId!: string | undefined;
    memberName!: string | undefined;
    contactEmail!: string | undefined;
    contactPhone!: string | undefined;
    message!: string | undefined;

    constructor(data?: ICheckIdNumberResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exists = _data["exists"];
            this.isMainMember = _data["isMainMember"];
            this.hasUserAccount = _data["hasUserAccount"];
            this.memberId = _data["memberId"];
            this.memberName = _data["memberName"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CheckIdNumberResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckIdNumberResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exists"] = this.exists;
        data["isMainMember"] = this.isMainMember;
        data["hasUserAccount"] = this.hasUserAccount;
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["message"] = this.message;
        return data;
    }
}

export interface ICheckIdNumberResponseDto {
    exists: boolean;
    isMainMember: boolean;
    hasUserAccount: boolean;
    memberId: string | undefined;
    memberName: string | undefined;
    contactEmail: string | undefined;
    contactPhone: string | undefined;
    message: string | undefined;
}

export class CheckinAssetDto implements ICheckinAssetDto {
    checkoutId!: string;
    endingOdometer!: number | undefined;
    fuelLevelCheckin!: number | undefined;
    returnedInGoodCondition!: boolean;
    damageReported!: string | undefined;
    checkinNotes!: string | undefined;
    checkinInspection!: InspectionLogDto;

    constructor(data?: ICheckinAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkoutId = _data["checkoutId"];
            this.endingOdometer = _data["endingOdometer"];
            this.fuelLevelCheckin = _data["fuelLevelCheckin"];
            this.returnedInGoodCondition = _data["returnedInGoodCondition"];
            this.damageReported = _data["damageReported"];
            this.checkinNotes = _data["checkinNotes"];
            this.checkinInspection = _data["checkinInspection"] ? InspectionLogDto.fromJS(_data["checkinInspection"]) : undefined as any;
        }
    }

    static fromJS(data: any): CheckinAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckinAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkoutId"] = this.checkoutId;
        data["endingOdometer"] = this.endingOdometer;
        data["fuelLevelCheckin"] = this.fuelLevelCheckin;
        data["returnedInGoodCondition"] = this.returnedInGoodCondition;
        data["damageReported"] = this.damageReported;
        data["checkinNotes"] = this.checkinNotes;
        data["checkinInspection"] = this.checkinInspection ? this.checkinInspection.toJSON() : undefined as any;
        return data;
    }
}

export interface ICheckinAssetDto {
    checkoutId: string;
    endingOdometer: number | undefined;
    fuelLevelCheckin: number | undefined;
    returnedInGoodCondition: boolean;
    damageReported: string | undefined;
    checkinNotes: string | undefined;
    checkinInspection: InspectionLogDto;
}

export class CheckoutAssetDto implements ICheckoutAssetDto {
    assetId!: string;
    expectedReturnDate!: DateTime | undefined;
    purpose!: string | undefined;
    destination!: string | undefined;
    startingOdometer!: number | undefined;
    fuelLevelCheckout!: number | undefined;
    checkoutNotes!: string | undefined;
    checkoutInspection!: InspectionLogDto;

    constructor(data?: ICheckoutAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetId = _data["assetId"];
            this.expectedReturnDate = _data["expectedReturnDate"] ? DateTime.fromISO(_data["expectedReturnDate"].toString()) : undefined as any;
            this.purpose = _data["purpose"];
            this.destination = _data["destination"];
            this.startingOdometer = _data["startingOdometer"];
            this.fuelLevelCheckout = _data["fuelLevelCheckout"];
            this.checkoutNotes = _data["checkoutNotes"];
            this.checkoutInspection = _data["checkoutInspection"] ? InspectionLogDto.fromJS(_data["checkoutInspection"]) : undefined as any;
        }
    }

    static fromJS(data: any): CheckoutAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckoutAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetId"] = this.assetId;
        data["expectedReturnDate"] = this.expectedReturnDate ? this.expectedReturnDate.toString() : undefined as any;
        data["purpose"] = this.purpose;
        data["destination"] = this.destination;
        data["startingOdometer"] = this.startingOdometer;
        data["fuelLevelCheckout"] = this.fuelLevelCheckout;
        data["checkoutNotes"] = this.checkoutNotes;
        data["checkoutInspection"] = this.checkoutInspection ? this.checkoutInspection.toJSON() : undefined as any;
        return data;
    }
}

export interface ICheckoutAssetDto {
    assetId: string;
    expectedReturnDate: DateTime | undefined;
    purpose: string | undefined;
    destination: string | undefined;
    startingOdometer: number | undefined;
    fuelLevelCheckout: number | undefined;
    checkoutNotes: string | undefined;
    checkoutInspection: InspectionLogDto;
}

export enum CheckoutStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum CheckpointStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class Claim implements IClaim {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    memberId!: string;
    member!: Member;
    policyId!: string;
    policy!: Policy;
    claimAmount!: number;
    claimDate!: DateTime;
    dateOfDeath!: DateTime | undefined;
    causeOfDeath!: string | undefined;
    placeOfDeath!: string | undefined;
    status!: ClaimStatus;
    description!: string | undefined;
    claimType!: ClaimType;
    claimantType!: ClaimantType;
    claimantId!: string | undefined;
    claimantName!: string | undefined;
    claimantEmail!: string | undefined;
    claimantPhone!: string | undefined;
    claimantIdNumber!: string | undefined;
    claimantAddress!: string | undefined;
    deceasedPersonId!: string | undefined;
    deceasedPersonName!: string | undefined;
    deceasedPersonIdNumber!: string | undefined;
    relationshipToDeceased!: string | undefined;
    beneficiaryId!: string | undefined;
    beneficiary!: Beneficiary;
    dependentId!: string | undefined;
    dependent!: Dependent;
    bankName!: string | undefined;
    accountNumber!: string | undefined;
    branchCode!: string | undefined;
    accountHolderName!: string | undefined;
    funeralServiceProvider!: string | undefined;
    estimatedFuneralCosts!: number | undefined;
    proposedFuneralDate!: DateTime | undefined;
    funeralLocation!: string | undefined;
    isIdentityVerified!: boolean;
    isDeathVerified!: boolean;
    isPolicyVerified!: boolean;
    isRelationshipVerified!: boolean;
    hasDeathCertificate!: boolean;
    hasIdentityDocuments!: boolean;
    hasMedicalReports!: boolean;
    hasPoliceReport!: boolean;
    hasProofOfRelationship!: boolean;
    hasBankingDetails!: boolean;
    assessedAmount!: number | undefined;
    assessmentNotes!: string | undefined;
    assessedBy!: string | undefined;
    assessedAt!: DateTime | undefined;
    approvedAmount!: number | undefined;
    approvalNotes!: string | undefined;
    approvedBy!: string | undefined;
    approvedAt!: DateTime | undefined;
    paymentReference!: string | undefined;
    paymentDate!: DateTime | undefined;
    paidAmount!: number | undefined;
    processedBy!: string | undefined;
    tenantId!: string;
    tenant!: Tenant;
    documents!: ClaimDocument[] | undefined;
    workflowHistory!: ClaimWorkflowHistory[] | undefined;
    rejectionReason!: string | undefined;
    requiresManagerApproval!: boolean;
    isFraudulent!: boolean;
    fraudNotes!: string | undefined;
    priority!: number;
    expectedCompletionDate!: DateTime | undefined;
    lastContactDate!: DateTime | undefined;
    lastContactMethod!: string | undefined;
    nextActionRequired!: string | undefined;
    nextFollowUpDate!: DateTime | undefined;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : undefined as any;
            this.policyId = _data["policyId"];
            this.policy = _data["policy"] ? Policy.fromJS(_data["policy"]) : undefined as any;
            this.claimAmount = _data["claimAmount"];
            this.claimDate = _data["claimDate"] ? DateTime.fromISO(_data["claimDate"].toString()) : undefined as any;
            this.dateOfDeath = _data["dateOfDeath"] ? DateTime.fromISO(_data["dateOfDeath"].toString()) : undefined as any;
            this.causeOfDeath = _data["causeOfDeath"];
            this.placeOfDeath = _data["placeOfDeath"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.claimType = _data["claimType"];
            this.claimantType = _data["claimantType"];
            this.claimantId = _data["claimantId"];
            this.claimantName = _data["claimantName"];
            this.claimantEmail = _data["claimantEmail"];
            this.claimantPhone = _data["claimantPhone"];
            this.claimantIdNumber = _data["claimantIdNumber"];
            this.claimantAddress = _data["claimantAddress"];
            this.deceasedPersonId = _data["deceasedPersonId"];
            this.deceasedPersonName = _data["deceasedPersonName"];
            this.deceasedPersonIdNumber = _data["deceasedPersonIdNumber"];
            this.relationshipToDeceased = _data["relationshipToDeceased"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.beneficiary = _data["beneficiary"] ? Beneficiary.fromJS(_data["beneficiary"]) : undefined as any;
            this.dependentId = _data["dependentId"];
            this.dependent = _data["dependent"] ? Dependent.fromJS(_data["dependent"]) : undefined as any;
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.branchCode = _data["branchCode"];
            this.accountHolderName = _data["accountHolderName"];
            this.funeralServiceProvider = _data["funeralServiceProvider"];
            this.estimatedFuneralCosts = _data["estimatedFuneralCosts"];
            this.proposedFuneralDate = _data["proposedFuneralDate"] ? DateTime.fromISO(_data["proposedFuneralDate"].toString()) : undefined as any;
            this.funeralLocation = _data["funeralLocation"];
            this.isIdentityVerified = _data["isIdentityVerified"];
            this.isDeathVerified = _data["isDeathVerified"];
            this.isPolicyVerified = _data["isPolicyVerified"];
            this.isRelationshipVerified = _data["isRelationshipVerified"];
            this.hasDeathCertificate = _data["hasDeathCertificate"];
            this.hasIdentityDocuments = _data["hasIdentityDocuments"];
            this.hasMedicalReports = _data["hasMedicalReports"];
            this.hasPoliceReport = _data["hasPoliceReport"];
            this.hasProofOfRelationship = _data["hasProofOfRelationship"];
            this.hasBankingDetails = _data["hasBankingDetails"];
            this.assessedAmount = _data["assessedAmount"];
            this.assessmentNotes = _data["assessmentNotes"];
            this.assessedBy = _data["assessedBy"];
            this.assessedAt = _data["assessedAt"] ? DateTime.fromISO(_data["assessedAt"].toString()) : undefined as any;
            this.approvedAmount = _data["approvedAmount"];
            this.approvalNotes = _data["approvalNotes"];
            this.approvedBy = _data["approvedBy"];
            this.approvedAt = _data["approvedAt"] ? DateTime.fromISO(_data["approvedAt"].toString()) : undefined as any;
            this.paymentReference = _data["paymentReference"];
            this.paymentDate = _data["paymentDate"] ? DateTime.fromISO(_data["paymentDate"].toString()) : undefined as any;
            this.paidAmount = _data["paidAmount"];
            this.processedBy = _data["processedBy"];
            this.tenantId = _data["tenantId"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : undefined as any;
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(ClaimDocument.fromJS(item));
            }
            if (Array.isArray(_data["workflowHistory"])) {
                this.workflowHistory = [] as any;
                for (let item of _data["workflowHistory"])
                    this.workflowHistory!.push(ClaimWorkflowHistory.fromJS(item));
            }
            this.rejectionReason = _data["rejectionReason"];
            this.requiresManagerApproval = _data["requiresManagerApproval"];
            this.isFraudulent = _data["isFraudulent"];
            this.fraudNotes = _data["fraudNotes"];
            this.priority = _data["priority"];
            this.expectedCompletionDate = _data["expectedCompletionDate"] ? DateTime.fromISO(_data["expectedCompletionDate"].toString()) : undefined as any;
            this.lastContactDate = _data["lastContactDate"] ? DateTime.fromISO(_data["lastContactDate"].toString()) : undefined as any;
            this.lastContactMethod = _data["lastContactMethod"];
            this.nextActionRequired = _data["nextActionRequired"];
            this.nextFollowUpDate = _data["nextFollowUpDate"] ? DateTime.fromISO(_data["nextFollowUpDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["member"] = this.member ? this.member.toJSON() : undefined as any;
        data["policyId"] = this.policyId;
        data["policy"] = this.policy ? this.policy.toJSON() : undefined as any;
        data["claimAmount"] = this.claimAmount;
        data["claimDate"] = this.claimDate ? this.claimDate.toString() : undefined as any;
        data["dateOfDeath"] = this.dateOfDeath ? this.dateOfDeath.toString() : undefined as any;
        data["causeOfDeath"] = this.causeOfDeath;
        data["placeOfDeath"] = this.placeOfDeath;
        data["status"] = this.status;
        data["description"] = this.description;
        data["claimType"] = this.claimType;
        data["claimantType"] = this.claimantType;
        data["claimantId"] = this.claimantId;
        data["claimantName"] = this.claimantName;
        data["claimantEmail"] = this.claimantEmail;
        data["claimantPhone"] = this.claimantPhone;
        data["claimantIdNumber"] = this.claimantIdNumber;
        data["claimantAddress"] = this.claimantAddress;
        data["deceasedPersonId"] = this.deceasedPersonId;
        data["deceasedPersonName"] = this.deceasedPersonName;
        data["deceasedPersonIdNumber"] = this.deceasedPersonIdNumber;
        data["relationshipToDeceased"] = this.relationshipToDeceased;
        data["beneficiaryId"] = this.beneficiaryId;
        data["beneficiary"] = this.beneficiary ? this.beneficiary.toJSON() : undefined as any;
        data["dependentId"] = this.dependentId;
        data["dependent"] = this.dependent ? this.dependent.toJSON() : undefined as any;
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["branchCode"] = this.branchCode;
        data["accountHolderName"] = this.accountHolderName;
        data["funeralServiceProvider"] = this.funeralServiceProvider;
        data["estimatedFuneralCosts"] = this.estimatedFuneralCosts;
        data["proposedFuneralDate"] = this.proposedFuneralDate ? this.proposedFuneralDate.toString() : undefined as any;
        data["funeralLocation"] = this.funeralLocation;
        data["isIdentityVerified"] = this.isIdentityVerified;
        data["isDeathVerified"] = this.isDeathVerified;
        data["isPolicyVerified"] = this.isPolicyVerified;
        data["isRelationshipVerified"] = this.isRelationshipVerified;
        data["hasDeathCertificate"] = this.hasDeathCertificate;
        data["hasIdentityDocuments"] = this.hasIdentityDocuments;
        data["hasMedicalReports"] = this.hasMedicalReports;
        data["hasPoliceReport"] = this.hasPoliceReport;
        data["hasProofOfRelationship"] = this.hasProofOfRelationship;
        data["hasBankingDetails"] = this.hasBankingDetails;
        data["assessedAmount"] = this.assessedAmount;
        data["assessmentNotes"] = this.assessmentNotes;
        data["assessedBy"] = this.assessedBy;
        data["assessedAt"] = this.assessedAt ? this.assessedAt.toString() : undefined as any;
        data["approvedAmount"] = this.approvedAmount;
        data["approvalNotes"] = this.approvalNotes;
        data["approvedBy"] = this.approvedBy;
        data["approvedAt"] = this.approvedAt ? this.approvedAt.toString() : undefined as any;
        data["paymentReference"] = this.paymentReference;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toString() : undefined as any;
        data["paidAmount"] = this.paidAmount;
        data["processedBy"] = this.processedBy;
        data["tenantId"] = this.tenantId;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : undefined as any;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.workflowHistory)) {
            data["workflowHistory"] = [];
            for (let item of this.workflowHistory)
                data["workflowHistory"].push(item ? item.toJSON() : undefined as any);
        }
        data["rejectionReason"] = this.rejectionReason;
        data["requiresManagerApproval"] = this.requiresManagerApproval;
        data["isFraudulent"] = this.isFraudulent;
        data["fraudNotes"] = this.fraudNotes;
        data["priority"] = this.priority;
        data["expectedCompletionDate"] = this.expectedCompletionDate ? this.expectedCompletionDate.toString() : undefined as any;
        data["lastContactDate"] = this.lastContactDate ? this.lastContactDate.toString() : undefined as any;
        data["lastContactMethod"] = this.lastContactMethod;
        data["nextActionRequired"] = this.nextActionRequired;
        data["nextFollowUpDate"] = this.nextFollowUpDate ? this.nextFollowUpDate.toString() : undefined as any;
        return data;
    }
}

export interface IClaim {
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    memberId: string;
    member: Member;
    policyId: string;
    policy: Policy;
    claimAmount: number;
    claimDate: DateTime;
    dateOfDeath: DateTime | undefined;
    causeOfDeath: string | undefined;
    placeOfDeath: string | undefined;
    status: ClaimStatus;
    description: string | undefined;
    claimType: ClaimType;
    claimantType: ClaimantType;
    claimantId: string | undefined;
    claimantName: string | undefined;
    claimantEmail: string | undefined;
    claimantPhone: string | undefined;
    claimantIdNumber: string | undefined;
    claimantAddress: string | undefined;
    deceasedPersonId: string | undefined;
    deceasedPersonName: string | undefined;
    deceasedPersonIdNumber: string | undefined;
    relationshipToDeceased: string | undefined;
    beneficiaryId: string | undefined;
    beneficiary: Beneficiary;
    dependentId: string | undefined;
    dependent: Dependent;
    bankName: string | undefined;
    accountNumber: string | undefined;
    branchCode: string | undefined;
    accountHolderName: string | undefined;
    funeralServiceProvider: string | undefined;
    estimatedFuneralCosts: number | undefined;
    proposedFuneralDate: DateTime | undefined;
    funeralLocation: string | undefined;
    isIdentityVerified: boolean;
    isDeathVerified: boolean;
    isPolicyVerified: boolean;
    isRelationshipVerified: boolean;
    hasDeathCertificate: boolean;
    hasIdentityDocuments: boolean;
    hasMedicalReports: boolean;
    hasPoliceReport: boolean;
    hasProofOfRelationship: boolean;
    hasBankingDetails: boolean;
    assessedAmount: number | undefined;
    assessmentNotes: string | undefined;
    assessedBy: string | undefined;
    assessedAt: DateTime | undefined;
    approvedAmount: number | undefined;
    approvalNotes: string | undefined;
    approvedBy: string | undefined;
    approvedAt: DateTime | undefined;
    paymentReference: string | undefined;
    paymentDate: DateTime | undefined;
    paidAmount: number | undefined;
    processedBy: string | undefined;
    tenantId: string;
    tenant: Tenant;
    documents: ClaimDocument[] | undefined;
    workflowHistory: ClaimWorkflowHistory[] | undefined;
    rejectionReason: string | undefined;
    requiresManagerApproval: boolean;
    isFraudulent: boolean;
    fraudNotes: string | undefined;
    priority: number;
    expectedCompletionDate: DateTime | undefined;
    lastContactDate: DateTime | undefined;
    lastContactMethod: string | undefined;
    nextActionRequired: string | undefined;
    nextFollowUpDate: DateTime | undefined;
}

export class ClaimDocument implements IClaimDocument {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    claimId!: string;
    claim!: Claim;
    fileName!: string;
    originalFileName!: string;
    filePath!: string;
    contentType!: string;
    fileSize!: number;
    documentType!: ClaimDocumentType;
    status!: ClaimDocumentStatus;
    rejectionReason!: string | undefined;
    verifiedBy!: string | undefined;
    verifiedAt!: DateTime | undefined;
    tenantId!: string;
    tenant!: Tenant;

    constructor(data?: IClaimDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.claimId = _data["claimId"];
            this.claim = _data["claim"] ? Claim.fromJS(_data["claim"]) : undefined as any;
            this.fileName = _data["fileName"];
            this.originalFileName = _data["originalFileName"];
            this.filePath = _data["filePath"];
            this.contentType = _data["contentType"];
            this.fileSize = _data["fileSize"];
            this.documentType = _data["documentType"];
            this.status = _data["status"];
            this.rejectionReason = _data["rejectionReason"];
            this.verifiedBy = _data["verifiedBy"];
            this.verifiedAt = _data["verifiedAt"] ? DateTime.fromISO(_data["verifiedAt"].toString()) : undefined as any;
            this.tenantId = _data["tenantId"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : undefined as any;
        }
    }

    static fromJS(data: any): ClaimDocument {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["claimId"] = this.claimId;
        data["claim"] = this.claim ? this.claim.toJSON() : undefined as any;
        data["fileName"] = this.fileName;
        data["originalFileName"] = this.originalFileName;
        data["filePath"] = this.filePath;
        data["contentType"] = this.contentType;
        data["fileSize"] = this.fileSize;
        data["documentType"] = this.documentType;
        data["status"] = this.status;
        data["rejectionReason"] = this.rejectionReason;
        data["verifiedBy"] = this.verifiedBy;
        data["verifiedAt"] = this.verifiedAt ? this.verifiedAt.toString() : undefined as any;
        data["tenantId"] = this.tenantId;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : undefined as any;
        return data;
    }
}

export interface IClaimDocument {
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    claimId: string;
    claim: Claim;
    fileName: string;
    originalFileName: string;
    filePath: string;
    contentType: string;
    fileSize: number;
    documentType: ClaimDocumentType;
    status: ClaimDocumentStatus;
    rejectionReason: string | undefined;
    verifiedBy: string | undefined;
    verifiedAt: DateTime | undefined;
    tenantId: string;
    tenant: Tenant;
}

export enum ClaimDocumentStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum ClaimDocumentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export class ClaimDto implements IClaimDto {
    id!: string;
    memberId!: string;
    policyId!: string;
    claimAmount!: number;
    claimDate!: DateTime;
    status!: string | undefined;
    description!: string | undefined;

    constructor(data?: IClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.policyId = _data["policyId"];
            this.claimAmount = _data["claimAmount"];
            this.claimDate = _data["claimDate"] ? DateTime.fromISO(_data["claimDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["policyId"] = this.policyId;
        data["claimAmount"] = this.claimAmount;
        data["claimDate"] = this.claimDate ? this.claimDate.toString() : undefined as any;
        data["status"] = this.status;
        data["description"] = this.description;
        return data;
    }
}

export interface IClaimDto {
    id: string;
    memberId: string;
    policyId: string;
    claimAmount: number;
    claimDate: DateTime;
    status: string | undefined;
    description: string | undefined;
}

export class ClaimEligibilityCheckDto implements IClaimEligibilityCheckDto {
    memberId!: string;
    policyId!: string;
    claimType!: ClaimType;
    claimantType!: ClaimantType;
    beneficiaryId!: string | undefined;
    requestingUserId!: string;
    notes!: string | undefined;

    constructor(data?: IClaimEligibilityCheckDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.policyId = _data["policyId"];
            this.claimType = _data["claimType"];
            this.claimantType = _data["claimantType"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.requestingUserId = _data["requestingUserId"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ClaimEligibilityCheckDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimEligibilityCheckDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["policyId"] = this.policyId;
        data["claimType"] = this.claimType;
        data["claimantType"] = this.claimantType;
        data["beneficiaryId"] = this.beneficiaryId;
        data["requestingUserId"] = this.requestingUserId;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IClaimEligibilityCheckDto {
    memberId: string;
    policyId: string;
    claimType: ClaimType;
    claimantType: ClaimantType;
    beneficiaryId: string | undefined;
    requestingUserId: string;
    notes: string | undefined;
}

export class ClaimEligibilityResultDto implements IClaimEligibilityResultDto {
    isEligible!: boolean;
    message!: string | undefined;
    requirements!: string[] | undefined;
    warnings!: string[] | undefined;
    requiredDocuments!: string[] | undefined;
    isPolicyActive!: boolean;
    isWaitingPeriodSatisfied!: boolean;
    arePremiumsCurrent!: boolean;
    maxClaimAmount!: number;
    outstandingPremiums!: number;
    isClaimantAuthorized!: boolean;
    requiresAdditionalVerification!: boolean;
    authorizationNotes!: string | undefined;
    isDeceasedCovered!: boolean;
    coverageType!: string | undefined;
    coverageAmount!: number;
    exclusions!: string[] | undefined;
    expectedProcessingTime!: string | undefined;
    requiresManagerApproval!: boolean;
    priority!: number;

    constructor(data?: IClaimEligibilityResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEligible = _data["isEligible"];
            this.message = _data["message"];
            if (Array.isArray(_data["requirements"])) {
                this.requirements = [] as any;
                for (let item of _data["requirements"])
                    this.requirements!.push(item);
            }
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
            if (Array.isArray(_data["requiredDocuments"])) {
                this.requiredDocuments = [] as any;
                for (let item of _data["requiredDocuments"])
                    this.requiredDocuments!.push(item);
            }
            this.isPolicyActive = _data["isPolicyActive"];
            this.isWaitingPeriodSatisfied = _data["isWaitingPeriodSatisfied"];
            this.arePremiumsCurrent = _data["arePremiumsCurrent"];
            this.maxClaimAmount = _data["maxClaimAmount"];
            this.outstandingPremiums = _data["outstandingPremiums"];
            this.isClaimantAuthorized = _data["isClaimantAuthorized"];
            this.requiresAdditionalVerification = _data["requiresAdditionalVerification"];
            this.authorizationNotes = _data["authorizationNotes"];
            this.isDeceasedCovered = _data["isDeceasedCovered"];
            this.coverageType = _data["coverageType"];
            this.coverageAmount = _data["coverageAmount"];
            if (Array.isArray(_data["exclusions"])) {
                this.exclusions = [] as any;
                for (let item of _data["exclusions"])
                    this.exclusions!.push(item);
            }
            this.expectedProcessingTime = _data["expectedProcessingTime"];
            this.requiresManagerApproval = _data["requiresManagerApproval"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): ClaimEligibilityResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimEligibilityResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEligible"] = this.isEligible;
        data["message"] = this.message;
        if (Array.isArray(this.requirements)) {
            data["requirements"] = [];
            for (let item of this.requirements)
                data["requirements"].push(item);
        }
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        if (Array.isArray(this.requiredDocuments)) {
            data["requiredDocuments"] = [];
            for (let item of this.requiredDocuments)
                data["requiredDocuments"].push(item);
        }
        data["isPolicyActive"] = this.isPolicyActive;
        data["isWaitingPeriodSatisfied"] = this.isWaitingPeriodSatisfied;
        data["arePremiumsCurrent"] = this.arePremiumsCurrent;
        data["maxClaimAmount"] = this.maxClaimAmount;
        data["outstandingPremiums"] = this.outstandingPremiums;
        data["isClaimantAuthorized"] = this.isClaimantAuthorized;
        data["requiresAdditionalVerification"] = this.requiresAdditionalVerification;
        data["authorizationNotes"] = this.authorizationNotes;
        data["isDeceasedCovered"] = this.isDeceasedCovered;
        data["coverageType"] = this.coverageType;
        data["coverageAmount"] = this.coverageAmount;
        if (Array.isArray(this.exclusions)) {
            data["exclusions"] = [];
            for (let item of this.exclusions)
                data["exclusions"].push(item);
        }
        data["expectedProcessingTime"] = this.expectedProcessingTime;
        data["requiresManagerApproval"] = this.requiresManagerApproval;
        data["priority"] = this.priority;
        return data;
    }
}

export interface IClaimEligibilityResultDto {
    isEligible: boolean;
    message: string | undefined;
    requirements: string[] | undefined;
    warnings: string[] | undefined;
    requiredDocuments: string[] | undefined;
    isPolicyActive: boolean;
    isWaitingPeriodSatisfied: boolean;
    arePremiumsCurrent: boolean;
    maxClaimAmount: number;
    outstandingPremiums: number;
    isClaimantAuthorized: boolean;
    requiresAdditionalVerification: boolean;
    authorizationNotes: string | undefined;
    isDeceasedCovered: boolean;
    coverageType: string | undefined;
    coverageAmount: number;
    exclusions: string[] | undefined;
    expectedProcessingTime: string | undefined;
    requiresManagerApproval: boolean;
    priority: number;
}

export class ClaimProcessStepDto implements IClaimProcessStepDto {
    stepNumber!: number;
    stepName!: string | undefined;
    description!: string | undefined;
    status!: string | undefined;
    isRequired!: boolean;
    completedAt!: DateTime | undefined;
    completedBy!: string | undefined;
    notes!: string | undefined;
    requiredActions!: string[] | undefined;
    requiredDocuments!: string[] | undefined;

    constructor(data?: IClaimProcessStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepNumber = _data["stepNumber"];
            this.stepName = _data["stepName"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.isRequired = _data["isRequired"];
            this.completedAt = _data["completedAt"] ? DateTime.fromISO(_data["completedAt"].toString()) : undefined as any;
            this.completedBy = _data["completedBy"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["requiredActions"])) {
                this.requiredActions = [] as any;
                for (let item of _data["requiredActions"])
                    this.requiredActions!.push(item);
            }
            if (Array.isArray(_data["requiredDocuments"])) {
                this.requiredDocuments = [] as any;
                for (let item of _data["requiredDocuments"])
                    this.requiredDocuments!.push(item);
            }
        }
    }

    static fromJS(data: any): ClaimProcessStepDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimProcessStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stepNumber"] = this.stepNumber;
        data["stepName"] = this.stepName;
        data["description"] = this.description;
        data["status"] = this.status;
        data["isRequired"] = this.isRequired;
        data["completedAt"] = this.completedAt ? this.completedAt.toString() : undefined as any;
        data["completedBy"] = this.completedBy;
        data["notes"] = this.notes;
        if (Array.isArray(this.requiredActions)) {
            data["requiredActions"] = [];
            for (let item of this.requiredActions)
                data["requiredActions"].push(item);
        }
        if (Array.isArray(this.requiredDocuments)) {
            data["requiredDocuments"] = [];
            for (let item of this.requiredDocuments)
                data["requiredDocuments"].push(item);
        }
        return data;
    }
}

export interface IClaimProcessStepDto {
    stepNumber: number;
    stepName: string | undefined;
    description: string | undefined;
    status: string | undefined;
    isRequired: boolean;
    completedAt: DateTime | undefined;
    completedBy: string | undefined;
    notes: string | undefined;
    requiredActions: string[] | undefined;
    requiredDocuments: string[] | undefined;
}

export class ClaimProcessTrackingDto implements IClaimProcessTrackingDto {
    claimId!: string;
    currentStatus!: string | undefined;
    currentStepName!: string | undefined;
    currentStepNumber!: number;
    totalSteps!: number;
    percentageComplete!: number;
    lastUpdated!: DateTime;
    nextAction!: string | undefined;
    expectedCompletionDate!: DateTime | undefined;
    steps!: ClaimProcessStepDto[] | undefined;
    lastContactDate!: DateTime | undefined;
    lastContactMethod!: string | undefined;
    nextFollowUpDate!: DateTime | undefined;
    requiresClaimantAction!: boolean;
    pendingRequirements!: string[] | undefined;

    constructor(data?: IClaimProcessTrackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claimId = _data["claimId"];
            this.currentStatus = _data["currentStatus"];
            this.currentStepName = _data["currentStepName"];
            this.currentStepNumber = _data["currentStepNumber"];
            this.totalSteps = _data["totalSteps"];
            this.percentageComplete = _data["percentageComplete"];
            this.lastUpdated = _data["lastUpdated"] ? DateTime.fromISO(_data["lastUpdated"].toString()) : undefined as any;
            this.nextAction = _data["nextAction"];
            this.expectedCompletionDate = _data["expectedCompletionDate"] ? DateTime.fromISO(_data["expectedCompletionDate"].toString()) : undefined as any;
            if (Array.isArray(_data["steps"])) {
                this.steps = [] as any;
                for (let item of _data["steps"])
                    this.steps!.push(ClaimProcessStepDto.fromJS(item));
            }
            this.lastContactDate = _data["lastContactDate"] ? DateTime.fromISO(_data["lastContactDate"].toString()) : undefined as any;
            this.lastContactMethod = _data["lastContactMethod"];
            this.nextFollowUpDate = _data["nextFollowUpDate"] ? DateTime.fromISO(_data["nextFollowUpDate"].toString()) : undefined as any;
            this.requiresClaimantAction = _data["requiresClaimantAction"];
            if (Array.isArray(_data["pendingRequirements"])) {
                this.pendingRequirements = [] as any;
                for (let item of _data["pendingRequirements"])
                    this.pendingRequirements!.push(item);
            }
        }
    }

    static fromJS(data: any): ClaimProcessTrackingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimProcessTrackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claimId"] = this.claimId;
        data["currentStatus"] = this.currentStatus;
        data["currentStepName"] = this.currentStepName;
        data["currentStepNumber"] = this.currentStepNumber;
        data["totalSteps"] = this.totalSteps;
        data["percentageComplete"] = this.percentageComplete;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toString() : undefined as any;
        data["nextAction"] = this.nextAction;
        data["expectedCompletionDate"] = this.expectedCompletionDate ? this.expectedCompletionDate.toString() : undefined as any;
        if (Array.isArray(this.steps)) {
            data["steps"] = [];
            for (let item of this.steps)
                data["steps"].push(item ? item.toJSON() : undefined as any);
        }
        data["lastContactDate"] = this.lastContactDate ? this.lastContactDate.toString() : undefined as any;
        data["lastContactMethod"] = this.lastContactMethod;
        data["nextFollowUpDate"] = this.nextFollowUpDate ? this.nextFollowUpDate.toString() : undefined as any;
        data["requiresClaimantAction"] = this.requiresClaimantAction;
        if (Array.isArray(this.pendingRequirements)) {
            data["pendingRequirements"] = [];
            for (let item of this.pendingRequirements)
                data["pendingRequirements"].push(item);
        }
        return data;
    }
}

export interface IClaimProcessTrackingDto {
    claimId: string;
    currentStatus: string | undefined;
    currentStepName: string | undefined;
    currentStepNumber: number;
    totalSteps: number;
    percentageComplete: number;
    lastUpdated: DateTime;
    nextAction: string | undefined;
    expectedCompletionDate: DateTime | undefined;
    steps: ClaimProcessStepDto[] | undefined;
    lastContactDate: DateTime | undefined;
    lastContactMethod: string | undefined;
    nextFollowUpDate: DateTime | undefined;
    requiresClaimantAction: boolean;
    pendingRequirements: string[] | undefined;
}

export enum ClaimStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
}

export enum ClaimType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ClaimWorkflowHistory implements IClaimWorkflowHistory {
    id!: string;
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    claimId!: string;
    claim!: Claim;
    oldStatus!: ClaimStatus;
    newStatus!: ClaimStatus;
    notes!: string | undefined;
    changedBy!: string;

    constructor(data?: IClaimWorkflowHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.claimId = _data["claimId"];
            this.claim = _data["claim"] ? Claim.fromJS(_data["claim"]) : undefined as any;
            this.oldStatus = _data["oldStatus"];
            this.newStatus = _data["newStatus"];
            this.notes = _data["notes"];
            this.changedBy = _data["changedBy"];
        }
    }

    static fromJS(data: any): ClaimWorkflowHistory {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimWorkflowHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["claimId"] = this.claimId;
        data["claim"] = this.claim ? this.claim.toJSON() : undefined as any;
        data["oldStatus"] = this.oldStatus;
        data["newStatus"] = this.newStatus;
        data["notes"] = this.notes;
        data["changedBy"] = this.changedBy;
        return data;
    }
}

export interface IClaimWorkflowHistory {
    id: string;
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    claimId: string;
    claim: Claim;
    oldStatus: ClaimStatus;
    newStatus: ClaimStatus;
    notes: string | undefined;
    changedBy: string;
}

export enum ClaimantType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class CompleteMaintenanceDto implements ICompleteMaintenanceDto {
    assetId!: string;
    nextMaintenanceDate!: DateTime | undefined;
    notes!: string | undefined;

    constructor(data?: ICompleteMaintenanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetId = _data["assetId"];
            this.nextMaintenanceDate = _data["nextMaintenanceDate"] ? DateTime.fromISO(_data["nextMaintenanceDate"].toString()) : undefined as any;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CompleteMaintenanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteMaintenanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetId"] = this.assetId;
        data["nextMaintenanceDate"] = this.nextMaintenanceDate ? this.nextMaintenanceDate.toString() : undefined as any;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICompleteMaintenanceDto {
    assetId: string;
    nextMaintenanceDate: DateTime | undefined;
    notes: string | undefined;
}

export class ContactFormDto implements IContactFormDto {
    name!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    subject!: string | undefined;
    message!: string | undefined;
    tenantSubdomain!: string | undefined;

    constructor(data?: IContactFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.subject = _data["subject"];
            this.message = _data["message"];
            this.tenantSubdomain = _data["tenantSubdomain"];
        }
    }

    static fromJS(data: any): ContactFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["subject"] = this.subject;
        data["message"] = this.message;
        data["tenantSubdomain"] = this.tenantSubdomain;
        return data;
    }
}

export interface IContactFormDto {
    name: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    subject: string | undefined;
    message: string | undefined;
    tenantSubdomain: string | undefined;
}

export class ContractGenerationResult implements IContractGenerationResult {
    contractId!: string;
    pdfUrl!: string | undefined;
    usedTemplate!: boolean;
    message!: string | undefined;

    constructor(data?: IContractGenerationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.pdfUrl = _data["pdfUrl"];
            this.usedTemplate = _data["usedTemplate"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ContractGenerationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContractGenerationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["pdfUrl"] = this.pdfUrl;
        data["usedTemplate"] = this.usedTemplate;
        data["message"] = this.message;
        return data;
    }
}

export interface IContractGenerationResult {
    contractId: string;
    pdfUrl: string | undefined;
    usedTemplate: boolean;
    message: string | undefined;
}

export class Coupon implements ICoupon {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    code!: string;
    name!: string;
    description!: string | undefined;
    discountType!: DiscountType;
    discountValue!: number;
    durationInMonths!: number;
    maxRedemptions!: number | undefined;
    currentRedemptions!: number;
    validFrom!: DateTime;
    validUntil!: DateTime | undefined;
    isActive!: boolean;
    applicablePlanIds!: string | undefined;
    applicableTenantTypes!: string | undefined;
    minimumPurchaseAmount!: number | undefined;
    isFirstTimeOnly!: boolean;
    createdBy!: string;
    tenantId!: string | undefined;
    tenant!: Tenant;
    internalNotes!: string | undefined;
    campaignName!: string | undefined;

    constructor(data?: ICoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
            this.durationInMonths = _data["durationInMonths"];
            this.maxRedemptions = _data["maxRedemptions"];
            this.currentRedemptions = _data["currentRedemptions"];
            this.validFrom = _data["validFrom"] ? DateTime.fromISO(_data["validFrom"].toString()) : undefined as any;
            this.validUntil = _data["validUntil"] ? DateTime.fromISO(_data["validUntil"].toString()) : undefined as any;
            this.isActive = _data["isActive"];
            this.applicablePlanIds = _data["applicablePlanIds"];
            this.applicableTenantTypes = _data["applicableTenantTypes"];
            this.minimumPurchaseAmount = _data["minimumPurchaseAmount"];
            this.isFirstTimeOnly = _data["isFirstTimeOnly"];
            this.createdBy = _data["createdBy"];
            this.tenantId = _data["tenantId"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : undefined as any;
            this.internalNotes = _data["internalNotes"];
            this.campaignName = _data["campaignName"];
        }
    }

    static fromJS(data: any): Coupon {
        data = typeof data === 'object' ? data : {};
        let result = new Coupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        data["durationInMonths"] = this.durationInMonths;
        data["maxRedemptions"] = this.maxRedemptions;
        data["currentRedemptions"] = this.currentRedemptions;
        data["validFrom"] = this.validFrom ? this.validFrom.toString() : undefined as any;
        data["validUntil"] = this.validUntil ? this.validUntil.toString() : undefined as any;
        data["isActive"] = this.isActive;
        data["applicablePlanIds"] = this.applicablePlanIds;
        data["applicableTenantTypes"] = this.applicableTenantTypes;
        data["minimumPurchaseAmount"] = this.minimumPurchaseAmount;
        data["isFirstTimeOnly"] = this.isFirstTimeOnly;
        data["createdBy"] = this.createdBy;
        data["tenantId"] = this.tenantId;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : undefined as any;
        data["internalNotes"] = this.internalNotes;
        data["campaignName"] = this.campaignName;
        return data;
    }
}

export interface ICoupon {
    createdAt: DateTime;
    updatedAt: DateTime;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    code: string;
    name: string;
    description: string | undefined;
    discountType: DiscountType;
    discountValue: number;
    durationInMonths: number;
    maxRedemptions: number | undefined;
    currentRedemptions: number;
    validFrom: DateTime;
    validUntil: DateTime | undefined;
    isActive: boolean;
    applicablePlanIds: string | undefined;
    applicableTenantTypes: string | undefined;
    minimumPurchaseAmount: number | undefined;
    isFirstTimeOnly: boolean;
    createdBy: string;
    tenantId: string | undefined;
    tenant: Tenant;
    internalNotes: string | undefined;
    campaignName: string | undefined;
}

export class CouponDto implements ICouponDto {
    id!: string;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    discountType!: string | undefined;
    discountValue!: number;
    durationInMonths!: number;
    maxRedemptions!: number | undefined;
    currentRedemptions!: number;
    validFrom!: DateTime;
    validUntil!: DateTime | undefined;
    isActive!: boolean;
    applicableTenantTypes!: string[] | undefined;
    minimumPurchaseAmount!: number | undefined;
    isFirstTimeOnly!: boolean;
    campaignName!: string | undefined;
    createdAt!: DateTime;

    constructor(data?: ICouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
            this.durationInMonths = _data["durationInMonths"];
            this.maxRedemptions = _data["maxRedemptions"];
            this.currentRedemptions = _data["currentRedemptions"];
            this.validFrom = _data["validFrom"] ? DateTime.fromISO(_data["validFrom"].toString()) : undefined as any;
            this.validUntil = _data["validUntil"] ? DateTime.fromISO(_data["validUntil"].toString()) : undefined as any;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["applicableTenantTypes"])) {
                this.applicableTenantTypes = [] as any;
                for (let item of _data["applicableTenantTypes"])
                    this.applicableTenantTypes!.push(item);
            }
            this.minimumPurchaseAmount = _data["minimumPurchaseAmount"];
            this.isFirstTimeOnly = _data["isFirstTimeOnly"];
            this.campaignName = _data["campaignName"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        data["durationInMonths"] = this.durationInMonths;
        data["maxRedemptions"] = this.maxRedemptions;
        data["currentRedemptions"] = this.currentRedemptions;
        data["validFrom"] = this.validFrom ? this.validFrom.toString() : undefined as any;
        data["validUntil"] = this.validUntil ? this.validUntil.toString() : undefined as any;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.applicableTenantTypes)) {
            data["applicableTenantTypes"] = [];
            for (let item of this.applicableTenantTypes)
                data["applicableTenantTypes"].push(item);
        }
        data["minimumPurchaseAmount"] = this.minimumPurchaseAmount;
        data["isFirstTimeOnly"] = this.isFirstTimeOnly;
        data["campaignName"] = this.campaignName;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        return data;
    }
}

export interface ICouponDto {
    id: string;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    discountType: string | undefined;
    discountValue: number;
    durationInMonths: number;
    maxRedemptions: number | undefined;
    currentRedemptions: number;
    validFrom: DateTime;
    validUntil: DateTime | undefined;
    isActive: boolean;
    applicableTenantTypes: string[] | undefined;
    minimumPurchaseAmount: number | undefined;
    isFirstTimeOnly: boolean;
    campaignName: string | undefined;
    createdAt: DateTime;
}

export class CouponListResponseDto implements ICouponListResponseDto {
    coupons!: CouponDto[] | undefined;
    totalCount!: number;
    pageNumber!: number;
    pageSize!: number;
    totalPages!: number;

    constructor(data?: ICouponListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["coupons"])) {
                this.coupons = [] as any;
                for (let item of _data["coupons"])
                    this.coupons!.push(CouponDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any): CouponListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.coupons)) {
            data["coupons"] = [];
            for (let item of this.coupons)
                data["coupons"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface ICouponListResponseDto {
    coupons: CouponDto[] | undefined;
    totalCount: number;
    pageNumber: number;
    pageSize: number;
    totalPages: number;
}

export class CouponRedemption implements ICouponRedemption {
    id!: string;
    couponId!: string;
    coupon!: Coupon;
    tenantId!: string;
    tenant!: Tenant;
    paymentId!: string;
    payment!: Payment;
    subscriptionPlanId!: string;
    subscriptionPlan!: SubscriptionPlan;
    discountAmount!: number;
    redeemedAt!: DateTime;
    originalAmount!: number;
    finalAmount!: number;
    durationMonths!: number;
    userEmail!: string | undefined;
    ipAddress!: string | undefined;

    constructor(data?: ICouponRedemption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.couponId = _data["couponId"];
            this.coupon = _data["coupon"] ? Coupon.fromJS(_data["coupon"]) : undefined as any;
            this.tenantId = _data["tenantId"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : undefined as any;
            this.paymentId = _data["paymentId"];
            this.payment = _data["payment"] ? Payment.fromJS(_data["payment"]) : undefined as any;
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.subscriptionPlan = _data["subscriptionPlan"] ? SubscriptionPlan.fromJS(_data["subscriptionPlan"]) : undefined as any;
            this.discountAmount = _data["discountAmount"];
            this.redeemedAt = _data["redeemedAt"] ? DateTime.fromISO(_data["redeemedAt"].toString()) : undefined as any;
            this.originalAmount = _data["originalAmount"];
            this.finalAmount = _data["finalAmount"];
            this.durationMonths = _data["durationMonths"];
            this.userEmail = _data["userEmail"];
            this.ipAddress = _data["ipAddress"];
        }
    }

    static fromJS(data: any): CouponRedemption {
        data = typeof data === 'object' ? data : {};
        let result = new CouponRedemption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["couponId"] = this.couponId;
        data["coupon"] = this.coupon ? this.coupon.toJSON() : undefined as any;
        data["tenantId"] = this.tenantId;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : undefined as any;
        data["paymentId"] = this.paymentId;
        data["payment"] = this.payment ? this.payment.toJSON() : undefined as any;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["subscriptionPlan"] = this.subscriptionPlan ? this.subscriptionPlan.toJSON() : undefined as any;
        data["discountAmount"] = this.discountAmount;
        data["redeemedAt"] = this.redeemedAt ? this.redeemedAt.toString() : undefined as any;
        data["originalAmount"] = this.originalAmount;
        data["finalAmount"] = this.finalAmount;
        data["durationMonths"] = this.durationMonths;
        data["userEmail"] = this.userEmail;
        data["ipAddress"] = this.ipAddress;
        return data;
    }
}

export interface ICouponRedemption {
    id: string;
    couponId: string;
    coupon: Coupon;
    tenantId: string;
    tenant: Tenant;
    paymentId: string;
    payment: Payment;
    subscriptionPlanId: string;
    subscriptionPlan: SubscriptionPlan;
    discountAmount: number;
    redeemedAt: DateTime;
    originalAmount: number;
    finalAmount: number;
    durationMonths: number;
    userEmail: string | undefined;
    ipAddress: string | undefined;
}

export class CouponStatsDto implements ICouponStatsDto {
    totalCoupons!: number;
    activeCoupons!: number;
    totalRedemptions!: number;
    totalDiscountGiven!: number;
    topCoupons!: TopCouponDto[] | undefined;

    constructor(data?: ICouponStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCoupons = _data["totalCoupons"];
            this.activeCoupons = _data["activeCoupons"];
            this.totalRedemptions = _data["totalRedemptions"];
            this.totalDiscountGiven = _data["totalDiscountGiven"];
            if (Array.isArray(_data["topCoupons"])) {
                this.topCoupons = [] as any;
                for (let item of _data["topCoupons"])
                    this.topCoupons!.push(TopCouponDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CouponStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCoupons"] = this.totalCoupons;
        data["activeCoupons"] = this.activeCoupons;
        data["totalRedemptions"] = this.totalRedemptions;
        data["totalDiscountGiven"] = this.totalDiscountGiven;
        if (Array.isArray(this.topCoupons)) {
            data["topCoupons"] = [];
            for (let item of this.topCoupons)
                data["topCoupons"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICouponStatsDto {
    totalCoupons: number;
    activeCoupons: number;
    totalRedemptions: number;
    totalDiscountGiven: number;
    topCoupons: TopCouponDto[] | undefined;
}

export class CouponValidationResult implements ICouponValidationResult {
    isValid!: boolean;
    message!: string | undefined;
    discountAmount!: number;
    finalAmount!: number;
    durationMonths!: number;
    couponId!: string | undefined;

    constructor(data?: ICouponValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            this.message = _data["message"];
            this.discountAmount = _data["discountAmount"];
            this.finalAmount = _data["finalAmount"];
            this.durationMonths = _data["durationMonths"];
            this.couponId = _data["couponId"];
        }
    }

    static fromJS(data: any): CouponValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new CouponValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        data["message"] = this.message;
        data["discountAmount"] = this.discountAmount;
        data["finalAmount"] = this.finalAmount;
        data["durationMonths"] = this.durationMonths;
        data["couponId"] = this.couponId;
        return data;
    }
}

export interface ICouponValidationResult {
    isValid: boolean;
    message: string | undefined;
    discountAmount: number;
    finalAmount: number;
    durationMonths: number;
    couponId: string | undefined;
}

export class CreateAssetDto implements ICreateAssetDto {
    name!: string | undefined;
    description!: string | undefined;
    assetType!: AssetType;
    identificationNumber!: string | undefined;
    make!: string | undefined;
    model!: string | undefined;
    year!: number | undefined;
    quantity!: number;
    currentLocation!: string | undefined;
    requiresInspection!: boolean;
    inspectionCheckpoints!: string[] | undefined;
    purchaseDate!: DateTime | undefined;
    purchaseCost!: number | undefined;
    conditionNotes!: string | undefined;

    constructor(data?: ICreateAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.assetType = _data["assetType"];
            this.identificationNumber = _data["identificationNumber"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.year = _data["year"];
            this.quantity = _data["quantity"];
            this.currentLocation = _data["currentLocation"];
            this.requiresInspection = _data["requiresInspection"];
            if (Array.isArray(_data["inspectionCheckpoints"])) {
                this.inspectionCheckpoints = [] as any;
                for (let item of _data["inspectionCheckpoints"])
                    this.inspectionCheckpoints!.push(item);
            }
            this.purchaseDate = _data["purchaseDate"] ? DateTime.fromISO(_data["purchaseDate"].toString()) : undefined as any;
            this.purchaseCost = _data["purchaseCost"];
            this.conditionNotes = _data["conditionNotes"];
        }
    }

    static fromJS(data: any): CreateAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["assetType"] = this.assetType;
        data["identificationNumber"] = this.identificationNumber;
        data["make"] = this.make;
        data["model"] = this.model;
        data["year"] = this.year;
        data["quantity"] = this.quantity;
        data["currentLocation"] = this.currentLocation;
        data["requiresInspection"] = this.requiresInspection;
        if (Array.isArray(this.inspectionCheckpoints)) {
            data["inspectionCheckpoints"] = [];
            for (let item of this.inspectionCheckpoints)
                data["inspectionCheckpoints"].push(item);
        }
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toString() : undefined as any;
        data["purchaseCost"] = this.purchaseCost;
        data["conditionNotes"] = this.conditionNotes;
        return data;
    }
}

export interface ICreateAssetDto {
    name: string | undefined;
    description: string | undefined;
    assetType: AssetType;
    identificationNumber: string | undefined;
    make: string | undefined;
    model: string | undefined;
    year: number | undefined;
    quantity: number;
    currentLocation: string | undefined;
    requiresInspection: boolean;
    inspectionCheckpoints: string[] | undefined;
    purchaseDate: DateTime | undefined;
    purchaseCost: number | undefined;
    conditionNotes: string | undefined;
}

export class CreateBatchRequest implements ICreateBatchRequest {
    processingDate!: DateTime;

    constructor(data?: ICreateBatchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processingDate = _data["processingDate"] ? DateTime.fromISO(_data["processingDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CreateBatchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBatchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processingDate"] = this.processingDate ? this.processingDate.toString() : undefined as any;
        return data;
    }
}

export interface ICreateBatchRequest {
    processingDate: DateTime;
}

export class CreateBookingDto implements ICreateBookingDto {
    customerName!: string | undefined;
    customerEmail!: string | undefined;
    customerPhone!: string | undefined;
    customerNotes!: string | undefined;
    bookingDate!: DateTime;
    timeSlot!: string | undefined;
    services!: BookingServiceDto[] | undefined;

    constructor(data?: ICreateBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerName = _data["customerName"];
            this.customerEmail = _data["customerEmail"];
            this.customerPhone = _data["customerPhone"];
            this.customerNotes = _data["customerNotes"];
            this.bookingDate = _data["bookingDate"] ? DateTime.fromISO(_data["bookingDate"].toString()) : undefined as any;
            this.timeSlot = _data["timeSlot"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(BookingServiceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateBookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerName"] = this.customerName;
        data["customerEmail"] = this.customerEmail;
        data["customerPhone"] = this.customerPhone;
        data["customerNotes"] = this.customerNotes;
        data["bookingDate"] = this.bookingDate ? this.bookingDate.toString() : undefined as any;
        data["timeSlot"] = this.timeSlot;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICreateBookingDto {
    customerName: string | undefined;
    customerEmail: string | undefined;
    customerPhone: string | undefined;
    customerNotes: string | undefined;
    bookingDate: DateTime;
    timeSlot: string | undefined;
    services: BookingServiceDto[] | undefined;
}

export class CreateCategoryDto implements ICreateCategoryDto {
    name!: string;
    description!: string | undefined;
    imageUrl!: string | undefined;
    parentCategoryId!: string | undefined;
    displayOrder!: number;
    isActive!: boolean;
    metaTitle!: string | undefined;
    metaDescription!: string | undefined;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.imageUrl = _data["imageUrl"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.displayOrder = _data["displayOrder"];
            this.isActive = _data["isActive"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["parentCategoryId"] = this.parentCategoryId;
        data["displayOrder"] = this.displayOrder;
        data["isActive"] = this.isActive;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        return data;
    }
}

export interface ICreateCategoryDto {
    name: string;
    description: string | undefined;
    imageUrl: string | undefined;
    parentCategoryId: string | undefined;
    displayOrder: number;
    isActive: boolean;
    metaTitle: string | undefined;
    metaDescription: string | undefined;
}

export class CreateClaimDto implements ICreateClaimDto {
    memberId!: string;
    policyId!: string;
    requestedAmount!: number | undefined;
    dateOfDeath!: DateTime;
    causeOfDeath!: string | undefined;
    placeOfDeath!: string | undefined;
    description!: string | undefined;
    beneficiaryId!: string | undefined;
    additionalNotes!: string | undefined;
    hasDeathCertificate!: boolean;
    hasIdentityDocuments!: boolean;
    hasMedicalReports!: boolean;
    requiresPoliceReport!: boolean;

    constructor(data?: ICreateClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.policyId = _data["policyId"];
            this.requestedAmount = _data["requestedAmount"];
            this.dateOfDeath = _data["dateOfDeath"] ? DateTime.fromISO(_data["dateOfDeath"].toString()) : undefined as any;
            this.causeOfDeath = _data["causeOfDeath"];
            this.placeOfDeath = _data["placeOfDeath"];
            this.description = _data["description"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.additionalNotes = _data["additionalNotes"];
            this.hasDeathCertificate = _data["hasDeathCertificate"];
            this.hasIdentityDocuments = _data["hasIdentityDocuments"];
            this.hasMedicalReports = _data["hasMedicalReports"];
            this.requiresPoliceReport = _data["requiresPoliceReport"];
        }
    }

    static fromJS(data: any): CreateClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["policyId"] = this.policyId;
        data["requestedAmount"] = this.requestedAmount;
        data["dateOfDeath"] = this.dateOfDeath ? this.dateOfDeath.toString() : undefined as any;
        data["causeOfDeath"] = this.causeOfDeath;
        data["placeOfDeath"] = this.placeOfDeath;
        data["description"] = this.description;
        data["beneficiaryId"] = this.beneficiaryId;
        data["additionalNotes"] = this.additionalNotes;
        data["hasDeathCertificate"] = this.hasDeathCertificate;
        data["hasIdentityDocuments"] = this.hasIdentityDocuments;
        data["hasMedicalReports"] = this.hasMedicalReports;
        data["requiresPoliceReport"] = this.requiresPoliceReport;
        return data;
    }
}

export interface ICreateClaimDto {
    memberId: string;
    policyId: string;
    requestedAmount: number | undefined;
    dateOfDeath: DateTime;
    causeOfDeath: string | undefined;
    placeOfDeath: string | undefined;
    description: string | undefined;
    beneficiaryId: string | undefined;
    additionalNotes: string | undefined;
    hasDeathCertificate: boolean;
    hasIdentityDocuments: boolean;
    hasMedicalReports: boolean;
    requiresPoliceReport: boolean;
}

export class CreateCouponDto implements ICreateCouponDto {
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    discountType!: number;
    discountValue!: number;
    durationInMonths!: number;
    maxRedemptions!: number | undefined;
    validFrom!: DateTime;
    validUntil!: DateTime | undefined;
    applicablePlanIds!: string[] | undefined;
    applicableTenantTypes!: string[] | undefined;
    minimumPurchaseAmount!: number | undefined;
    isFirstTimeOnly!: boolean;
    internalNotes!: string | undefined;
    campaignName!: string | undefined;

    constructor(data?: ICreateCouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
            this.durationInMonths = _data["durationInMonths"];
            this.maxRedemptions = _data["maxRedemptions"];
            this.validFrom = _data["validFrom"] ? DateTime.fromISO(_data["validFrom"].toString()) : undefined as any;
            this.validUntil = _data["validUntil"] ? DateTime.fromISO(_data["validUntil"].toString()) : undefined as any;
            if (Array.isArray(_data["applicablePlanIds"])) {
                this.applicablePlanIds = [] as any;
                for (let item of _data["applicablePlanIds"])
                    this.applicablePlanIds!.push(item);
            }
            if (Array.isArray(_data["applicableTenantTypes"])) {
                this.applicableTenantTypes = [] as any;
                for (let item of _data["applicableTenantTypes"])
                    this.applicableTenantTypes!.push(item);
            }
            this.minimumPurchaseAmount = _data["minimumPurchaseAmount"];
            this.isFirstTimeOnly = _data["isFirstTimeOnly"];
            this.internalNotes = _data["internalNotes"];
            this.campaignName = _data["campaignName"];
        }
    }

    static fromJS(data: any): CreateCouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        data["durationInMonths"] = this.durationInMonths;
        data["maxRedemptions"] = this.maxRedemptions;
        data["validFrom"] = this.validFrom ? this.validFrom.toString() : undefined as any;
        data["validUntil"] = this.validUntil ? this.validUntil.toString() : undefined as any;
        if (Array.isArray(this.applicablePlanIds)) {
            data["applicablePlanIds"] = [];
            for (let item of this.applicablePlanIds)
                data["applicablePlanIds"].push(item);
        }
        if (Array.isArray(this.applicableTenantTypes)) {
            data["applicableTenantTypes"] = [];
            for (let item of this.applicableTenantTypes)
                data["applicableTenantTypes"].push(item);
        }
        data["minimumPurchaseAmount"] = this.minimumPurchaseAmount;
        data["isFirstTimeOnly"] = this.isFirstTimeOnly;
        data["internalNotes"] = this.internalNotes;
        data["campaignName"] = this.campaignName;
        return data;
    }
}

export interface ICreateCouponDto {
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    discountType: number;
    discountValue: number;
    durationInMonths: number;
    maxRedemptions: number | undefined;
    validFrom: DateTime;
    validUntil: DateTime | undefined;
    applicablePlanIds: string[] | undefined;
    applicableTenantTypes: string[] | undefined;
    minimumPurchaseAmount: number | undefined;
    isFirstTimeOnly: boolean;
    internalNotes: string | undefined;
    campaignName: string | undefined;
}

export class CreateCustomerAddressDto implements ICreateCustomerAddressDto {
    label!: string | undefined;
    addressLine1!: string;
    addressLine2!: string | undefined;
    city!: string;
    state!: string;
    postalCode!: string;
    country!: string;
    isDefault!: boolean;
    isShipping!: boolean;
    isBilling!: boolean;

    constructor(data?: ICreateCustomerAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.country = _data["country"];
            this.isDefault = _data["isDefault"];
            this.isShipping = _data["isShipping"];
            this.isBilling = _data["isBilling"];
        }
    }

    static fromJS(data: any): CreateCustomerAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["country"] = this.country;
        data["isDefault"] = this.isDefault;
        data["isShipping"] = this.isShipping;
        data["isBilling"] = this.isBilling;
        return data;
    }
}

export interface ICreateCustomerAddressDto {
    label: string | undefined;
    addressLine1: string;
    addressLine2: string | undefined;
    city: string;
    state: string;
    postalCode: string;
    country: string;
    isDefault: boolean;
    isShipping: boolean;
    isBilling: boolean;
}

export class CreateCustomerDto implements ICreateCustomerDto {
    firstName!: string;
    lastName!: string;
    email!: string;
    phone!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    isActive!: boolean;
    acceptsMarketing!: boolean;
    notes!: string | undefined;
    addresses!: CreateCustomerAddressDto[] | undefined;

    constructor(data?: ICreateCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.isActive = _data["isActive"];
            this.acceptsMarketing = _data["acceptsMarketing"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CreateCustomerAddressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["isActive"] = this.isActive;
        data["acceptsMarketing"] = this.acceptsMarketing;
        data["notes"] = this.notes;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICreateCustomerDto {
    firstName: string;
    lastName: string;
    email: string;
    phone: string | undefined;
    dateOfBirth: DateTime | undefined;
    isActive: boolean;
    acceptsMarketing: boolean;
    notes: string | undefined;
    addresses: CreateCustomerAddressDto[] | undefined;
}

export class CreateDashboardWidgetSettingDto implements ICreateDashboardWidgetSettingDto {
    widgetKey!: string | undefined;
    widgetName!: string | undefined;
    isVisible!: boolean;
    allowedRoles!: string[] | undefined;
    displayOrder!: number;

    constructor(data?: ICreateDashboardWidgetSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetKey = _data["widgetKey"];
            this.widgetName = _data["widgetName"];
            this.isVisible = _data["isVisible"];
            if (Array.isArray(_data["allowedRoles"])) {
                this.allowedRoles = [] as any;
                for (let item of _data["allowedRoles"])
                    this.allowedRoles!.push(item);
            }
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): CreateDashboardWidgetSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDashboardWidgetSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetKey"] = this.widgetKey;
        data["widgetName"] = this.widgetName;
        data["isVisible"] = this.isVisible;
        if (Array.isArray(this.allowedRoles)) {
            data["allowedRoles"] = [];
            for (let item of this.allowedRoles)
                data["allowedRoles"].push(item);
        }
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface ICreateDashboardWidgetSettingDto {
    widgetKey: string | undefined;
    widgetName: string | undefined;
    isVisible: boolean;
    allowedRoles: string[] | undefined;
    displayOrder: number;
}

export class CreateMemberBankingDetailDto implements ICreateMemberBankingDetailDto {
    bankName!: string | undefined;
    accountNumber!: string | undefined;
    accountType!: string | undefined;
    branchCode!: string | undefined;
    branchName!: string | undefined;
    accountHolderName!: string | undefined;
    debitDay!: number | undefined;
    paymentMethod!: PaymentMethodType;

    constructor(data?: ICreateMemberBankingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.accountType = _data["accountType"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.accountHolderName = _data["accountHolderName"];
            this.debitDay = _data["debitDay"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): CreateMemberBankingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMemberBankingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["accountType"] = this.accountType;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["accountHolderName"] = this.accountHolderName;
        data["debitDay"] = this.debitDay;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }
}

export interface ICreateMemberBankingDetailDto {
    bankName: string | undefined;
    accountNumber: string | undefined;
    accountType: string | undefined;
    branchCode: string | undefined;
    branchName: string | undefined;
    accountHolderName: string | undefined;
    debitDay: number | undefined;
    paymentMethod: PaymentMethodType;
}

export class CreateMemberDto implements ICreateMemberDto {
    id!: string | undefined;
    name!: string | undefined;
    address!: string | undefined;
    title!: string | undefined;
    firstNames!: string | undefined;
    surname!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    email!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    identificationNumber!: string | undefined;
    sourceOfIncome!: SourceOfIncome;
    sourceOfIncomeOther!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    province!: SouthAfricanProvince;
    postalCode!: string | undefined;
    isReplacingExistingPolicy!: boolean;
    existingPolicyNumber!: string | undefined;
    existingInsurerName!: string | undefined;
    existingPolicyPaidUpToDate!: boolean | undefined;
    existingPolicyWaitingPeriodExpired!: boolean | undefined;
    sameBenefitAsExistingPolicy!: boolean | undefined;
    benefitDifferenceNotes!: string | undefined;
    occupation!: string | undefined;
    workPhoneNumber!: string | undefined;
    passportNumber!: string | undefined;
    countryOfBirth!: string | undefined;
    countryOfResidence!: string | undefined;
    citizenship!: string | undefined;
    nationality!: string | undefined;
    isForeigner!: boolean;
    workPermitNumber!: string | undefined;
    policyId!: string;

    constructor(data?: ICreateMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.title = _data["title"];
            this.firstNames = _data["firstNames"];
            this.surname = _data["surname"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.email = _data["email"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.identificationNumber = _data["identificationNumber"];
            this.sourceOfIncome = _data["sourceOfIncome"];
            this.sourceOfIncomeOther = _data["sourceOfIncomeOther"];
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.isReplacingExistingPolicy = _data["isReplacingExistingPolicy"];
            this.existingPolicyNumber = _data["existingPolicyNumber"];
            this.existingInsurerName = _data["existingInsurerName"];
            this.existingPolicyPaidUpToDate = _data["existingPolicyPaidUpToDate"];
            this.existingPolicyWaitingPeriodExpired = _data["existingPolicyWaitingPeriodExpired"];
            this.sameBenefitAsExistingPolicy = _data["sameBenefitAsExistingPolicy"];
            this.benefitDifferenceNotes = _data["benefitDifferenceNotes"];
            this.occupation = _data["occupation"];
            this.workPhoneNumber = _data["workPhoneNumber"];
            this.passportNumber = _data["passportNumber"];
            this.countryOfBirth = _data["countryOfBirth"];
            this.countryOfResidence = _data["countryOfResidence"];
            this.citizenship = _data["citizenship"];
            this.nationality = _data["nationality"];
            this.isForeigner = _data["isForeigner"];
            this.workPermitNumber = _data["workPermitNumber"];
            this.policyId = _data["policyId"];
        }
    }

    static fromJS(data: any): CreateMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address;
        data["title"] = this.title;
        data["firstNames"] = this.firstNames;
        data["surname"] = this.surname;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["email"] = this.email;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["identificationNumber"] = this.identificationNumber;
        data["sourceOfIncome"] = this.sourceOfIncome;
        data["sourceOfIncomeOther"] = this.sourceOfIncomeOther;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["isReplacingExistingPolicy"] = this.isReplacingExistingPolicy;
        data["existingPolicyNumber"] = this.existingPolicyNumber;
        data["existingInsurerName"] = this.existingInsurerName;
        data["existingPolicyPaidUpToDate"] = this.existingPolicyPaidUpToDate;
        data["existingPolicyWaitingPeriodExpired"] = this.existingPolicyWaitingPeriodExpired;
        data["sameBenefitAsExistingPolicy"] = this.sameBenefitAsExistingPolicy;
        data["benefitDifferenceNotes"] = this.benefitDifferenceNotes;
        data["occupation"] = this.occupation;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["passportNumber"] = this.passportNumber;
        data["countryOfBirth"] = this.countryOfBirth;
        data["countryOfResidence"] = this.countryOfResidence;
        data["citizenship"] = this.citizenship;
        data["nationality"] = this.nationality;
        data["isForeigner"] = this.isForeigner;
        data["workPermitNumber"] = this.workPermitNumber;
        data["policyId"] = this.policyId;
        return data;
    }
}

export interface ICreateMemberDto {
    id: string | undefined;
    name: string | undefined;
    address: string | undefined;
    title: string | undefined;
    firstNames: string | undefined;
    surname: string | undefined;
    dateOfBirth: DateTime | undefined;
    email: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    identificationNumber: string | undefined;
    sourceOfIncome: SourceOfIncome;
    sourceOfIncomeOther: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    province: SouthAfricanProvince;
    postalCode: string | undefined;
    isReplacingExistingPolicy: boolean;
    existingPolicyNumber: string | undefined;
    existingInsurerName: string | undefined;
    existingPolicyPaidUpToDate: boolean | undefined;
    existingPolicyWaitingPeriodExpired: boolean | undefined;
    sameBenefitAsExistingPolicy: boolean | undefined;
    benefitDifferenceNotes: string | undefined;
    occupation: string | undefined;
    workPhoneNumber: string | undefined;
    passportNumber: string | undefined;
    countryOfBirth: string | undefined;
    countryOfResidence: string | undefined;
    citizenship: string | undefined;
    nationality: string | undefined;
    isForeigner: boolean;
    workPermitNumber: string | undefined;
    policyId: string;
}

export class CreateOnboardingFieldConfigurationDto implements ICreateOnboardingFieldConfigurationDto {
    fieldContext!: string | undefined;
    fieldKey!: string;
    fieldLabel!: string;
    fieldType!: string;
    category!: string | undefined;
    isRequired!: boolean;
    isEnabled!: boolean;
    displayOrder!: number;
    placeholder!: string | undefined;
    helpText!: string | undefined;
    optionsJson!: string | undefined;
    validationRulesJson!: string | undefined;
    defaultValue!: string | undefined;
    maxLength!: number | undefined;
    minLength!: number | undefined;

    constructor(data?: ICreateOnboardingFieldConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldContext = _data["fieldContext"];
            this.fieldKey = _data["fieldKey"];
            this.fieldLabel = _data["fieldLabel"];
            this.fieldType = _data["fieldType"];
            this.category = _data["category"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.placeholder = _data["placeholder"];
            this.helpText = _data["helpText"];
            this.optionsJson = _data["optionsJson"];
            this.validationRulesJson = _data["validationRulesJson"];
            this.defaultValue = _data["defaultValue"];
            this.maxLength = _data["maxLength"];
            this.minLength = _data["minLength"];
        }
    }

    static fromJS(data: any): CreateOnboardingFieldConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOnboardingFieldConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldContext"] = this.fieldContext;
        data["fieldKey"] = this.fieldKey;
        data["fieldLabel"] = this.fieldLabel;
        data["fieldType"] = this.fieldType;
        data["category"] = this.category;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["placeholder"] = this.placeholder;
        data["helpText"] = this.helpText;
        data["optionsJson"] = this.optionsJson;
        data["validationRulesJson"] = this.validationRulesJson;
        data["defaultValue"] = this.defaultValue;
        data["maxLength"] = this.maxLength;
        data["minLength"] = this.minLength;
        return data;
    }
}

export interface ICreateOnboardingFieldConfigurationDto {
    fieldContext: string | undefined;
    fieldKey: string;
    fieldLabel: string;
    fieldType: string;
    category: string | undefined;
    isRequired: boolean;
    isEnabled: boolean;
    displayOrder: number;
    placeholder: string | undefined;
    helpText: string | undefined;
    optionsJson: string | undefined;
    validationRulesJson: string | undefined;
    defaultValue: string | undefined;
    maxLength: number | undefined;
    minLength: number | undefined;
}

export class CreateOnboardingFieldDefinitionDto implements ICreateOnboardingFieldDefinitionDto {
    tenantId!: string;
    fieldKey!: string | undefined;
    fieldLabel!: string | undefined;
    placeholder!: string | undefined;
    helpText!: string | undefined;
    fieldType!: string | undefined;
    isRequired!: boolean;
    isEnabled!: boolean;
    validationRules!: string | undefined;
    options!: string | undefined;
    defaultValue!: string | undefined;
    displayOrder!: number;
    cssClass!: string | undefined;
    icon!: string | undefined;
    minValue!: number | undefined;
    maxValue!: number | undefined;
    maxLength!: number | undefined;
    isUnique!: boolean;
    conditionalDisplay!: string | undefined;

    constructor(data?: ICreateOnboardingFieldDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.fieldKey = _data["fieldKey"];
            this.fieldLabel = _data["fieldLabel"];
            this.placeholder = _data["placeholder"];
            this.helpText = _data["helpText"];
            this.fieldType = _data["fieldType"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.validationRules = _data["validationRules"];
            this.options = _data["options"];
            this.defaultValue = _data["defaultValue"];
            this.displayOrder = _data["displayOrder"];
            this.cssClass = _data["cssClass"];
            this.icon = _data["icon"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
            this.maxLength = _data["maxLength"];
            this.isUnique = _data["isUnique"];
            this.conditionalDisplay = _data["conditionalDisplay"];
        }
    }

    static fromJS(data: any): CreateOnboardingFieldDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOnboardingFieldDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["fieldKey"] = this.fieldKey;
        data["fieldLabel"] = this.fieldLabel;
        data["placeholder"] = this.placeholder;
        data["helpText"] = this.helpText;
        data["fieldType"] = this.fieldType;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["validationRules"] = this.validationRules;
        data["options"] = this.options;
        data["defaultValue"] = this.defaultValue;
        data["displayOrder"] = this.displayOrder;
        data["cssClass"] = this.cssClass;
        data["icon"] = this.icon;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        data["maxLength"] = this.maxLength;
        data["isUnique"] = this.isUnique;
        data["conditionalDisplay"] = this.conditionalDisplay;
        return data;
    }
}

export interface ICreateOnboardingFieldDefinitionDto {
    tenantId: string;
    fieldKey: string | undefined;
    fieldLabel: string | undefined;
    placeholder: string | undefined;
    helpText: string | undefined;
    fieldType: string | undefined;
    isRequired: boolean;
    isEnabled: boolean;
    validationRules: string | undefined;
    options: string | undefined;
    defaultValue: string | undefined;
    displayOrder: number;
    cssClass: string | undefined;
    icon: string | undefined;
    minValue: number | undefined;
    maxValue: number | undefined;
    maxLength: number | undefined;
    isUnique: boolean;
    conditionalDisplay: string | undefined;
}

export class CreateOnboardingFieldGroupDto implements ICreateOnboardingFieldGroupDto {
    tenantId!: string;
    groupKey!: string | undefined;
    groupName!: string | undefined;
    description!: string | undefined;
    isEnabled!: boolean;
    displayOrder!: number;
    icon!: string | undefined;
    cssClass!: string | undefined;
    isCollapsible!: boolean;
    isCollapsedByDefault!: boolean;
    fieldIds!: string | undefined;

    constructor(data?: ICreateOnboardingFieldGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.groupKey = _data["groupKey"];
            this.groupName = _data["groupName"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.icon = _data["icon"];
            this.cssClass = _data["cssClass"];
            this.isCollapsible = _data["isCollapsible"];
            this.isCollapsedByDefault = _data["isCollapsedByDefault"];
            this.fieldIds = _data["fieldIds"];
        }
    }

    static fromJS(data: any): CreateOnboardingFieldGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOnboardingFieldGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["groupKey"] = this.groupKey;
        data["groupName"] = this.groupName;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["icon"] = this.icon;
        data["cssClass"] = this.cssClass;
        data["isCollapsible"] = this.isCollapsible;
        data["isCollapsedByDefault"] = this.isCollapsedByDefault;
        data["fieldIds"] = this.fieldIds;
        return data;
    }
}

export interface ICreateOnboardingFieldGroupDto {
    tenantId: string;
    groupKey: string | undefined;
    groupName: string | undefined;
    description: string | undefined;
    isEnabled: boolean;
    displayOrder: number;
    icon: string | undefined;
    cssClass: string | undefined;
    isCollapsible: boolean;
    isCollapsedByDefault: boolean;
    fieldIds: string | undefined;
}

export class CreateOnboardingStepConfigurationDto implements ICreateOnboardingStepConfigurationDto {
    tenantId!: string;
    stepType!: OnboardingStepType;
    stepKey!: string | undefined;
    stepLabel!: string | undefined;
    tenantTypeFilter!: string | undefined;
    displayOrder!: number;
    isRequired!: boolean;
    isEnabled!: boolean;
    description!: string | undefined;
    icon!: string | undefined;
    isSkippable!: boolean;
    pdfTemplateFileId!: string | undefined;
    autoGeneratePdf!: boolean;
    includeStepDataKeys!: string | undefined;
    requireTypedSignature!: boolean;
    termsContentMode!: string | undefined;
    termsPdfFileId!: string | undefined;
    termsTextContent!: string | undefined;
    termsTitle!: string | undefined;
    termsAcceptanceLabel!: string | undefined;
    requireFullReview!: boolean;

    constructor(data?: ICreateOnboardingStepConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.stepType = _data["stepType"];
            this.stepKey = _data["stepKey"];
            this.stepLabel = _data["stepLabel"];
            this.tenantTypeFilter = _data["tenantTypeFilter"];
            this.displayOrder = _data["displayOrder"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.description = _data["description"];
            this.icon = _data["icon"];
            this.isSkippable = _data["isSkippable"];
            this.pdfTemplateFileId = _data["pdfTemplateFileId"];
            this.autoGeneratePdf = _data["autoGeneratePdf"];
            this.includeStepDataKeys = _data["includeStepDataKeys"];
            this.requireTypedSignature = _data["requireTypedSignature"];
            this.termsContentMode = _data["termsContentMode"];
            this.termsPdfFileId = _data["termsPdfFileId"];
            this.termsTextContent = _data["termsTextContent"];
            this.termsTitle = _data["termsTitle"];
            this.termsAcceptanceLabel = _data["termsAcceptanceLabel"];
            this.requireFullReview = _data["requireFullReview"];
        }
    }

    static fromJS(data: any): CreateOnboardingStepConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOnboardingStepConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["stepType"] = this.stepType;
        data["stepKey"] = this.stepKey;
        data["stepLabel"] = this.stepLabel;
        data["tenantTypeFilter"] = this.tenantTypeFilter;
        data["displayOrder"] = this.displayOrder;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["description"] = this.description;
        data["icon"] = this.icon;
        data["isSkippable"] = this.isSkippable;
        data["pdfTemplateFileId"] = this.pdfTemplateFileId;
        data["autoGeneratePdf"] = this.autoGeneratePdf;
        data["includeStepDataKeys"] = this.includeStepDataKeys;
        data["requireTypedSignature"] = this.requireTypedSignature;
        data["termsContentMode"] = this.termsContentMode;
        data["termsPdfFileId"] = this.termsPdfFileId;
        data["termsTextContent"] = this.termsTextContent;
        data["termsTitle"] = this.termsTitle;
        data["termsAcceptanceLabel"] = this.termsAcceptanceLabel;
        data["requireFullReview"] = this.requireFullReview;
        return data;
    }
}

export interface ICreateOnboardingStepConfigurationDto {
    tenantId: string;
    stepType: OnboardingStepType;
    stepKey: string | undefined;
    stepLabel: string | undefined;
    tenantTypeFilter: string | undefined;
    displayOrder: number;
    isRequired: boolean;
    isEnabled: boolean;
    description: string | undefined;
    icon: string | undefined;
    isSkippable: boolean;
    pdfTemplateFileId: string | undefined;
    autoGeneratePdf: boolean;
    includeStepDataKeys: string | undefined;
    requireTypedSignature: boolean;
    termsContentMode: string | undefined;
    termsPdfFileId: string | undefined;
    termsTextContent: string | undefined;
    termsTitle: string | undefined;
    termsAcceptanceLabel: string | undefined;
    requireFullReview: boolean;
}

export class CreateOnboardingStepFieldDto implements ICreateOnboardingStepFieldDto {
    stepId!: string;
    fieldDefinitionId!: string | undefined;
    fieldGroupId!: string | undefined;
    displayOrder!: number;
    isRequired!: boolean;
    isEnabled!: boolean;
    conditionalDisplay!: string | undefined;

    constructor(data?: ICreateOnboardingStepFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepId = _data["stepId"];
            this.fieldDefinitionId = _data["fieldDefinitionId"];
            this.fieldGroupId = _data["fieldGroupId"];
            this.displayOrder = _data["displayOrder"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.conditionalDisplay = _data["conditionalDisplay"];
        }
    }

    static fromJS(data: any): CreateOnboardingStepFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOnboardingStepFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stepId"] = this.stepId;
        data["fieldDefinitionId"] = this.fieldDefinitionId;
        data["fieldGroupId"] = this.fieldGroupId;
        data["displayOrder"] = this.displayOrder;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["conditionalDisplay"] = this.conditionalDisplay;
        return data;
    }
}

export interface ICreateOnboardingStepFieldDto {
    stepId: string;
    fieldDefinitionId: string | undefined;
    fieldGroupId: string | undefined;
    displayOrder: number;
    isRequired: boolean;
    isEnabled: boolean;
    conditionalDisplay: string | undefined;
}

export class CreateOrderDto implements ICreateOrderDto {
    customerId!: string;
    orderItems!: CreateOrderItemDto[];
    customerNote!: string | undefined;
    shippingAddress!: AddressDto;
    billingAddress!: AddressDto;
    paymentMethod!: string;
    taxAmount!: number | undefined;
    shippingAmount!: number | undefined;
    discountAmount!: number | undefined;

    constructor(data?: ICreateOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.orderItems = [];
            this.shippingAddress = new AddressDto();
            this.billingAddress = new AddressDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(CreateOrderItemDto.fromJS(item));
            }
            this.customerNote = _data["customerNote"];
            this.shippingAddress = _data["shippingAddress"] ? AddressDto.fromJS(_data["shippingAddress"]) : new AddressDto();
            this.billingAddress = _data["billingAddress"] ? AddressDto.fromJS(_data["billingAddress"]) : new AddressDto();
            this.paymentMethod = _data["paymentMethod"];
            this.taxAmount = _data["taxAmount"];
            this.shippingAmount = _data["shippingAmount"];
            this.discountAmount = _data["discountAmount"];
        }
    }

    static fromJS(data: any): CreateOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item ? item.toJSON() : undefined as any);
        }
        data["customerNote"] = this.customerNote;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : undefined as any;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : undefined as any;
        data["paymentMethod"] = this.paymentMethod;
        data["taxAmount"] = this.taxAmount;
        data["shippingAmount"] = this.shippingAmount;
        data["discountAmount"] = this.discountAmount;
        return data;
    }
}

export interface ICreateOrderDto {
    customerId: string;
    orderItems: CreateOrderItemDto[];
    customerNote: string | undefined;
    shippingAddress: AddressDto;
    billingAddress: AddressDto;
    paymentMethod: string;
    taxAmount: number | undefined;
    shippingAmount: number | undefined;
    discountAmount: number | undefined;
}

export class CreateOrderItemDto implements ICreateOrderItemDto {
    productId!: string;
    productVariantId!: string | undefined;
    quantity!: number;

    constructor(data?: ICreateOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productVariantId = _data["productVariantId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): CreateOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productVariantId"] = this.productVariantId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ICreateOrderItemDto {
    productId: string;
    productVariantId: string | undefined;
    quantity: number;
}

export class CreatePageDto implements ICreatePageDto {
    name!: string | undefined;
    slug!: string | undefined;
    title!: string | undefined;
    description!: string | undefined;
    isPublic!: boolean;
    requiresAuth!: boolean;
    showInNavbar!: boolean;
    showInFooter!: boolean;

    constructor(data?: ICreatePageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isPublic = _data["isPublic"];
            this.requiresAuth = _data["requiresAuth"];
            this.showInNavbar = _data["showInNavbar"];
            this.showInFooter = _data["showInFooter"];
        }
    }

    static fromJS(data: any): CreatePageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isPublic"] = this.isPublic;
        data["requiresAuth"] = this.requiresAuth;
        data["showInNavbar"] = this.showInNavbar;
        data["showInFooter"] = this.showInFooter;
        return data;
    }
}

export interface ICreatePageDto {
    name: string | undefined;
    slug: string | undefined;
    title: string | undefined;
    description: string | undefined;
    isPublic: boolean;
    requiresAuth: boolean;
    showInNavbar: boolean;
    showInFooter: boolean;
}

export class CreatePaymentSessionDto implements ICreatePaymentSessionDto {
    tenantId!: string;
    subscriptionPlanId!: string;
    couponCode!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    email!: string | undefined;
    tenantEmail!: string | undefined;
    tenantName!: string | undefined;
    amount!: number;
    currency!: string | undefined;
    description!: string | undefined;
    returnUrl!: string | undefined;
    cancelUrl!: string | undefined;
    notifyUrl!: string | undefined;
    isRecurring!: boolean;
    billingCycle!: BillingCycle;
    enableProRata!: boolean;

    constructor(data?: ICreatePaymentSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.couponCode = _data["couponCode"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.tenantEmail = _data["tenantEmail"];
            this.tenantName = _data["tenantName"];
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.description = _data["description"];
            this.returnUrl = _data["returnUrl"];
            this.cancelUrl = _data["cancelUrl"];
            this.notifyUrl = _data["notifyUrl"];
            this.isRecurring = _data["isRecurring"];
            this.billingCycle = _data["billingCycle"];
            this.enableProRata = _data["enableProRata"];
        }
    }

    static fromJS(data: any): CreatePaymentSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["couponCode"] = this.couponCode;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["tenantEmail"] = this.tenantEmail;
        data["tenantName"] = this.tenantName;
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["description"] = this.description;
        data["returnUrl"] = this.returnUrl;
        data["cancelUrl"] = this.cancelUrl;
        data["notifyUrl"] = this.notifyUrl;
        data["isRecurring"] = this.isRecurring;
        data["billingCycle"] = this.billingCycle;
        data["enableProRata"] = this.enableProRata;
        return data;
    }
}

export interface ICreatePaymentSessionDto {
    tenantId: string;
    subscriptionPlanId: string;
    couponCode: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    tenantEmail: string | undefined;
    tenantName: string | undefined;
    amount: number;
    currency: string | undefined;
    description: string | undefined;
    returnUrl: string | undefined;
    cancelUrl: string | undefined;
    notifyUrl: string | undefined;
    isRecurring: boolean;
    billingCycle: BillingCycle;
    enableProRata: boolean;
}

export class CreatePdfFieldMappingRequest implements ICreatePdfFieldMappingRequest {
    sourceField!: string | undefined;
    pdfFieldName!: string | undefined;
    mappingType!: string | undefined;
    isEnabled!: boolean;
    displayOrder!: number;
    description!: string | undefined;
    conditionalRulesJson!: string | undefined;
    transformRule!: string | undefined;
    defaultValue!: string | undefined;
    checkedValue!: string | undefined;
    uncheckedValue!: string | undefined;
    category!: string | undefined;
    isArrayField!: boolean;
    arrayName!: string | undefined;
    arrayFieldPattern!: string | undefined;
    arrayMaxItems!: number | undefined;
    sourceArrayPath!: string | undefined;
    fieldNamePrefix!: string | undefined;
    usePrefixInPdfFieldName!: boolean;

    constructor(data?: ICreatePdfFieldMappingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceField = _data["sourceField"];
            this.pdfFieldName = _data["pdfFieldName"];
            this.mappingType = _data["mappingType"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.description = _data["description"];
            this.conditionalRulesJson = _data["conditionalRulesJson"];
            this.transformRule = _data["transformRule"];
            this.defaultValue = _data["defaultValue"];
            this.checkedValue = _data["checkedValue"];
            this.uncheckedValue = _data["uncheckedValue"];
            this.category = _data["category"];
            this.isArrayField = _data["isArrayField"];
            this.arrayName = _data["arrayName"];
            this.arrayFieldPattern = _data["arrayFieldPattern"];
            this.arrayMaxItems = _data["arrayMaxItems"];
            this.sourceArrayPath = _data["sourceArrayPath"];
            this.fieldNamePrefix = _data["fieldNamePrefix"];
            this.usePrefixInPdfFieldName = _data["usePrefixInPdfFieldName"];
        }
    }

    static fromJS(data: any): CreatePdfFieldMappingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePdfFieldMappingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceField"] = this.sourceField;
        data["pdfFieldName"] = this.pdfFieldName;
        data["mappingType"] = this.mappingType;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["description"] = this.description;
        data["conditionalRulesJson"] = this.conditionalRulesJson;
        data["transformRule"] = this.transformRule;
        data["defaultValue"] = this.defaultValue;
        data["checkedValue"] = this.checkedValue;
        data["uncheckedValue"] = this.uncheckedValue;
        data["category"] = this.category;
        data["isArrayField"] = this.isArrayField;
        data["arrayName"] = this.arrayName;
        data["arrayFieldPattern"] = this.arrayFieldPattern;
        data["arrayMaxItems"] = this.arrayMaxItems;
        data["sourceArrayPath"] = this.sourceArrayPath;
        data["fieldNamePrefix"] = this.fieldNamePrefix;
        data["usePrefixInPdfFieldName"] = this.usePrefixInPdfFieldName;
        return data;
    }
}

export interface ICreatePdfFieldMappingRequest {
    sourceField: string | undefined;
    pdfFieldName: string | undefined;
    mappingType: string | undefined;
    isEnabled: boolean;
    displayOrder: number;
    description: string | undefined;
    conditionalRulesJson: string | undefined;
    transformRule: string | undefined;
    defaultValue: string | undefined;
    checkedValue: string | undefined;
    uncheckedValue: string | undefined;
    category: string | undefined;
    isArrayField: boolean;
    arrayName: string | undefined;
    arrayFieldPattern: string | undefined;
    arrayMaxItems: number | undefined;
    sourceArrayPath: string | undefined;
    fieldNamePrefix: string | undefined;
    usePrefixInPdfFieldName: boolean;
}

export class CreatePlanConfigurationDto implements ICreatePlanConfigurationDto {
    tenantType!: number;
    planName!: string;
    description!: string | undefined;
    monthlyPrice!: number;
    yearlyPrice!: number;
    maxUsers!: number;
    maxStorageMB!: number;
    maxProducts!: number | undefined;
    maxMembers!: number | undefined;
    maxProductImagesPerProduct!: number | undefined;
    maxActiveOrders!: number | undefined;
    apiRateLimitPerMinute!: number;
    apiRateLimitPerDay!: number;
    overageUserPrice!: number;
    overageStoragePricePerGB!: number;
    overageProductPricePer100!: number | undefined;
    overageMemberPricePer100!: number | undefined;
    canUploadFiles!: boolean;
    canCreateSubAccounts!: boolean;
    canExportData!: boolean;
    canUseAPI!: boolean;
    canUseLandingPageBuilder!: boolean;
    canUseCustomDomain!: boolean;
    canAccessAdvancedReports!: boolean;
    canUseWhiteLabel!: boolean;
    hasPrioritySupport!: boolean;
    allowOverage!: boolean;
    sendUsageAlerts!: boolean;
    usageAlertThresholdPercent!: number;
    trialDays!: number;
    requiresCreditCard!: boolean;
    canDowngrade!: boolean;
    canUpgrade!: boolean;
    maxLandingPages!: number;
    maxEmailTemplates!: number;
    maxCustomForms!: number;
    displayOrder!: number;
    isActive!: boolean;

    constructor(data?: ICreatePlanConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantType = _data["tenantType"];
            this.planName = _data["planName"];
            this.description = _data["description"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.yearlyPrice = _data["yearlyPrice"];
            this.maxUsers = _data["maxUsers"];
            this.maxStorageMB = _data["maxStorageMB"];
            this.maxProducts = _data["maxProducts"];
            this.maxMembers = _data["maxMembers"];
            this.maxProductImagesPerProduct = _data["maxProductImagesPerProduct"];
            this.maxActiveOrders = _data["maxActiveOrders"];
            this.apiRateLimitPerMinute = _data["apiRateLimitPerMinute"];
            this.apiRateLimitPerDay = _data["apiRateLimitPerDay"];
            this.overageUserPrice = _data["overageUserPrice"];
            this.overageStoragePricePerGB = _data["overageStoragePricePerGB"];
            this.overageProductPricePer100 = _data["overageProductPricePer100"];
            this.overageMemberPricePer100 = _data["overageMemberPricePer100"];
            this.canUploadFiles = _data["canUploadFiles"];
            this.canCreateSubAccounts = _data["canCreateSubAccounts"];
            this.canExportData = _data["canExportData"];
            this.canUseAPI = _data["canUseAPI"];
            this.canUseLandingPageBuilder = _data["canUseLandingPageBuilder"];
            this.canUseCustomDomain = _data["canUseCustomDomain"];
            this.canAccessAdvancedReports = _data["canAccessAdvancedReports"];
            this.canUseWhiteLabel = _data["canUseWhiteLabel"];
            this.hasPrioritySupport = _data["hasPrioritySupport"];
            this.allowOverage = _data["allowOverage"];
            this.sendUsageAlerts = _data["sendUsageAlerts"];
            this.usageAlertThresholdPercent = _data["usageAlertThresholdPercent"];
            this.trialDays = _data["trialDays"];
            this.requiresCreditCard = _data["requiresCreditCard"];
            this.canDowngrade = _data["canDowngrade"];
            this.canUpgrade = _data["canUpgrade"];
            this.maxLandingPages = _data["maxLandingPages"];
            this.maxEmailTemplates = _data["maxEmailTemplates"];
            this.maxCustomForms = _data["maxCustomForms"];
            this.displayOrder = _data["displayOrder"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreatePlanConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlanConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantType"] = this.tenantType;
        data["planName"] = this.planName;
        data["description"] = this.description;
        data["monthlyPrice"] = this.monthlyPrice;
        data["yearlyPrice"] = this.yearlyPrice;
        data["maxUsers"] = this.maxUsers;
        data["maxStorageMB"] = this.maxStorageMB;
        data["maxProducts"] = this.maxProducts;
        data["maxMembers"] = this.maxMembers;
        data["maxProductImagesPerProduct"] = this.maxProductImagesPerProduct;
        data["maxActiveOrders"] = this.maxActiveOrders;
        data["apiRateLimitPerMinute"] = this.apiRateLimitPerMinute;
        data["apiRateLimitPerDay"] = this.apiRateLimitPerDay;
        data["overageUserPrice"] = this.overageUserPrice;
        data["overageStoragePricePerGB"] = this.overageStoragePricePerGB;
        data["overageProductPricePer100"] = this.overageProductPricePer100;
        data["overageMemberPricePer100"] = this.overageMemberPricePer100;
        data["canUploadFiles"] = this.canUploadFiles;
        data["canCreateSubAccounts"] = this.canCreateSubAccounts;
        data["canExportData"] = this.canExportData;
        data["canUseAPI"] = this.canUseAPI;
        data["canUseLandingPageBuilder"] = this.canUseLandingPageBuilder;
        data["canUseCustomDomain"] = this.canUseCustomDomain;
        data["canAccessAdvancedReports"] = this.canAccessAdvancedReports;
        data["canUseWhiteLabel"] = this.canUseWhiteLabel;
        data["hasPrioritySupport"] = this.hasPrioritySupport;
        data["allowOverage"] = this.allowOverage;
        data["sendUsageAlerts"] = this.sendUsageAlerts;
        data["usageAlertThresholdPercent"] = this.usageAlertThresholdPercent;
        data["trialDays"] = this.trialDays;
        data["requiresCreditCard"] = this.requiresCreditCard;
        data["canDowngrade"] = this.canDowngrade;
        data["canUpgrade"] = this.canUpgrade;
        data["maxLandingPages"] = this.maxLandingPages;
        data["maxEmailTemplates"] = this.maxEmailTemplates;
        data["maxCustomForms"] = this.maxCustomForms;
        data["displayOrder"] = this.displayOrder;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreatePlanConfigurationDto {
    tenantType: number;
    planName: string;
    description: string | undefined;
    monthlyPrice: number;
    yearlyPrice: number;
    maxUsers: number;
    maxStorageMB: number;
    maxProducts: number | undefined;
    maxMembers: number | undefined;
    maxProductImagesPerProduct: number | undefined;
    maxActiveOrders: number | undefined;
    apiRateLimitPerMinute: number;
    apiRateLimitPerDay: number;
    overageUserPrice: number;
    overageStoragePricePerGB: number;
    overageProductPricePer100: number | undefined;
    overageMemberPricePer100: number | undefined;
    canUploadFiles: boolean;
    canCreateSubAccounts: boolean;
    canExportData: boolean;
    canUseAPI: boolean;
    canUseLandingPageBuilder: boolean;
    canUseCustomDomain: boolean;
    canAccessAdvancedReports: boolean;
    canUseWhiteLabel: boolean;
    hasPrioritySupport: boolean;
    allowOverage: boolean;
    sendUsageAlerts: boolean;
    usageAlertThresholdPercent: number;
    trialDays: number;
    requiresCreditCard: boolean;
    canDowngrade: boolean;
    canUpgrade: boolean;
    maxLandingPages: number;
    maxEmailTemplates: number;
    maxCustomForms: number;
    displayOrder: number;
    isActive: boolean;
}

export class CreateProductDto implements ICreateProductDto {
    name!: string;
    sku!: string | undefined;
    description!: string | undefined;
    price!: number;
    compareAtPrice!: number | undefined;
    cost!: number | undefined;
    stockQuantity!: number;
    lowStockThreshold!: number | undefined;
    trackInventory!: boolean;
    isActive!: boolean;
    isFeatured!: boolean;
    categoryId!: string | undefined;
    metaTitle!: string | undefined;
    metaDescription!: string | undefined;
    metaKeywords!: string | undefined;
    weight!: number | undefined;
    length!: number | undefined;
    width!: number | undefined;
    height!: number | undefined;
    weightUnit!: string | undefined;
    dimensionUnit!: string | undefined;
    images!: CreateProductImageDto[] | undefined;
    variants!: CreateProductVariantDto[] | undefined;

    constructor(data?: ICreateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.sku = _data["sku"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.compareAtPrice = _data["compareAtPrice"];
            this.cost = _data["cost"];
            this.stockQuantity = _data["stockQuantity"];
            this.lowStockThreshold = _data["lowStockThreshold"];
            this.trackInventory = _data["trackInventory"];
            this.isActive = _data["isActive"];
            this.isFeatured = _data["isFeatured"];
            this.categoryId = _data["categoryId"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.metaKeywords = _data["metaKeywords"];
            this.weight = _data["weight"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.weightUnit = _data["weightUnit"];
            this.dimensionUnit = _data["dimensionUnit"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(CreateProductImageDto.fromJS(item));
            }
            if (Array.isArray(_data["variants"])) {
                this.variants = [] as any;
                for (let item of _data["variants"])
                    this.variants!.push(CreateProductVariantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sku"] = this.sku;
        data["description"] = this.description;
        data["price"] = this.price;
        data["compareAtPrice"] = this.compareAtPrice;
        data["cost"] = this.cost;
        data["stockQuantity"] = this.stockQuantity;
        data["lowStockThreshold"] = this.lowStockThreshold;
        data["trackInventory"] = this.trackInventory;
        data["isActive"] = this.isActive;
        data["isFeatured"] = this.isFeatured;
        data["categoryId"] = this.categoryId;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["metaKeywords"] = this.metaKeywords;
        data["weight"] = this.weight;
        data["length"] = this.length;
        data["width"] = this.width;
        data["height"] = this.height;
        data["weightUnit"] = this.weightUnit;
        data["dimensionUnit"] = this.dimensionUnit;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.variants)) {
            data["variants"] = [];
            for (let item of this.variants)
                data["variants"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICreateProductDto {
    name: string;
    sku: string | undefined;
    description: string | undefined;
    price: number;
    compareAtPrice: number | undefined;
    cost: number | undefined;
    stockQuantity: number;
    lowStockThreshold: number | undefined;
    trackInventory: boolean;
    isActive: boolean;
    isFeatured: boolean;
    categoryId: string | undefined;
    metaTitle: string | undefined;
    metaDescription: string | undefined;
    metaKeywords: string | undefined;
    weight: number | undefined;
    length: number | undefined;
    width: number | undefined;
    height: number | undefined;
    weightUnit: string | undefined;
    dimensionUnit: string | undefined;
    images: CreateProductImageDto[] | undefined;
    variants: CreateProductVariantDto[] | undefined;
}

export class CreateProductImageDto implements ICreateProductImageDto {
    imageUrl!: string;
    altText!: string | undefined;
    displayOrder!: number;
    isPrimary!: boolean;

    constructor(data?: ICreateProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageUrl = _data["imageUrl"];
            this.altText = _data["altText"];
            this.displayOrder = _data["displayOrder"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): CreateProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageUrl"] = this.imageUrl;
        data["altText"] = this.altText;
        data["displayOrder"] = this.displayOrder;
        data["isPrimary"] = this.isPrimary;
        return data;
    }
}

export interface ICreateProductImageDto {
    imageUrl: string;
    altText: string | undefined;
    displayOrder: number;
    isPrimary: boolean;
}

export class CreateProductVariantDto implements ICreateProductVariantDto {
    name!: string;
    variantType!: string | undefined;
    sku!: string | undefined;
    priceAdjustment!: number | undefined;
    stockQuantity!: number;
    isActive!: boolean;

    constructor(data?: ICreateProductVariantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.variantType = _data["variantType"];
            this.sku = _data["sku"];
            this.priceAdjustment = _data["priceAdjustment"];
            this.stockQuantity = _data["stockQuantity"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateProductVariantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductVariantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["variantType"] = this.variantType;
        data["sku"] = this.sku;
        data["priceAdjustment"] = this.priceAdjustment;
        data["stockQuantity"] = this.stockQuantity;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateProductVariantDto {
    name: string;
    variantType: string | undefined;
    sku: string | undefined;
    priceAdjustment: number | undefined;
    stockQuantity: number;
    isActive: boolean;
}

export class CreateRolePermissionDto implements ICreateRolePermissionDto {
    id!: string;
    roleId!: string;
    permissionId!: string;

    constructor(data?: ICreateRolePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.permissionId = _data["permissionId"];
        }
    }

    static fromJS(data: any): CreateRolePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRolePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["permissionId"] = this.permissionId;
        return data;
    }
}

export interface ICreateRolePermissionDto {
    id: string;
    roleId: string;
    permissionId: string;
}

export class CreateSubscriptionDto implements ICreateSubscriptionDto {
    tenantId!: string;
    subscriptionPlanId!: string;
    couponCode!: string | undefined;
    startTrial!: boolean;
    trialDays!: number | undefined;
    autoRenew!: boolean;

    constructor(data?: ICreateSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.couponCode = _data["couponCode"];
            this.startTrial = _data["startTrial"];
            this.trialDays = _data["trialDays"];
            this.autoRenew = _data["autoRenew"];
        }
    }

    static fromJS(data: any): CreateSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["couponCode"] = this.couponCode;
        data["startTrial"] = this.startTrial;
        data["trialDays"] = this.trialDays;
        data["autoRenew"] = this.autoRenew;
        return data;
    }
}

export interface ICreateSubscriptionDto {
    tenantId: string;
    subscriptionPlanId: string;
    couponCode: string | undefined;
    startTrial: boolean;
    trialDays: number | undefined;
    autoRenew: boolean;
}

export class CreateVerificationRequestDto implements ICreateVerificationRequestDto {
    idNumber!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    verificationType!: string | undefined;
    userId!: string | undefined;
    memberId!: string | undefined;
    claimId!: string | undefined;

    constructor(data?: ICreateVerificationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.verificationType = _data["verificationType"];
            this.userId = _data["userId"];
            this.memberId = _data["memberId"];
            this.claimId = _data["claimId"];
        }
    }

    static fromJS(data: any): CreateVerificationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVerificationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["verificationType"] = this.verificationType;
        data["userId"] = this.userId;
        data["memberId"] = this.memberId;
        data["claimId"] = this.claimId;
        return data;
    }
}

export interface ICreateVerificationRequestDto {
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    dateOfBirth: DateTime | undefined;
    verificationType: string | undefined;
    userId: string | undefined;
    memberId: string | undefined;
    claimId: string | undefined;
}

export class CustomPageDto implements ICustomPageDto {
    id!: string;
    name!: string | undefined;
    slug!: string | undefined;
    title!: string | undefined;
    description!: string | undefined;
    content!: PageWidgetDto[] | undefined;
    isPublic!: boolean;
    requiresAuth!: boolean;
    showInNavbar!: boolean;
    showInFooter!: boolean;
    navbarOrder!: number | undefined;
    footerOrder!: number | undefined;
    isActive!: boolean;
    metaTags!: PageMetaTagsDto;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: ICustomPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["content"])) {
                this.content = [] as any;
                for (let item of _data["content"])
                    this.content!.push(PageWidgetDto.fromJS(item));
            }
            this.isPublic = _data["isPublic"];
            this.requiresAuth = _data["requiresAuth"];
            this.showInNavbar = _data["showInNavbar"];
            this.showInFooter = _data["showInFooter"];
            this.navbarOrder = _data["navbarOrder"];
            this.footerOrder = _data["footerOrder"];
            this.isActive = _data["isActive"];
            this.metaTags = _data["metaTags"] ? PageMetaTagsDto.fromJS(_data["metaTags"]) : undefined as any;
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CustomPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomPageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item ? item.toJSON() : undefined as any);
        }
        data["isPublic"] = this.isPublic;
        data["requiresAuth"] = this.requiresAuth;
        data["showInNavbar"] = this.showInNavbar;
        data["showInFooter"] = this.showInFooter;
        data["navbarOrder"] = this.navbarOrder;
        data["footerOrder"] = this.footerOrder;
        data["isActive"] = this.isActive;
        data["metaTags"] = this.metaTags ? this.metaTags.toJSON() : undefined as any;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface ICustomPageDto {
    id: string;
    name: string | undefined;
    slug: string | undefined;
    title: string | undefined;
    description: string | undefined;
    content: PageWidgetDto[] | undefined;
    isPublic: boolean;
    requiresAuth: boolean;
    showInNavbar: boolean;
    showInFooter: boolean;
    navbarOrder: number | undefined;
    footerOrder: number | undefined;
    isActive: boolean;
    metaTags: PageMetaTagsDto;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class CustomerAddressDto implements ICustomerAddressDto {
    id!: string;
    customerId!: string;
    label!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    country!: string | undefined;
    isDefault!: boolean;
    isShipping!: boolean;
    isBilling!: boolean;

    constructor(data?: ICustomerAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
            this.label = _data["label"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.country = _data["country"];
            this.isDefault = _data["isDefault"];
            this.isShipping = _data["isShipping"];
            this.isBilling = _data["isBilling"];
        }
    }

    static fromJS(data: any): CustomerAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["label"] = this.label;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["country"] = this.country;
        data["isDefault"] = this.isDefault;
        data["isShipping"] = this.isShipping;
        data["isBilling"] = this.isBilling;
        return data;
    }
}

export interface ICustomerAddressDto {
    id: string;
    customerId: string;
    label: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    country: string | undefined;
    isDefault: boolean;
    isShipping: boolean;
    isBilling: boolean;
}

export class CustomerDto implements ICustomerDto {
    id!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    fullName!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    isActive!: boolean;
    acceptsMarketing!: boolean;
    notes!: string | undefined;
    totalOrders!: number;
    totalSpent!: number;
    lastOrderDate!: DateTime | undefined;
    addresses!: CustomerAddressDto[] | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.isActive = _data["isActive"];
            this.acceptsMarketing = _data["acceptsMarketing"];
            this.notes = _data["notes"];
            this.totalOrders = _data["totalOrders"];
            this.totalSpent = _data["totalSpent"];
            this.lastOrderDate = _data["lastOrderDate"] ? DateTime.fromISO(_data["lastOrderDate"].toString()) : undefined as any;
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddressDto.fromJS(item));
            }
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["isActive"] = this.isActive;
        data["acceptsMarketing"] = this.acceptsMarketing;
        data["notes"] = this.notes;
        data["totalOrders"] = this.totalOrders;
        data["totalSpent"] = this.totalSpent;
        data["lastOrderDate"] = this.lastOrderDate ? this.lastOrderDate.toString() : undefined as any;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item ? item.toJSON() : undefined as any);
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface ICustomerDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    dateOfBirth: DateTime | undefined;
    isActive: boolean;
    acceptsMarketing: boolean;
    notes: string | undefined;
    totalOrders: number;
    totalSpent: number;
    lastOrderDate: DateTime | undefined;
    addresses: CustomerAddressDto[] | undefined;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class CustomerStatsDto implements ICustomerStatsDto {
    totalCustomers!: number;
    activeCustomers!: number;
    newCustomersThisMonth!: number;
    totalCustomerValue!: number;
    averageCustomerValue!: number;
    customersWithOrders!: number;

    constructor(data?: ICustomerStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCustomers = _data["totalCustomers"];
            this.activeCustomers = _data["activeCustomers"];
            this.newCustomersThisMonth = _data["newCustomersThisMonth"];
            this.totalCustomerValue = _data["totalCustomerValue"];
            this.averageCustomerValue = _data["averageCustomerValue"];
            this.customersWithOrders = _data["customersWithOrders"];
        }
    }

    static fromJS(data: any): CustomerStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCustomers"] = this.totalCustomers;
        data["activeCustomers"] = this.activeCustomers;
        data["newCustomersThisMonth"] = this.newCustomersThisMonth;
        data["totalCustomerValue"] = this.totalCustomerValue;
        data["averageCustomerValue"] = this.averageCustomerValue;
        data["customersWithOrders"] = this.customersWithOrders;
        return data;
    }
}

export interface ICustomerStatsDto {
    totalCustomers: number;
    activeCustomers: number;
    newCustomersThisMonth: number;
    totalCustomerValue: number;
    averageCustomerValue: number;
    customersWithOrders: number;
}

export class DashboardWidgetSettingDto implements IDashboardWidgetSettingDto {
    id!: string;
    widgetKey!: string | undefined;
    widgetName!: string | undefined;
    isVisible!: boolean;
    allowedRoles!: string[] | undefined;
    displayOrder!: number;

    constructor(data?: IDashboardWidgetSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.widgetKey = _data["widgetKey"];
            this.widgetName = _data["widgetName"];
            this.isVisible = _data["isVisible"];
            if (Array.isArray(_data["allowedRoles"])) {
                this.allowedRoles = [] as any;
                for (let item of _data["allowedRoles"])
                    this.allowedRoles!.push(item);
            }
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): DashboardWidgetSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardWidgetSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["widgetKey"] = this.widgetKey;
        data["widgetName"] = this.widgetName;
        data["isVisible"] = this.isVisible;
        if (Array.isArray(this.allowedRoles)) {
            data["allowedRoles"] = [];
            for (let item of this.allowedRoles)
                data["allowedRoles"].push(item);
        }
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IDashboardWidgetSettingDto {
    id: string;
    widgetKey: string | undefined;
    widgetName: string | undefined;
    isVisible: boolean;
    allowedRoles: string[] | undefined;
    displayOrder: number;
}

export class DebitOrderBatchDto implements IDebitOrderBatchDto {
    id!: string;
    batchNumber!: string | undefined;
    processingDate!: DateTime;
    submittedAt!: DateTime | undefined;
    totalTransactions!: number;
    totalAmount!: number;
    successfulTransactions!: number;
    failedTransactions!: number;
    status!: string | undefined;
    batchFilePath!: string | undefined;
    responseFilePath!: string | undefined;

    constructor(data?: IDebitOrderBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.batchNumber = _data["batchNumber"];
            this.processingDate = _data["processingDate"] ? DateTime.fromISO(_data["processingDate"].toString()) : undefined as any;
            this.submittedAt = _data["submittedAt"] ? DateTime.fromISO(_data["submittedAt"].toString()) : undefined as any;
            this.totalTransactions = _data["totalTransactions"];
            this.totalAmount = _data["totalAmount"];
            this.successfulTransactions = _data["successfulTransactions"];
            this.failedTransactions = _data["failedTransactions"];
            this.status = _data["status"];
            this.batchFilePath = _data["batchFilePath"];
            this.responseFilePath = _data["responseFilePath"];
        }
    }

    static fromJS(data: any): DebitOrderBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new DebitOrderBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["batchNumber"] = this.batchNumber;
        data["processingDate"] = this.processingDate ? this.processingDate.toString() : undefined as any;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toString() : undefined as any;
        data["totalTransactions"] = this.totalTransactions;
        data["totalAmount"] = this.totalAmount;
        data["successfulTransactions"] = this.successfulTransactions;
        data["failedTransactions"] = this.failedTransactions;
        data["status"] = this.status;
        data["batchFilePath"] = this.batchFilePath;
        data["responseFilePath"] = this.responseFilePath;
        return data;
    }
}

export interface IDebitOrderBatchDto {
    id: string;
    batchNumber: string | undefined;
    processingDate: DateTime;
    submittedAt: DateTime | undefined;
    totalTransactions: number;
    totalAmount: number;
    successfulTransactions: number;
    failedTransactions: number;
    status: string | undefined;
    batchFilePath: string | undefined;
    responseFilePath: string | undefined;
}

export class DebitOrderTransactionDto implements IDebitOrderTransactionDto {
    id!: string;
    batchId!: string;
    invoiceId!: string;
    invoiceNumber!: string | undefined;
    tenantId!: string;
    tenantName!: string | undefined;
    amount!: number;
    accountNumber!: string | undefined;
    bankName!: string | undefined;
    status!: string | undefined;
    failureReason!: string | undefined;
    bankReference!: string | undefined;
    processedAt!: DateTime | undefined;

    constructor(data?: IDebitOrderTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.batchId = _data["batchId"];
            this.invoiceId = _data["invoiceId"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            this.amount = _data["amount"];
            this.accountNumber = _data["accountNumber"];
            this.bankName = _data["bankName"];
            this.status = _data["status"];
            this.failureReason = _data["failureReason"];
            this.bankReference = _data["bankReference"];
            this.processedAt = _data["processedAt"] ? DateTime.fromISO(_data["processedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): DebitOrderTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DebitOrderTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["batchId"] = this.batchId;
        data["invoiceId"] = this.invoiceId;
        data["invoiceNumber"] = this.invoiceNumber;
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        data["amount"] = this.amount;
        data["accountNumber"] = this.accountNumber;
        data["bankName"] = this.bankName;
        data["status"] = this.status;
        data["failureReason"] = this.failureReason;
        data["bankReference"] = this.bankReference;
        data["processedAt"] = this.processedAt ? this.processedAt.toString() : undefined as any;
        return data;
    }
}

export interface IDebitOrderTransactionDto {
    id: string;
    batchId: string;
    invoiceId: string;
    invoiceNumber: string | undefined;
    tenantId: string;
    tenantName: string | undefined;
    amount: number;
    accountNumber: string | undefined;
    bankName: string | undefined;
    status: string | undefined;
    failureReason: string | undefined;
    bankReference: string | undefined;
    processedAt: DateTime | undefined;
}

export class Dependent implements IDependent {
    id!: string;
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    memberId!: string;
    member!: Member;
    name!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    identificationNumber!: string | undefined;
    dependentType!: DependentType;
    dateOfBirth!: DateTime | undefined;
    readonly calculatedAge!: number | undefined;
    tenantId!: string;

    constructor(data?: IDependent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.memberId = _data["memberId"];
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : undefined as any;
            this.name = _data["name"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.identificationNumber = _data["identificationNumber"];
            this.dependentType = _data["dependentType"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            (this as any).calculatedAge = _data["calculatedAge"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): Dependent {
        data = typeof data === 'object' ? data : {};
        let result = new Dependent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["memberId"] = this.memberId;
        data["member"] = this.member ? this.member.toJSON() : undefined as any;
        data["name"] = this.name;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["identificationNumber"] = this.identificationNumber;
        data["dependentType"] = this.dependentType;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["calculatedAge"] = this.calculatedAge;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IDependent {
    id: string;
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    memberId: string;
    member: Member;
    name: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    identificationNumber: string | undefined;
    dependentType: DependentType;
    dateOfBirth: DateTime | undefined;
    calculatedAge: number | undefined;
    tenantId: string;
}

export class DependentCountTierDto implements IDependentCountTierDto {
    minDependents!: number;
    maxDependents!: number;
    label!: string | undefined;
    ageBrackets!: { [key: string]: PolicyCoverAgeBracketDto; } | undefined;

    constructor(data?: IDependentCountTierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minDependents = _data["minDependents"];
            this.maxDependents = _data["maxDependents"];
            this.label = _data["label"];
            if (_data["ageBrackets"]) {
                this.ageBrackets = {} as any;
                for (let key in _data["ageBrackets"]) {
                    if (_data["ageBrackets"].hasOwnProperty(key))
                        (this.ageBrackets as any)![key] = _data["ageBrackets"][key] ? PolicyCoverAgeBracketDto.fromJS(_data["ageBrackets"][key]) : new PolicyCoverAgeBracketDto();
                }
            }
        }
    }

    static fromJS(data: any): DependentCountTierDto {
        data = typeof data === 'object' ? data : {};
        let result = new DependentCountTierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minDependents"] = this.minDependents;
        data["maxDependents"] = this.maxDependents;
        data["label"] = this.label;
        if (this.ageBrackets) {
            data["ageBrackets"] = {};
            for (let key in this.ageBrackets) {
                if (this.ageBrackets.hasOwnProperty(key))
                    (data["ageBrackets"] as any)[key] = this.ageBrackets[key] ? this.ageBrackets[key].toJSON() : undefined as any;
            }
        }
        return data;
    }
}

export interface IDependentCountTierDto {
    minDependents: number;
    maxDependents: number;
    label: string | undefined;
    ageBrackets: { [key: string]: PolicyCoverAgeBracketDto; } | undefined;
}

export class DependentDto implements IDependentDto {
    id!: string;
    memberId!: string;
    name!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    identificationNumber!: string | undefined;
    dependentType!: DependentType;
    dateOfBirth!: DateTime | undefined;
    calculatedAge!: number | undefined;

    constructor(data?: IDependentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.identificationNumber = _data["identificationNumber"];
            this.dependentType = _data["dependentType"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.calculatedAge = _data["calculatedAge"];
        }
    }

    static fromJS(data: any): DependentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DependentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["identificationNumber"] = this.identificationNumber;
        data["dependentType"] = this.dependentType;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["calculatedAge"] = this.calculatedAge;
        return data;
    }
}

export interface IDependentDto {
    id: string;
    memberId: string;
    name: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    identificationNumber: string | undefined;
    dependentType: DependentType;
    dateOfBirth: DateTime | undefined;
    calculatedAge: number | undefined;
}

export class DependentInfoDto implements IDependentInfoDto {
    id!: string;
    age!: number;
    dateOfBirth!: DateTime;
    firstName!: string | undefined;
    lastName!: string | undefined;

    constructor(data?: IDependentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.age = _data["age"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): DependentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DependentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["age"] = this.age;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IDependentInfoDto {
    id: string;
    age: number;
    dateOfBirth: DateTime;
    firstName: string | undefined;
    lastName: string | undefined;
}

export class DependentSummary implements IDependentSummary {
    id!: string;
    name!: string | undefined;
    relationship!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    age!: number | undefined;

    constructor(data?: IDependentSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.relationship = _data["relationship"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.age = _data["age"];
        }
    }

    static fromJS(data: any): DependentSummary {
        data = typeof data === 'object' ? data : {};
        let result = new DependentSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["relationship"] = this.relationship;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["age"] = this.age;
        return data;
    }
}

export interface IDependentSummary {
    id: string;
    name: string | undefined;
    relationship: string | undefined;
    dateOfBirth: DateTime | undefined;
    age: number | undefined;
}

export enum DependentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum DiscountType {
    _0 = 0,
    _1 = 1,
}

export class DocumentComplianceStatus implements IDocumentComplianceStatus {
    isCompliant!: boolean;
    totalRequired!: number;
    totalUploaded!: number;
    totalApproved!: number;
    missingDocuments!: DocumentRequirement[] | undefined;
    pendingVerification!: DocumentRequirement[] | undefined;
    rejectedDocuments!: DocumentRequirement[] | undefined;

    constructor(data?: IDocumentComplianceStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isCompliant = _data["isCompliant"];
            this.totalRequired = _data["totalRequired"];
            this.totalUploaded = _data["totalUploaded"];
            this.totalApproved = _data["totalApproved"];
            if (Array.isArray(_data["missingDocuments"])) {
                this.missingDocuments = [] as any;
                for (let item of _data["missingDocuments"])
                    this.missingDocuments!.push(DocumentRequirement.fromJS(item));
            }
            if (Array.isArray(_data["pendingVerification"])) {
                this.pendingVerification = [] as any;
                for (let item of _data["pendingVerification"])
                    this.pendingVerification!.push(DocumentRequirement.fromJS(item));
            }
            if (Array.isArray(_data["rejectedDocuments"])) {
                this.rejectedDocuments = [] as any;
                for (let item of _data["rejectedDocuments"])
                    this.rejectedDocuments!.push(DocumentRequirement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentComplianceStatus {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentComplianceStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isCompliant"] = this.isCompliant;
        data["totalRequired"] = this.totalRequired;
        data["totalUploaded"] = this.totalUploaded;
        data["totalApproved"] = this.totalApproved;
        if (Array.isArray(this.missingDocuments)) {
            data["missingDocuments"] = [];
            for (let item of this.missingDocuments)
                data["missingDocuments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.pendingVerification)) {
            data["pendingVerification"] = [];
            for (let item of this.pendingVerification)
                data["pendingVerification"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.rejectedDocuments)) {
            data["rejectedDocuments"] = [];
            for (let item of this.rejectedDocuments)
                data["rejectedDocuments"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IDocumentComplianceStatus {
    isCompliant: boolean;
    totalRequired: number;
    totalUploaded: number;
    totalApproved: number;
    missingDocuments: DocumentRequirement[] | undefined;
    pendingVerification: DocumentRequirement[] | undefined;
    rejectedDocuments: DocumentRequirement[] | undefined;
}

export class DocumentRequirement implements IDocumentRequirement {
    documentType!: MemberDocumentType;
    documentName!: string | undefined;
    requirementReason!: string | undefined;
    isRequired!: boolean;
    isUploaded!: boolean;
    fileMetadataId!: string | undefined;
    verificationStatus!: DocumentVerificationStatus;

    constructor(data?: IDocumentRequirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"];
            this.documentName = _data["documentName"];
            this.requirementReason = _data["requirementReason"];
            this.isRequired = _data["isRequired"];
            this.isUploaded = _data["isUploaded"];
            this.fileMetadataId = _data["fileMetadataId"];
            this.verificationStatus = _data["verificationStatus"];
        }
    }

    static fromJS(data: any): DocumentRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        data["documentName"] = this.documentName;
        data["requirementReason"] = this.requirementReason;
        data["isRequired"] = this.isRequired;
        data["isUploaded"] = this.isUploaded;
        data["fileMetadataId"] = this.fileMetadataId;
        data["verificationStatus"] = this.verificationStatus;
        return data;
    }
}

export interface IDocumentRequirement {
    documentType: MemberDocumentType;
    documentName: string | undefined;
    requirementReason: string | undefined;
    isRequired: boolean;
    isUploaded: boolean;
    fileMetadataId: string | undefined;
    verificationStatus: DocumentVerificationStatus;
}

export enum DocumentVerificationStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class DonorRecognition implements IDonorRecognition {
    id!: number;
    donorName!: string;
    donorType!: string;
    donationAmount!: number;
    donationDate!: DateTime;
    campaign!: string | undefined;
    recognitionLevel!: string;
    isAnonymous!: boolean;
    notes!: string | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: IDonorRecognition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.donorName = _data["donorName"];
            this.donorType = _data["donorType"];
            this.donationAmount = _data["donationAmount"];
            this.donationDate = _data["donationDate"] ? DateTime.fromISO(_data["donationDate"].toString()) : undefined as any;
            this.campaign = _data["campaign"];
            this.recognitionLevel = _data["recognitionLevel"];
            this.isAnonymous = _data["isAnonymous"];
            this.notes = _data["notes"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): DonorRecognition {
        data = typeof data === 'object' ? data : {};
        let result = new DonorRecognition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["donorName"] = this.donorName;
        data["donorType"] = this.donorType;
        data["donationAmount"] = this.donationAmount;
        data["donationDate"] = this.donationDate ? this.donationDate.toString() : undefined as any;
        data["campaign"] = this.campaign;
        data["recognitionLevel"] = this.recognitionLevel;
        data["isAnonymous"] = this.isAnonymous;
        data["notes"] = this.notes;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IDonorRecognition {
    id: number;
    donorName: string;
    donorType: string;
    donationAmount: number;
    donationDate: DateTime;
    campaign: string | undefined;
    recognitionLevel: string;
    isAnonymous: boolean;
    notes: string | undefined;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class EnhancedCreateClaimDto implements IEnhancedCreateClaimDto {
    memberId!: string;
    policyId!: string;
    requestedAmount!: number | undefined;
    description!: string | undefined;
    claimType!: string | undefined;
    claimantType!: string | undefined;
    dateOfDeath!: DateTime;
    causeOfDeath!: string | undefined;
    placeOfDeath!: string | undefined;
    claimantName!: string | undefined;
    claimantEmail!: string | undefined;
    claimantPhone!: string | undefined;
    claimantIdNumber!: string | undefined;
    claimantAddress!: string | undefined;
    deceasedPersonId!: string | undefined;
    deceasedPersonName!: string | undefined;
    deceasedPersonIdNumber!: string | undefined;
    relationshipToDeceased!: string | undefined;
    beneficiaryId!: string | undefined;
    dependentId!: string | undefined;
    bankName!: string | undefined;
    accountNumber!: string | undefined;
    branchCode!: string | undefined;
    accountHolderName!: string | undefined;
    funeralServiceProvider!: string | undefined;
    estimatedFuneralCosts!: number | undefined;
    proposedFuneralDate!: DateTime | undefined;
    funeralLocation!: string | undefined;
    hasDeathCertificate!: boolean;
    hasIdentityDocuments!: boolean;
    hasMedicalReports!: boolean;
    hasPoliceReport!: boolean;
    hasProofOfRelationship!: boolean;
    hasBankingDetails!: boolean;
    additionalNotes!: string | undefined;
    requiresUrgentProcessing!: boolean;

    constructor(data?: IEnhancedCreateClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.policyId = _data["policyId"];
            this.requestedAmount = _data["requestedAmount"];
            this.description = _data["description"];
            this.claimType = _data["claimType"];
            this.claimantType = _data["claimantType"];
            this.dateOfDeath = _data["dateOfDeath"] ? DateTime.fromISO(_data["dateOfDeath"].toString()) : undefined as any;
            this.causeOfDeath = _data["causeOfDeath"];
            this.placeOfDeath = _data["placeOfDeath"];
            this.claimantName = _data["claimantName"];
            this.claimantEmail = _data["claimantEmail"];
            this.claimantPhone = _data["claimantPhone"];
            this.claimantIdNumber = _data["claimantIdNumber"];
            this.claimantAddress = _data["claimantAddress"];
            this.deceasedPersonId = _data["deceasedPersonId"];
            this.deceasedPersonName = _data["deceasedPersonName"];
            this.deceasedPersonIdNumber = _data["deceasedPersonIdNumber"];
            this.relationshipToDeceased = _data["relationshipToDeceased"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.dependentId = _data["dependentId"];
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.branchCode = _data["branchCode"];
            this.accountHolderName = _data["accountHolderName"];
            this.funeralServiceProvider = _data["funeralServiceProvider"];
            this.estimatedFuneralCosts = _data["estimatedFuneralCosts"];
            this.proposedFuneralDate = _data["proposedFuneralDate"] ? DateTime.fromISO(_data["proposedFuneralDate"].toString()) : undefined as any;
            this.funeralLocation = _data["funeralLocation"];
            this.hasDeathCertificate = _data["hasDeathCertificate"];
            this.hasIdentityDocuments = _data["hasIdentityDocuments"];
            this.hasMedicalReports = _data["hasMedicalReports"];
            this.hasPoliceReport = _data["hasPoliceReport"];
            this.hasProofOfRelationship = _data["hasProofOfRelationship"];
            this.hasBankingDetails = _data["hasBankingDetails"];
            this.additionalNotes = _data["additionalNotes"];
            this.requiresUrgentProcessing = _data["requiresUrgentProcessing"];
        }
    }

    static fromJS(data: any): EnhancedCreateClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnhancedCreateClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["policyId"] = this.policyId;
        data["requestedAmount"] = this.requestedAmount;
        data["description"] = this.description;
        data["claimType"] = this.claimType;
        data["claimantType"] = this.claimantType;
        data["dateOfDeath"] = this.dateOfDeath ? this.dateOfDeath.toString() : undefined as any;
        data["causeOfDeath"] = this.causeOfDeath;
        data["placeOfDeath"] = this.placeOfDeath;
        data["claimantName"] = this.claimantName;
        data["claimantEmail"] = this.claimantEmail;
        data["claimantPhone"] = this.claimantPhone;
        data["claimantIdNumber"] = this.claimantIdNumber;
        data["claimantAddress"] = this.claimantAddress;
        data["deceasedPersonId"] = this.deceasedPersonId;
        data["deceasedPersonName"] = this.deceasedPersonName;
        data["deceasedPersonIdNumber"] = this.deceasedPersonIdNumber;
        data["relationshipToDeceased"] = this.relationshipToDeceased;
        data["beneficiaryId"] = this.beneficiaryId;
        data["dependentId"] = this.dependentId;
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["branchCode"] = this.branchCode;
        data["accountHolderName"] = this.accountHolderName;
        data["funeralServiceProvider"] = this.funeralServiceProvider;
        data["estimatedFuneralCosts"] = this.estimatedFuneralCosts;
        data["proposedFuneralDate"] = this.proposedFuneralDate ? this.proposedFuneralDate.toString() : undefined as any;
        data["funeralLocation"] = this.funeralLocation;
        data["hasDeathCertificate"] = this.hasDeathCertificate;
        data["hasIdentityDocuments"] = this.hasIdentityDocuments;
        data["hasMedicalReports"] = this.hasMedicalReports;
        data["hasPoliceReport"] = this.hasPoliceReport;
        data["hasProofOfRelationship"] = this.hasProofOfRelationship;
        data["hasBankingDetails"] = this.hasBankingDetails;
        data["additionalNotes"] = this.additionalNotes;
        data["requiresUrgentProcessing"] = this.requiresUrgentProcessing;
        return data;
    }
}

export interface IEnhancedCreateClaimDto {
    memberId: string;
    policyId: string;
    requestedAmount: number | undefined;
    description: string | undefined;
    claimType: string | undefined;
    claimantType: string | undefined;
    dateOfDeath: DateTime;
    causeOfDeath: string | undefined;
    placeOfDeath: string | undefined;
    claimantName: string | undefined;
    claimantEmail: string | undefined;
    claimantPhone: string | undefined;
    claimantIdNumber: string | undefined;
    claimantAddress: string | undefined;
    deceasedPersonId: string | undefined;
    deceasedPersonName: string | undefined;
    deceasedPersonIdNumber: string | undefined;
    relationshipToDeceased: string | undefined;
    beneficiaryId: string | undefined;
    dependentId: string | undefined;
    bankName: string | undefined;
    accountNumber: string | undefined;
    branchCode: string | undefined;
    accountHolderName: string | undefined;
    funeralServiceProvider: string | undefined;
    estimatedFuneralCosts: number | undefined;
    proposedFuneralDate: DateTime | undefined;
    funeralLocation: string | undefined;
    hasDeathCertificate: boolean;
    hasIdentityDocuments: boolean;
    hasMedicalReports: boolean;
    hasPoliceReport: boolean;
    hasProofOfRelationship: boolean;
    hasBankingDetails: boolean;
    additionalNotes: string | undefined;
    requiresUrgentProcessing: boolean;
}

export class ErrorResponse implements IErrorResponse {
    message!: string | undefined;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface IErrorResponse {
    message: string | undefined;
}

export class ExtendedFamilyBenefitRowDto implements IExtendedFamilyBenefitRowDto {
    minAge!: number;
    maxAge!: number;
    ageRange!: string | undefined;
    premium_5000_Cover!: number;
    premium_10000_Cover!: number;
    premium_15000_Cover!: number;
    premium_20000_Cover!: number;

    [key: string]: any;

    constructor(data?: IExtendedFamilyBenefitRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.minAge = _data["minAge"];
            this.maxAge = _data["maxAge"];
            this.ageRange = _data["ageRange"];
            this.premium_5000_Cover = _data["premium_5000_Cover"];
            this.premium_10000_Cover = _data["premium_10000_Cover"];
            this.premium_15000_Cover = _data["premium_15000_Cover"];
            this.premium_20000_Cover = _data["premium_20000_Cover"];
        }
    }

    static fromJS(data: any): ExtendedFamilyBenefitRowDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendedFamilyBenefitRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["minAge"] = this.minAge;
        data["maxAge"] = this.maxAge;
        data["ageRange"] = this.ageRange;
        data["premium_5000_Cover"] = this.premium_5000_Cover;
        data["premium_10000_Cover"] = this.premium_10000_Cover;
        data["premium_15000_Cover"] = this.premium_15000_Cover;
        data["premium_20000_Cover"] = this.premium_20000_Cover;
        return data;
    }
}

export interface IExtendedFamilyBenefitRowDto {
    minAge: number;
    maxAge: number;
    ageRange: string | undefined;
    premium_5000_Cover: number;
    premium_10000_Cover: number;
    premium_15000_Cover: number;
    premium_20000_Cover: number;

    [key: string]: any;
}

export class ExtendedFamilyBenefitTableDto implements IExtendedFamilyBenefitTableDto {
    rows!: ExtendedFamilyBenefitRowDto[] | undefined;

    constructor(data?: IExtendedFamilyBenefitTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(ExtendedFamilyBenefitRowDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExtendedFamilyBenefitTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendedFamilyBenefitTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IExtendedFamilyBenefitTableDto {
    rows: ExtendedFamilyBenefitRowDto[] | undefined;
}

export class FileMetadataDto implements IFileMetadataDto {
    id!: string;
    tenantId!: string;
    userId!: string | undefined;
    fileName!: string | undefined;
    filePath!: string | undefined;
    contentType!: string | undefined;
    size!: number;
    description!: string | undefined;
    entityType!: string | undefined;
    entityId!: string | undefined;

    constructor(data?: IFileMetadataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.contentType = _data["contentType"];
            this.size = _data["size"];
            this.description = _data["description"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): FileMetadataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileMetadataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["contentType"] = this.contentType;
        data["size"] = this.size;
        data["description"] = this.description;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        return data;
    }
}

export interface IFileMetadataDto {
    id: string;
    tenantId: string;
    userId: string | undefined;
    fileName: string | undefined;
    filePath: string | undefined;
    contentType: string | undefined;
    size: number;
    description: string | undefined;
    entityType: string | undefined;
    entityId: string | undefined;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string | undefined;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email: string | undefined;
}

export enum FulfillmentStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class FuneralEventDto implements IFuneralEventDto {
    id!: string;
    claimId!: string;
    eventDate!: DateTime;
    location!: string | undefined;
    notes!: string | undefined;
    status!: FuneralEventStatus;
    assetIds!: string[] | undefined;
    driverIds!: string[] | undefined;
    decoratorIds!: string[] | undefined;

    constructor(data?: IFuneralEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.claimId = _data["claimId"];
            this.eventDate = _data["eventDate"] ? DateTime.fromISO(_data["eventDate"].toString()) : undefined as any;
            this.location = _data["location"];
            this.notes = _data["notes"];
            this.status = _data["status"];
            if (Array.isArray(_data["assetIds"])) {
                this.assetIds = [] as any;
                for (let item of _data["assetIds"])
                    this.assetIds!.push(item);
            }
            if (Array.isArray(_data["driverIds"])) {
                this.driverIds = [] as any;
                for (let item of _data["driverIds"])
                    this.driverIds!.push(item);
            }
            if (Array.isArray(_data["decoratorIds"])) {
                this.decoratorIds = [] as any;
                for (let item of _data["decoratorIds"])
                    this.decoratorIds!.push(item);
            }
        }
    }

    static fromJS(data: any): FuneralEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new FuneralEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["claimId"] = this.claimId;
        data["eventDate"] = this.eventDate ? this.eventDate.toString() : undefined as any;
        data["location"] = this.location;
        data["notes"] = this.notes;
        data["status"] = this.status;
        if (Array.isArray(this.assetIds)) {
            data["assetIds"] = [];
            for (let item of this.assetIds)
                data["assetIds"].push(item);
        }
        if (Array.isArray(this.driverIds)) {
            data["driverIds"] = [];
            for (let item of this.driverIds)
                data["driverIds"].push(item);
        }
        if (Array.isArray(this.decoratorIds)) {
            data["decoratorIds"] = [];
            for (let item of this.decoratorIds)
                data["decoratorIds"].push(item);
        }
        return data;
    }
}

export interface IFuneralEventDto {
    id: string;
    claimId: string;
    eventDate: DateTime;
    location: string | undefined;
    notes: string | undefined;
    status: FuneralEventStatus;
    assetIds: string[] | undefined;
    driverIds: string[] | undefined;
    decoratorIds: string[] | undefined;
}

export enum FuneralEventStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class GenerateContractRequest implements IGenerateContractRequest {
    memberId!: string;

    constructor(data?: IGenerateContractRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
        }
    }

    static fromJS(data: any): GenerateContractRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateContractRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        return data;
    }
}

export interface IGenerateContractRequest {
    memberId: string;
}

export class GeneratePolicyNumberRequestDto implements IGeneratePolicyNumberRequestDto {
    memberId!: string | undefined;

    constructor(data?: IGeneratePolicyNumberRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
        }
    }

    static fromJS(data: any): GeneratePolicyNumberRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneratePolicyNumberRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        return data;
    }
}

export interface IGeneratePolicyNumberRequestDto {
    memberId: string | undefined;
}

export class GeneratePolicyNumberResponseDto implements IGeneratePolicyNumberResponseDto {
    policyNumber!: string | undefined;
    generationStrategy!: string | undefined;
    message!: string | undefined;

    constructor(data?: IGeneratePolicyNumberResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.policyNumber = _data["policyNumber"];
            this.generationStrategy = _data["generationStrategy"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): GeneratePolicyNumberResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneratePolicyNumberResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyNumber"] = this.policyNumber;
        data["generationStrategy"] = this.generationStrategy;
        data["message"] = this.message;
        return data;
    }
}

export interface IGeneratePolicyNumberResponseDto {
    policyNumber: string | undefined;
    generationStrategy: string | undefined;
    message: string | undefined;
}

export class GrantApplication implements IGrantApplication {
    id!: number;
    organizationName!: string;
    contactPerson!: string;
    email!: string;
    phone!: string | undefined;
    projectName!: string;
    projectDescription!: string;
    projectCategory!: string;
    requestedAmount!: number;
    timeline!: string;
    status!: string;
    submittedDate!: DateTime;
    reviewedDate!: DateTime | undefined;
    approvedDate!: DateTime | undefined;
    notes!: string | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: IGrantApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.organizationName = _data["organizationName"];
            this.contactPerson = _data["contactPerson"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.projectName = _data["projectName"];
            this.projectDescription = _data["projectDescription"];
            this.projectCategory = _data["projectCategory"];
            this.requestedAmount = _data["requestedAmount"];
            this.timeline = _data["timeline"];
            this.status = _data["status"];
            this.submittedDate = _data["submittedDate"] ? DateTime.fromISO(_data["submittedDate"].toString()) : undefined as any;
            this.reviewedDate = _data["reviewedDate"] ? DateTime.fromISO(_data["reviewedDate"].toString()) : undefined as any;
            this.approvedDate = _data["approvedDate"] ? DateTime.fromISO(_data["approvedDate"].toString()) : undefined as any;
            this.notes = _data["notes"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): GrantApplication {
        data = typeof data === 'object' ? data : {};
        let result = new GrantApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationName"] = this.organizationName;
        data["contactPerson"] = this.contactPerson;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["projectName"] = this.projectName;
        data["projectDescription"] = this.projectDescription;
        data["projectCategory"] = this.projectCategory;
        data["requestedAmount"] = this.requestedAmount;
        data["timeline"] = this.timeline;
        data["status"] = this.status;
        data["submittedDate"] = this.submittedDate ? this.submittedDate.toString() : undefined as any;
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toString() : undefined as any;
        data["approvedDate"] = this.approvedDate ? this.approvedDate.toString() : undefined as any;
        data["notes"] = this.notes;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IGrantApplication {
    id: number;
    organizationName: string;
    contactPerson: string;
    email: string;
    phone: string | undefined;
    projectName: string;
    projectDescription: string;
    projectCategory: string;
    requestedAmount: number;
    timeline: string;
    status: string;
    submittedDate: DateTime;
    reviewedDate: DateTime | undefined;
    approvedDate: DateTime | undefined;
    notes: string | undefined;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class ImpactReport implements IImpactReport {
    id!: number;
    title!: string;
    description!: string;
    category!: string;
    metrics!: string;
    period!: string;
    attachments!: string | undefined;
    isPublished!: boolean;
    reportDate!: DateTime;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: IImpactReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.metrics = _data["metrics"];
            this.period = _data["period"];
            this.attachments = _data["attachments"];
            this.isPublished = _data["isPublished"];
            this.reportDate = _data["reportDate"] ? DateTime.fromISO(_data["reportDate"].toString()) : undefined as any;
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ImpactReport {
        data = typeof data === 'object' ? data : {};
        let result = new ImpactReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["category"] = this.category;
        data["metrics"] = this.metrics;
        data["period"] = this.period;
        data["attachments"] = this.attachments;
        data["isPublished"] = this.isPublished;
        data["reportDate"] = this.reportDate ? this.reportDate.toString() : undefined as any;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IImpactReport {
    id: number;
    title: string;
    description: string;
    category: string;
    metrics: string;
    period: string;
    attachments: string | undefined;
    isPublished: boolean;
    reportDate: DateTime;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class InitiatePaymentRequest implements IInitiatePaymentRequest {
    invoiceId!: string;
    amount!: number;
    provider!: PaymentGatewayProvider;
    returnUrl!: string | undefined;

    constructor(data?: IInitiatePaymentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            this.amount = _data["amount"];
            this.provider = _data["provider"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): InitiatePaymentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InitiatePaymentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["amount"] = this.amount;
        data["provider"] = this.provider;
        data["returnUrl"] = this.returnUrl;
        return data;
    }
}

export interface IInitiatePaymentRequest {
    invoiceId: string;
    amount: number;
    provider: PaymentGatewayProvider;
    returnUrl: string | undefined;
}

export class InspectionCheckpoint implements IInspectionCheckpoint {
    checkpoint!: string | undefined;
    status!: CheckpointStatus;
    readonly statusName!: string | undefined;
    notes!: string | undefined;

    constructor(data?: IInspectionCheckpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkpoint = _data["checkpoint"];
            this.status = _data["status"];
            (this as any).statusName = _data["statusName"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): InspectionCheckpoint {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionCheckpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkpoint"] = this.checkpoint;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IInspectionCheckpoint {
    checkpoint: string | undefined;
    status: CheckpointStatus;
    statusName: string | undefined;
    notes: string | undefined;
}

export class InspectionLogDto implements IInspectionLogDto {
    inspectionType!: InspectionType;
    checkpoints!: InspectionCheckpoint[] | undefined;
    overallResult!: InspectionResult;
    notes!: string | undefined;
    issuesFound!: boolean;
    issueDescription!: string | undefined;
    inspectorSignature!: string | undefined;

    constructor(data?: IInspectionLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inspectionType = _data["inspectionType"];
            if (Array.isArray(_data["checkpoints"])) {
                this.checkpoints = [] as any;
                for (let item of _data["checkpoints"])
                    this.checkpoints!.push(InspectionCheckpoint.fromJS(item));
            }
            this.overallResult = _data["overallResult"];
            this.notes = _data["notes"];
            this.issuesFound = _data["issuesFound"];
            this.issueDescription = _data["issueDescription"];
            this.inspectorSignature = _data["inspectorSignature"];
        }
    }

    static fromJS(data: any): InspectionLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspectionType"] = this.inspectionType;
        if (Array.isArray(this.checkpoints)) {
            data["checkpoints"] = [];
            for (let item of this.checkpoints)
                data["checkpoints"].push(item ? item.toJSON() : undefined as any);
        }
        data["overallResult"] = this.overallResult;
        data["notes"] = this.notes;
        data["issuesFound"] = this.issuesFound;
        data["issueDescription"] = this.issueDescription;
        data["inspectorSignature"] = this.inspectorSignature;
        return data;
    }
}

export interface IInspectionLogDto {
    inspectionType: InspectionType;
    checkpoints: InspectionCheckpoint[] | undefined;
    overallResult: InspectionResult;
    notes: string | undefined;
    issuesFound: boolean;
    issueDescription: string | undefined;
    inspectorSignature: string | undefined;
}

export enum InspectionResult {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum InspectionType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class Invoice implements IInvoice {
    id!: string;
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    memberId!: string | undefined;
    member!: Member;
    amountDue!: number;
    amountPaid!: number;
    dueDate!: DateTime;
    issueDate!: DateTime;
    status!: InvoiceStatus;
    isPaid!: boolean;
    invoiceNumber!: string | undefined;
    description!: string | undefined;
    payments!: Payment[] | undefined;
    tenantId!: string;
    tenant!: Tenant;
    paymentId!: string | undefined;
    payment!: Payment;
    subscriptionPlanId!: string | undefined;
    subscriptionPlan!: SubscriptionPlan;
    subtotalAmount!: number | undefined;
    discountAmount!: number | undefined;
    taxAmount!: number | undefined;
    currency!: string | undefined;
    paidDate!: DateTime | undefined;
    voidedAt!: DateTime | undefined;
    voidReason!: string | undefined;
    pdfUrl!: string | undefined;
    invoiceItems!: InvoiceItem[] | undefined;
    readonly totalAmount!: number;

    constructor(data?: IInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.memberId = _data["memberId"];
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : undefined as any;
            this.amountDue = _data["amountDue"];
            this.amountPaid = _data["amountPaid"];
            this.dueDate = _data["dueDate"] ? DateTime.fromISO(_data["dueDate"].toString()) : undefined as any;
            this.issueDate = _data["issueDate"] ? DateTime.fromISO(_data["issueDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.isPaid = _data["isPaid"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.description = _data["description"];
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments!.push(Payment.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : undefined as any;
            this.paymentId = _data["paymentId"];
            this.payment = _data["payment"] ? Payment.fromJS(_data["payment"]) : undefined as any;
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.subscriptionPlan = _data["subscriptionPlan"] ? SubscriptionPlan.fromJS(_data["subscriptionPlan"]) : undefined as any;
            this.subtotalAmount = _data["subtotalAmount"];
            this.discountAmount = _data["discountAmount"];
            this.taxAmount = _data["taxAmount"];
            this.currency = _data["currency"];
            this.paidDate = _data["paidDate"] ? DateTime.fromISO(_data["paidDate"].toString()) : undefined as any;
            this.voidedAt = _data["voidedAt"] ? DateTime.fromISO(_data["voidedAt"].toString()) : undefined as any;
            this.voidReason = _data["voidReason"];
            this.pdfUrl = _data["pdfUrl"];
            if (Array.isArray(_data["invoiceItems"])) {
                this.invoiceItems = [] as any;
                for (let item of _data["invoiceItems"])
                    this.invoiceItems!.push(InvoiceItem.fromJS(item));
            }
            (this as any).totalAmount = _data["totalAmount"];
        }
    }

    static fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["memberId"] = this.memberId;
        data["member"] = this.member ? this.member.toJSON() : undefined as any;
        data["amountDue"] = this.amountDue;
        data["amountPaid"] = this.amountPaid;
        data["dueDate"] = this.dueDate ? this.dueDate.toString() : undefined as any;
        data["issueDate"] = this.issueDate ? this.issueDate.toString() : undefined as any;
        data["status"] = this.status;
        data["isPaid"] = this.isPaid;
        data["invoiceNumber"] = this.invoiceNumber;
        data["description"] = this.description;
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item ? item.toJSON() : undefined as any);
        }
        data["tenantId"] = this.tenantId;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : undefined as any;
        data["paymentId"] = this.paymentId;
        data["payment"] = this.payment ? this.payment.toJSON() : undefined as any;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["subscriptionPlan"] = this.subscriptionPlan ? this.subscriptionPlan.toJSON() : undefined as any;
        data["subtotalAmount"] = this.subtotalAmount;
        data["discountAmount"] = this.discountAmount;
        data["taxAmount"] = this.taxAmount;
        data["currency"] = this.currency;
        data["paidDate"] = this.paidDate ? this.paidDate.toString() : undefined as any;
        data["voidedAt"] = this.voidedAt ? this.voidedAt.toString() : undefined as any;
        data["voidReason"] = this.voidReason;
        data["pdfUrl"] = this.pdfUrl;
        if (Array.isArray(this.invoiceItems)) {
            data["invoiceItems"] = [];
            for (let item of this.invoiceItems)
                data["invoiceItems"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalAmount"] = this.totalAmount;
        return data;
    }
}

export interface IInvoice {
    id: string;
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    memberId: string | undefined;
    member: Member;
    amountDue: number;
    amountPaid: number;
    dueDate: DateTime;
    issueDate: DateTime;
    status: InvoiceStatus;
    isPaid: boolean;
    invoiceNumber: string | undefined;
    description: string | undefined;
    payments: Payment[] | undefined;
    tenantId: string;
    tenant: Tenant;
    paymentId: string | undefined;
    payment: Payment;
    subscriptionPlanId: string | undefined;
    subscriptionPlan: SubscriptionPlan;
    subtotalAmount: number | undefined;
    discountAmount: number | undefined;
    taxAmount: number | undefined;
    currency: string | undefined;
    paidDate: DateTime | undefined;
    voidedAt: DateTime | undefined;
    voidReason: string | undefined;
    pdfUrl: string | undefined;
    invoiceItems: InvoiceItem[] | undefined;
    totalAmount: number;
}

export class InvoiceDto implements IInvoiceDto {
    id!: string;
    memberId!: string | undefined;
    amountDue!: number;
    amountPaid!: number;
    dueDate!: DateTime;
    issueDate!: DateTime;
    isPaid!: boolean;
    status!: string | undefined;
    invoiceNumber!: string | undefined;
    description!: string | undefined;
    tenantId!: string;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.amountDue = _data["amountDue"];
            this.amountPaid = _data["amountPaid"];
            this.dueDate = _data["dueDate"] ? DateTime.fromISO(_data["dueDate"].toString()) : undefined as any;
            this.issueDate = _data["issueDate"] ? DateTime.fromISO(_data["issueDate"].toString()) : undefined as any;
            this.isPaid = _data["isPaid"];
            this.status = _data["status"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["amountDue"] = this.amountDue;
        data["amountPaid"] = this.amountPaid;
        data["dueDate"] = this.dueDate ? this.dueDate.toString() : undefined as any;
        data["issueDate"] = this.issueDate ? this.issueDate.toString() : undefined as any;
        data["isPaid"] = this.isPaid;
        data["status"] = this.status;
        data["invoiceNumber"] = this.invoiceNumber;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IInvoiceDto {
    id: string;
    memberId: string | undefined;
    amountDue: number;
    amountPaid: number;
    dueDate: DateTime;
    issueDate: DateTime;
    isPaid: boolean;
    status: string | undefined;
    invoiceNumber: string | undefined;
    description: string | undefined;
    tenantId: string;
}

export class InvoiceItem implements IInvoiceItem {
    id!: string;
    invoiceId!: string;
    invoice!: Invoice;
    description!: string;
    quantity!: number;
    unitPrice!: number;
    amount!: number;
    taxRate!: number;
    taxAmount!: number;
    discountPercent!: number;
    itemType!: string | undefined;
    subscriptionPlanId!: string | undefined;
    billingPeriod!: string | undefined;
    createdAt!: DateTime;

    constructor(data?: IInvoiceItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : undefined as any;
            this.description = _data["description"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.amount = _data["amount"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountPercent = _data["discountPercent"];
            this.itemType = _data["itemType"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.billingPeriod = _data["billingPeriod"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): InvoiceItem {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : undefined as any;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["amount"] = this.amount;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountPercent"] = this.discountPercent;
        data["itemType"] = this.itemType;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["billingPeriod"] = this.billingPeriod;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        return data;
    }
}

export interface IInvoiceItem {
    id: string;
    invoiceId: string;
    invoice: Invoice;
    description: string;
    quantity: number;
    unitPrice: number;
    amount: number;
    taxRate: number;
    taxAmount: number;
    discountPercent: number;
    itemType: string | undefined;
    subscriptionPlanId: string | undefined;
    billingPeriod: string | undefined;
    createdAt: DateTime;
}

export enum InvoiceStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class JsonNode implements IJsonNode {
    options!: JsonNodeOptions;
    parent!: JsonNode;
    root!: JsonNode;

    constructor(data?: IJsonNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.options = _data["options"] ? JsonNodeOptions.fromJS(_data["options"]) : undefined as any;
            this.parent = _data["parent"] ? JsonNode.fromJS(_data["parent"]) : undefined as any;
            this.root = _data["root"] ? JsonNode.fromJS(_data["root"]) : undefined as any;
        }
    }

    static fromJS(data: any): JsonNode {
        data = typeof data === 'object' ? data : {};
        let result = new JsonNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["options"] = this.options ? this.options.toJSON() : undefined as any;
        data["parent"] = this.parent ? this.parent.toJSON() : undefined as any;
        data["root"] = this.root ? this.root.toJSON() : undefined as any;
        return data;
    }
}

export interface IJsonNode {
    options: JsonNodeOptions;
    parent: JsonNode;
    root: JsonNode;
}

export class JsonNodeOptions implements IJsonNodeOptions {
    propertyNameCaseInsensitive!: boolean;

    constructor(data?: IJsonNodeOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyNameCaseInsensitive = _data["propertyNameCaseInsensitive"];
        }
    }

    static fromJS(data: any): JsonNodeOptions {
        data = typeof data === 'object' ? data : {};
        let result = new JsonNodeOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyNameCaseInsensitive"] = this.propertyNameCaseInsensitive;
        return data;
    }
}

export interface IJsonNodeOptions {
    propertyNameCaseInsensitive: boolean;
}

export class LandingPageComponentDto implements ILandingPageComponentDto {
    id!: number | undefined;
    sortOrder!: number;
    componentType!: string | undefined;
    content!: JsonNode;
    column!: number;
    columnSpan!: number;
    row!: number;
    rowSpan!: number;
    fullWidth!: boolean;
    minHeight!: number | undefined;
    maxHeight!: number | undefined;
    padding!: number;
    margin!: number;
    backgroundColor!: string | undefined;
    borderRadius!: number;
    boxShadow!: string | undefined;
    zIndex!: number;
    responsiveConfig!: string | undefined;
    animationType!: string | undefined;
    animationDuration!: number;
    animationDelay!: number;
    animationEasing!: string | undefined;
    animationEnabled!: boolean;
    autoHeight!: boolean;
    hoverEffect!: string | undefined;

    constructor(data?: ILandingPageComponentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
            this.componentType = _data["componentType"];
            this.content = _data["content"] ? JsonNode.fromJS(_data["content"]) : undefined as any;
            this.column = _data["column"];
            this.columnSpan = _data["columnSpan"];
            this.row = _data["row"];
            this.rowSpan = _data["rowSpan"];
            this.fullWidth = _data["fullWidth"];
            this.minHeight = _data["minHeight"];
            this.maxHeight = _data["maxHeight"];
            this.padding = _data["padding"];
            this.margin = _data["margin"];
            this.backgroundColor = _data["backgroundColor"];
            this.borderRadius = _data["borderRadius"];
            this.boxShadow = _data["boxShadow"];
            this.zIndex = _data["zIndex"];
            this.responsiveConfig = _data["responsiveConfig"];
            this.animationType = _data["animationType"];
            this.animationDuration = _data["animationDuration"];
            this.animationDelay = _data["animationDelay"];
            this.animationEasing = _data["animationEasing"];
            this.animationEnabled = _data["animationEnabled"];
            this.autoHeight = _data["autoHeight"];
            this.hoverEffect = _data["hoverEffect"];
        }
    }

    static fromJS(data: any): LandingPageComponentDto {
        data = typeof data === 'object' ? data : {};
        let result = new LandingPageComponentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["componentType"] = this.componentType;
        data["content"] = this.content ? this.content.toJSON() : undefined as any;
        data["column"] = this.column;
        data["columnSpan"] = this.columnSpan;
        data["row"] = this.row;
        data["rowSpan"] = this.rowSpan;
        data["fullWidth"] = this.fullWidth;
        data["minHeight"] = this.minHeight;
        data["maxHeight"] = this.maxHeight;
        data["padding"] = this.padding;
        data["margin"] = this.margin;
        data["backgroundColor"] = this.backgroundColor;
        data["borderRadius"] = this.borderRadius;
        data["boxShadow"] = this.boxShadow;
        data["zIndex"] = this.zIndex;
        data["responsiveConfig"] = this.responsiveConfig;
        data["animationType"] = this.animationType;
        data["animationDuration"] = this.animationDuration;
        data["animationDelay"] = this.animationDelay;
        data["animationEasing"] = this.animationEasing;
        data["animationEnabled"] = this.animationEnabled;
        data["autoHeight"] = this.autoHeight;
        data["hoverEffect"] = this.hoverEffect;
        return data;
    }
}

export interface ILandingPageComponentDto {
    id: number | undefined;
    sortOrder: number;
    componentType: string | undefined;
    content: JsonNode;
    column: number;
    columnSpan: number;
    row: number;
    rowSpan: number;
    fullWidth: boolean;
    minHeight: number | undefined;
    maxHeight: number | undefined;
    padding: number;
    margin: number;
    backgroundColor: string | undefined;
    borderRadius: number;
    boxShadow: string | undefined;
    zIndex: number;
    responsiveConfig: string | undefined;
    animationType: string | undefined;
    animationDuration: number;
    animationDelay: number;
    animationEasing: string | undefined;
    animationEnabled: boolean;
    autoHeight: boolean;
    hoverEffect: string | undefined;
}

export class LandingPageDto implements ILandingPageDto {
    pageTitle!: string | undefined;
    metaDescription!: string | undefined;
    metaKeywords!: string | undefined;
    ogTitle!: string | undefined;
    ogDescription!: string | undefined;
    ogImage!: string | undefined;
    twitterCard!: string | undefined;
    canonicalUrl!: string | undefined;
    layouts!: LandingPageLayoutDto[] | undefined;

    constructor(data?: ILandingPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageTitle = _data["pageTitle"];
            this.metaDescription = _data["metaDescription"];
            this.metaKeywords = _data["metaKeywords"];
            this.ogTitle = _data["ogTitle"];
            this.ogDescription = _data["ogDescription"];
            this.ogImage = _data["ogImage"];
            this.twitterCard = _data["twitterCard"];
            this.canonicalUrl = _data["canonicalUrl"];
            if (Array.isArray(_data["layouts"])) {
                this.layouts = [] as any;
                for (let item of _data["layouts"])
                    this.layouts!.push(LandingPageLayoutDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LandingPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LandingPageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageTitle"] = this.pageTitle;
        data["metaDescription"] = this.metaDescription;
        data["metaKeywords"] = this.metaKeywords;
        data["ogTitle"] = this.ogTitle;
        data["ogDescription"] = this.ogDescription;
        data["ogImage"] = this.ogImage;
        data["twitterCard"] = this.twitterCard;
        data["canonicalUrl"] = this.canonicalUrl;
        if (Array.isArray(this.layouts)) {
            data["layouts"] = [];
            for (let item of this.layouts)
                data["layouts"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ILandingPageDto {
    pageTitle: string | undefined;
    metaDescription: string | undefined;
    metaKeywords: string | undefined;
    ogTitle: string | undefined;
    ogDescription: string | undefined;
    ogImage: string | undefined;
    twitterCard: string | undefined;
    canonicalUrl: string | undefined;
    layouts: LandingPageLayoutDto[] | undefined;
}

export class LandingPageLayoutDto implements ILandingPageLayoutDto {
    id!: number | undefined;
    sortOrder!: number;
    sectionType!: string | undefined;
    components!: LandingPageComponentDto[] | undefined;

    constructor(data?: ILandingPageLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
            this.sectionType = _data["sectionType"];
            if (Array.isArray(_data["components"])) {
                this.components = [] as any;
                for (let item of _data["components"])
                    this.components!.push(LandingPageComponentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LandingPageLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new LandingPageLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["sectionType"] = this.sectionType;
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ILandingPageLayoutDto {
    id: number | undefined;
    sortOrder: number;
    sectionType: string | undefined;
    components: LandingPageComponentDto[] | undefined;
}

export class LoginRequest implements ILoginRequest {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    email: string | undefined;
    password: string | undefined;
}

export class LookupDto implements ILookupDto {
    name!: string | undefined;
    value!: number;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface ILookupDto {
    name: string | undefined;
    value: number;
}

export class Member implements IMember {
    id!: string;
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    name!: string | undefined;
    address!: string | undefined;
    title!: string | undefined;
    firstNames!: string | undefined;
    surname!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    email!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    identificationNumber!: string | undefined;
    sourceOfIncome!: SourceOfIncome;
    sourceOfIncomeOther!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    province!: SouthAfricanProvince;
    postalCode!: string | undefined;
    isReplacingExistingPolicy!: boolean;
    existingPolicyNumber!: string | undefined;
    existingInsurerName!: string | undefined;
    existingPolicyPaidUpToDate!: boolean | undefined;
    existingPolicyWaitingPeriodExpired!: boolean | undefined;
    sameBenefitAsExistingPolicy!: boolean | undefined;
    benefitDifferenceNotes!: string | undefined;
    occupation!: string | undefined;
    workPhoneNumber!: string | undefined;
    passportNumber!: string | undefined;
    countryOfBirth!: string | undefined;
    countryOfResidence!: string | undefined;
    citizenship!: string | undefined;
    nationality!: string | undefined;
    isForeigner!: boolean;
    workPermitNumber!: string | undefined;
    status!: MemberStatus;
    paymentStatus!: PaymentStatus;
    nextPaymentDate!: DateTime | undefined;
    dependents!: Dependent[] | undefined;
    beneficiaries!: Beneficiary[] | undefined;
    policyEnrollments!: PolicyEnrollment[] | undefined;
    tenantId!: string;
    isIdVerified!: boolean;
    idVerifiedAt!: DateTime | undefined;
    isLifeVerified!: boolean;
    lifeVerifiedAt!: DateTime | undefined;
    signatureDataUrl!: string | undefined;
    signedAt!: DateTime | undefined;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.title = _data["title"];
            this.firstNames = _data["firstNames"];
            this.surname = _data["surname"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.email = _data["email"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.identificationNumber = _data["identificationNumber"];
            this.sourceOfIncome = _data["sourceOfIncome"];
            this.sourceOfIncomeOther = _data["sourceOfIncomeOther"];
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.isReplacingExistingPolicy = _data["isReplacingExistingPolicy"];
            this.existingPolicyNumber = _data["existingPolicyNumber"];
            this.existingInsurerName = _data["existingInsurerName"];
            this.existingPolicyPaidUpToDate = _data["existingPolicyPaidUpToDate"];
            this.existingPolicyWaitingPeriodExpired = _data["existingPolicyWaitingPeriodExpired"];
            this.sameBenefitAsExistingPolicy = _data["sameBenefitAsExistingPolicy"];
            this.benefitDifferenceNotes = _data["benefitDifferenceNotes"];
            this.occupation = _data["occupation"];
            this.workPhoneNumber = _data["workPhoneNumber"];
            this.passportNumber = _data["passportNumber"];
            this.countryOfBirth = _data["countryOfBirth"];
            this.countryOfResidence = _data["countryOfResidence"];
            this.citizenship = _data["citizenship"];
            this.nationality = _data["nationality"];
            this.isForeigner = _data["isForeigner"];
            this.workPermitNumber = _data["workPermitNumber"];
            this.status = _data["status"];
            this.paymentStatus = _data["paymentStatus"];
            this.nextPaymentDate = _data["nextPaymentDate"] ? DateTime.fromISO(_data["nextPaymentDate"].toString()) : undefined as any;
            if (Array.isArray(_data["dependents"])) {
                this.dependents = [] as any;
                for (let item of _data["dependents"])
                    this.dependents!.push(Dependent.fromJS(item));
            }
            if (Array.isArray(_data["beneficiaries"])) {
                this.beneficiaries = [] as any;
                for (let item of _data["beneficiaries"])
                    this.beneficiaries!.push(Beneficiary.fromJS(item));
            }
            if (Array.isArray(_data["policyEnrollments"])) {
                this.policyEnrollments = [] as any;
                for (let item of _data["policyEnrollments"])
                    this.policyEnrollments!.push(PolicyEnrollment.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.isIdVerified = _data["isIdVerified"];
            this.idVerifiedAt = _data["idVerifiedAt"] ? DateTime.fromISO(_data["idVerifiedAt"].toString()) : undefined as any;
            this.isLifeVerified = _data["isLifeVerified"];
            this.lifeVerifiedAt = _data["lifeVerifiedAt"] ? DateTime.fromISO(_data["lifeVerifiedAt"].toString()) : undefined as any;
            this.signatureDataUrl = _data["signatureDataUrl"];
            this.signedAt = _data["signedAt"] ? DateTime.fromISO(_data["signedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["name"] = this.name;
        data["address"] = this.address;
        data["title"] = this.title;
        data["firstNames"] = this.firstNames;
        data["surname"] = this.surname;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["email"] = this.email;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["identificationNumber"] = this.identificationNumber;
        data["sourceOfIncome"] = this.sourceOfIncome;
        data["sourceOfIncomeOther"] = this.sourceOfIncomeOther;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["isReplacingExistingPolicy"] = this.isReplacingExistingPolicy;
        data["existingPolicyNumber"] = this.existingPolicyNumber;
        data["existingInsurerName"] = this.existingInsurerName;
        data["existingPolicyPaidUpToDate"] = this.existingPolicyPaidUpToDate;
        data["existingPolicyWaitingPeriodExpired"] = this.existingPolicyWaitingPeriodExpired;
        data["sameBenefitAsExistingPolicy"] = this.sameBenefitAsExistingPolicy;
        data["benefitDifferenceNotes"] = this.benefitDifferenceNotes;
        data["occupation"] = this.occupation;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["passportNumber"] = this.passportNumber;
        data["countryOfBirth"] = this.countryOfBirth;
        data["countryOfResidence"] = this.countryOfResidence;
        data["citizenship"] = this.citizenship;
        data["nationality"] = this.nationality;
        data["isForeigner"] = this.isForeigner;
        data["workPermitNumber"] = this.workPermitNumber;
        data["status"] = this.status;
        data["paymentStatus"] = this.paymentStatus;
        data["nextPaymentDate"] = this.nextPaymentDate ? this.nextPaymentDate.toString() : undefined as any;
        if (Array.isArray(this.dependents)) {
            data["dependents"] = [];
            for (let item of this.dependents)
                data["dependents"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.beneficiaries)) {
            data["beneficiaries"] = [];
            for (let item of this.beneficiaries)
                data["beneficiaries"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.policyEnrollments)) {
            data["policyEnrollments"] = [];
            for (let item of this.policyEnrollments)
                data["policyEnrollments"].push(item ? item.toJSON() : undefined as any);
        }
        data["tenantId"] = this.tenantId;
        data["isIdVerified"] = this.isIdVerified;
        data["idVerifiedAt"] = this.idVerifiedAt ? this.idVerifiedAt.toString() : undefined as any;
        data["isLifeVerified"] = this.isLifeVerified;
        data["lifeVerifiedAt"] = this.lifeVerifiedAt ? this.lifeVerifiedAt.toString() : undefined as any;
        data["signatureDataUrl"] = this.signatureDataUrl;
        data["signedAt"] = this.signedAt ? this.signedAt.toString() : undefined as any;
        return data;
    }
}

export interface IMember {
    id: string;
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    name: string | undefined;
    address: string | undefined;
    title: string | undefined;
    firstNames: string | undefined;
    surname: string | undefined;
    dateOfBirth: DateTime | undefined;
    email: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    identificationNumber: string | undefined;
    sourceOfIncome: SourceOfIncome;
    sourceOfIncomeOther: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    province: SouthAfricanProvince;
    postalCode: string | undefined;
    isReplacingExistingPolicy: boolean;
    existingPolicyNumber: string | undefined;
    existingInsurerName: string | undefined;
    existingPolicyPaidUpToDate: boolean | undefined;
    existingPolicyWaitingPeriodExpired: boolean | undefined;
    sameBenefitAsExistingPolicy: boolean | undefined;
    benefitDifferenceNotes: string | undefined;
    occupation: string | undefined;
    workPhoneNumber: string | undefined;
    passportNumber: string | undefined;
    countryOfBirth: string | undefined;
    countryOfResidence: string | undefined;
    citizenship: string | undefined;
    nationality: string | undefined;
    isForeigner: boolean;
    workPermitNumber: string | undefined;
    status: MemberStatus;
    paymentStatus: PaymentStatus;
    nextPaymentDate: DateTime | undefined;
    dependents: Dependent[] | undefined;
    beneficiaries: Beneficiary[] | undefined;
    policyEnrollments: PolicyEnrollment[] | undefined;
    tenantId: string;
    isIdVerified: boolean;
    idVerifiedAt: DateTime | undefined;
    isLifeVerified: boolean;
    lifeVerifiedAt: DateTime | undefined;
    signatureDataUrl: string | undefined;
    signedAt: DateTime | undefined;
}

export class MemberApprovalDetailDto implements IMemberApprovalDetailDto {
    id!: string;
    title!: string | undefined;
    firstNames!: string | undefined;
    surname!: string | undefined;
    identificationNumber!: string | undefined;
    email!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    age!: number | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    postalCode!: string | undefined;
    sourceOfIncome!: string | undefined;
    sourceOfIncomeOther!: string | undefined;
    occupation!: string | undefined;
    workPhoneNumber!: string | undefined;
    nationality!: string | undefined;
    countryOfResidence!: string | undefined;
    isForeigner!: boolean;
    passportNumber!: string | undefined;
    workPermitNumber!: string | undefined;
    isReplacingExistingPolicy!: boolean;
    existingPolicyNumber!: string | undefined;
    existingInsurerName!: string | undefined;
    isIdVerified!: boolean;
    idVerifiedAt!: DateTime | undefined;
    isLifeVerified!: boolean;
    lifeVerifiedAt!: DateTime | undefined;
    signatureDataUrl!: string | undefined;
    signedAt!: DateTime | undefined;
    status!: string | undefined;
    createdDate!: DateTime | undefined;
    daysWaiting!: number;
    policyEnrollments!: PolicyEnrollmentSummary[] | undefined;
    dependents!: DependentSummary[] | undefined;
    beneficiaries!: BeneficiarySummary[] | undefined;
    customFields!: OnboardingFieldData[] | undefined;

    constructor(data?: IMemberApprovalDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.firstNames = _data["firstNames"];
            this.surname = _data["surname"];
            this.identificationNumber = _data["identificationNumber"];
            this.email = _data["email"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.age = _data["age"];
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.sourceOfIncome = _data["sourceOfIncome"];
            this.sourceOfIncomeOther = _data["sourceOfIncomeOther"];
            this.occupation = _data["occupation"];
            this.workPhoneNumber = _data["workPhoneNumber"];
            this.nationality = _data["nationality"];
            this.countryOfResidence = _data["countryOfResidence"];
            this.isForeigner = _data["isForeigner"];
            this.passportNumber = _data["passportNumber"];
            this.workPermitNumber = _data["workPermitNumber"];
            this.isReplacingExistingPolicy = _data["isReplacingExistingPolicy"];
            this.existingPolicyNumber = _data["existingPolicyNumber"];
            this.existingInsurerName = _data["existingInsurerName"];
            this.isIdVerified = _data["isIdVerified"];
            this.idVerifiedAt = _data["idVerifiedAt"] ? DateTime.fromISO(_data["idVerifiedAt"].toString()) : undefined as any;
            this.isLifeVerified = _data["isLifeVerified"];
            this.lifeVerifiedAt = _data["lifeVerifiedAt"] ? DateTime.fromISO(_data["lifeVerifiedAt"].toString()) : undefined as any;
            this.signatureDataUrl = _data["signatureDataUrl"];
            this.signedAt = _data["signedAt"] ? DateTime.fromISO(_data["signedAt"].toString()) : undefined as any;
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? DateTime.fromISO(_data["createdDate"].toString()) : undefined as any;
            this.daysWaiting = _data["daysWaiting"];
            if (Array.isArray(_data["policyEnrollments"])) {
                this.policyEnrollments = [] as any;
                for (let item of _data["policyEnrollments"])
                    this.policyEnrollments!.push(PolicyEnrollmentSummary.fromJS(item));
            }
            if (Array.isArray(_data["dependents"])) {
                this.dependents = [] as any;
                for (let item of _data["dependents"])
                    this.dependents!.push(DependentSummary.fromJS(item));
            }
            if (Array.isArray(_data["beneficiaries"])) {
                this.beneficiaries = [] as any;
                for (let item of _data["beneficiaries"])
                    this.beneficiaries!.push(BeneficiarySummary.fromJS(item));
            }
            if (Array.isArray(_data["customFields"])) {
                this.customFields = [] as any;
                for (let item of _data["customFields"])
                    this.customFields!.push(OnboardingFieldData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberApprovalDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberApprovalDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["firstNames"] = this.firstNames;
        data["surname"] = this.surname;
        data["identificationNumber"] = this.identificationNumber;
        data["email"] = this.email;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["age"] = this.age;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["sourceOfIncome"] = this.sourceOfIncome;
        data["sourceOfIncomeOther"] = this.sourceOfIncomeOther;
        data["occupation"] = this.occupation;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["nationality"] = this.nationality;
        data["countryOfResidence"] = this.countryOfResidence;
        data["isForeigner"] = this.isForeigner;
        data["passportNumber"] = this.passportNumber;
        data["workPermitNumber"] = this.workPermitNumber;
        data["isReplacingExistingPolicy"] = this.isReplacingExistingPolicy;
        data["existingPolicyNumber"] = this.existingPolicyNumber;
        data["existingInsurerName"] = this.existingInsurerName;
        data["isIdVerified"] = this.isIdVerified;
        data["idVerifiedAt"] = this.idVerifiedAt ? this.idVerifiedAt.toString() : undefined as any;
        data["isLifeVerified"] = this.isLifeVerified;
        data["lifeVerifiedAt"] = this.lifeVerifiedAt ? this.lifeVerifiedAt.toString() : undefined as any;
        data["signatureDataUrl"] = this.signatureDataUrl;
        data["signedAt"] = this.signedAt ? this.signedAt.toString() : undefined as any;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toString() : undefined as any;
        data["daysWaiting"] = this.daysWaiting;
        if (Array.isArray(this.policyEnrollments)) {
            data["policyEnrollments"] = [];
            for (let item of this.policyEnrollments)
                data["policyEnrollments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.dependents)) {
            data["dependents"] = [];
            for (let item of this.dependents)
                data["dependents"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.beneficiaries)) {
            data["beneficiaries"] = [];
            for (let item of this.beneficiaries)
                data["beneficiaries"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.customFields)) {
            data["customFields"] = [];
            for (let item of this.customFields)
                data["customFields"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IMemberApprovalDetailDto {
    id: string;
    title: string | undefined;
    firstNames: string | undefined;
    surname: string | undefined;
    identificationNumber: string | undefined;
    email: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    dateOfBirth: DateTime | undefined;
    age: number | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    province: string | undefined;
    postalCode: string | undefined;
    sourceOfIncome: string | undefined;
    sourceOfIncomeOther: string | undefined;
    occupation: string | undefined;
    workPhoneNumber: string | undefined;
    nationality: string | undefined;
    countryOfResidence: string | undefined;
    isForeigner: boolean;
    passportNumber: string | undefined;
    workPermitNumber: string | undefined;
    isReplacingExistingPolicy: boolean;
    existingPolicyNumber: string | undefined;
    existingInsurerName: string | undefined;
    isIdVerified: boolean;
    idVerifiedAt: DateTime | undefined;
    isLifeVerified: boolean;
    lifeVerifiedAt: DateTime | undefined;
    signatureDataUrl: string | undefined;
    signedAt: DateTime | undefined;
    status: string | undefined;
    createdDate: DateTime | undefined;
    daysWaiting: number;
    policyEnrollments: PolicyEnrollmentSummary[] | undefined;
    dependents: DependentSummary[] | undefined;
    beneficiaries: BeneficiarySummary[] | undefined;
    customFields: OnboardingFieldData[] | undefined;
}

export class MemberBankingDetailDto implements IMemberBankingDetailDto {
    id!: string;
    memberId!: string;
    bankName!: string | undefined;
    accountNumber!: string | undefined;
    accountType!: string | undefined;
    branchCode!: string | undefined;
    branchName!: string | undefined;
    accountHolderName!: string | undefined;
    debitDay!: number | undefined;
    paymentMethod!: PaymentMethodType;
    isVerified!: boolean;
    createdAt!: DateTime;

    constructor(data?: IMemberBankingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.accountType = _data["accountType"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.accountHolderName = _data["accountHolderName"];
            this.debitDay = _data["debitDay"];
            this.paymentMethod = _data["paymentMethod"];
            this.isVerified = _data["isVerified"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): MemberBankingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberBankingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["accountType"] = this.accountType;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["accountHolderName"] = this.accountHolderName;
        data["debitDay"] = this.debitDay;
        data["paymentMethod"] = this.paymentMethod;
        data["isVerified"] = this.isVerified;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        return data;
    }
}

export interface IMemberBankingDetailDto {
    id: string;
    memberId: string;
    bankName: string | undefined;
    accountNumber: string | undefined;
    accountType: string | undefined;
    branchCode: string | undefined;
    branchName: string | undefined;
    accountHolderName: string | undefined;
    debitDay: number | undefined;
    paymentMethod: PaymentMethodType;
    isVerified: boolean;
    createdAt: DateTime;
}

export class MemberDocumentStatusDto implements IMemberDocumentStatusDto {
    memberId!: string;
    requiredDocuments!: RequiredDocumentDto[] | undefined;
    uploadedDocuments!: FileMetadataDto[] | undefined;
    missingDocuments!: RequiredDocumentDto[] | undefined;
    allRequiredDocumentsUploaded!: boolean;

    constructor(data?: IMemberDocumentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            if (Array.isArray(_data["requiredDocuments"])) {
                this.requiredDocuments = [] as any;
                for (let item of _data["requiredDocuments"])
                    this.requiredDocuments!.push(RequiredDocumentDto.fromJS(item));
            }
            if (Array.isArray(_data["uploadedDocuments"])) {
                this.uploadedDocuments = [] as any;
                for (let item of _data["uploadedDocuments"])
                    this.uploadedDocuments!.push(FileMetadataDto.fromJS(item));
            }
            if (Array.isArray(_data["missingDocuments"])) {
                this.missingDocuments = [] as any;
                for (let item of _data["missingDocuments"])
                    this.missingDocuments!.push(RequiredDocumentDto.fromJS(item));
            }
            this.allRequiredDocumentsUploaded = _data["allRequiredDocumentsUploaded"];
        }
    }

    static fromJS(data: any): MemberDocumentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDocumentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        if (Array.isArray(this.requiredDocuments)) {
            data["requiredDocuments"] = [];
            for (let item of this.requiredDocuments)
                data["requiredDocuments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.uploadedDocuments)) {
            data["uploadedDocuments"] = [];
            for (let item of this.uploadedDocuments)
                data["uploadedDocuments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.missingDocuments)) {
            data["missingDocuments"] = [];
            for (let item of this.missingDocuments)
                data["missingDocuments"].push(item ? item.toJSON() : undefined as any);
        }
        data["allRequiredDocumentsUploaded"] = this.allRequiredDocumentsUploaded;
        return data;
    }
}

export interface IMemberDocumentStatusDto {
    memberId: string;
    requiredDocuments: RequiredDocumentDto[] | undefined;
    uploadedDocuments: FileMetadataDto[] | undefined;
    missingDocuments: RequiredDocumentDto[] | undefined;
    allRequiredDocumentsUploaded: boolean;
}

export enum MemberDocumentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _99 = 99,
}

export class MemberDto implements IMemberDto {
    id!: string;
    name!: string | undefined;
    address!: string | undefined;
    title!: string | undefined;
    firstNames!: string | undefined;
    surname!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    email!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    identificationNumber!: string | undefined;
    sourceOfIncome!: SourceOfIncome;
    sourceOfIncomeOther!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    province!: SouthAfricanProvince;
    postalCode!: string | undefined;
    isReplacingExistingPolicy!: boolean;
    existingPolicyNumber!: string | undefined;
    existingInsurerName!: string | undefined;
    existingPolicyPaidUpToDate!: boolean | undefined;
    existingPolicyWaitingPeriodExpired!: boolean | undefined;
    sameBenefitAsExistingPolicy!: boolean | undefined;
    benefitDifferenceNotes!: string | undefined;
    occupation!: string | undefined;
    workPhoneNumber!: string | undefined;
    passportNumber!: string | undefined;
    countryOfBirth!: string | undefined;
    countryOfResidence!: string | undefined;
    citizenship!: string | undefined;
    nationality!: string | undefined;
    isForeigner!: boolean;
    workPermitNumber!: string | undefined;
    status!: MemberStatus;
    paymentStatus!: PaymentStatus;
    nextPaymentDate!: DateTime | undefined;
    signatureDataUrl!: string | undefined;
    signedAt!: DateTime | undefined;
    dependents!: DependentDto[] | undefined;
    beneficiaries!: BeneficiaryDto[] | undefined;
    policyEnrollments!: PolicyEnrollmentDto[] | undefined;

    constructor(data?: IMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.title = _data["title"];
            this.firstNames = _data["firstNames"];
            this.surname = _data["surname"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.email = _data["email"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.identificationNumber = _data["identificationNumber"];
            this.sourceOfIncome = _data["sourceOfIncome"];
            this.sourceOfIncomeOther = _data["sourceOfIncomeOther"];
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.isReplacingExistingPolicy = _data["isReplacingExistingPolicy"];
            this.existingPolicyNumber = _data["existingPolicyNumber"];
            this.existingInsurerName = _data["existingInsurerName"];
            this.existingPolicyPaidUpToDate = _data["existingPolicyPaidUpToDate"];
            this.existingPolicyWaitingPeriodExpired = _data["existingPolicyWaitingPeriodExpired"];
            this.sameBenefitAsExistingPolicy = _data["sameBenefitAsExistingPolicy"];
            this.benefitDifferenceNotes = _data["benefitDifferenceNotes"];
            this.occupation = _data["occupation"];
            this.workPhoneNumber = _data["workPhoneNumber"];
            this.passportNumber = _data["passportNumber"];
            this.countryOfBirth = _data["countryOfBirth"];
            this.countryOfResidence = _data["countryOfResidence"];
            this.citizenship = _data["citizenship"];
            this.nationality = _data["nationality"];
            this.isForeigner = _data["isForeigner"];
            this.workPermitNumber = _data["workPermitNumber"];
            this.status = _data["status"];
            this.paymentStatus = _data["paymentStatus"];
            this.nextPaymentDate = _data["nextPaymentDate"] ? DateTime.fromISO(_data["nextPaymentDate"].toString()) : undefined as any;
            this.signatureDataUrl = _data["signatureDataUrl"];
            this.signedAt = _data["signedAt"] ? DateTime.fromISO(_data["signedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["dependents"])) {
                this.dependents = [] as any;
                for (let item of _data["dependents"])
                    this.dependents!.push(DependentDto.fromJS(item));
            }
            if (Array.isArray(_data["beneficiaries"])) {
                this.beneficiaries = [] as any;
                for (let item of _data["beneficiaries"])
                    this.beneficiaries!.push(BeneficiaryDto.fromJS(item));
            }
            if (Array.isArray(_data["policyEnrollments"])) {
                this.policyEnrollments = [] as any;
                for (let item of _data["policyEnrollments"])
                    this.policyEnrollments!.push(PolicyEnrollmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address;
        data["title"] = this.title;
        data["firstNames"] = this.firstNames;
        data["surname"] = this.surname;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["email"] = this.email;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["identificationNumber"] = this.identificationNumber;
        data["sourceOfIncome"] = this.sourceOfIncome;
        data["sourceOfIncomeOther"] = this.sourceOfIncomeOther;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["isReplacingExistingPolicy"] = this.isReplacingExistingPolicy;
        data["existingPolicyNumber"] = this.existingPolicyNumber;
        data["existingInsurerName"] = this.existingInsurerName;
        data["existingPolicyPaidUpToDate"] = this.existingPolicyPaidUpToDate;
        data["existingPolicyWaitingPeriodExpired"] = this.existingPolicyWaitingPeriodExpired;
        data["sameBenefitAsExistingPolicy"] = this.sameBenefitAsExistingPolicy;
        data["benefitDifferenceNotes"] = this.benefitDifferenceNotes;
        data["occupation"] = this.occupation;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["passportNumber"] = this.passportNumber;
        data["countryOfBirth"] = this.countryOfBirth;
        data["countryOfResidence"] = this.countryOfResidence;
        data["citizenship"] = this.citizenship;
        data["nationality"] = this.nationality;
        data["isForeigner"] = this.isForeigner;
        data["workPermitNumber"] = this.workPermitNumber;
        data["status"] = this.status;
        data["paymentStatus"] = this.paymentStatus;
        data["nextPaymentDate"] = this.nextPaymentDate ? this.nextPaymentDate.toString() : undefined as any;
        data["signatureDataUrl"] = this.signatureDataUrl;
        data["signedAt"] = this.signedAt ? this.signedAt.toString() : undefined as any;
        if (Array.isArray(this.dependents)) {
            data["dependents"] = [];
            for (let item of this.dependents)
                data["dependents"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.beneficiaries)) {
            data["beneficiaries"] = [];
            for (let item of this.beneficiaries)
                data["beneficiaries"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.policyEnrollments)) {
            data["policyEnrollments"] = [];
            for (let item of this.policyEnrollments)
                data["policyEnrollments"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IMemberDto {
    id: string;
    name: string | undefined;
    address: string | undefined;
    title: string | undefined;
    firstNames: string | undefined;
    surname: string | undefined;
    dateOfBirth: DateTime | undefined;
    email: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    identificationNumber: string | undefined;
    sourceOfIncome: SourceOfIncome;
    sourceOfIncomeOther: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    province: SouthAfricanProvince;
    postalCode: string | undefined;
    isReplacingExistingPolicy: boolean;
    existingPolicyNumber: string | undefined;
    existingInsurerName: string | undefined;
    existingPolicyPaidUpToDate: boolean | undefined;
    existingPolicyWaitingPeriodExpired: boolean | undefined;
    sameBenefitAsExistingPolicy: boolean | undefined;
    benefitDifferenceNotes: string | undefined;
    occupation: string | undefined;
    workPhoneNumber: string | undefined;
    passportNumber: string | undefined;
    countryOfBirth: string | undefined;
    countryOfResidence: string | undefined;
    citizenship: string | undefined;
    nationality: string | undefined;
    isForeigner: boolean;
    workPermitNumber: string | undefined;
    status: MemberStatus;
    paymentStatus: PaymentStatus;
    nextPaymentDate: DateTime | undefined;
    signatureDataUrl: string | undefined;
    signedAt: DateTime | undefined;
    dependents: DependentDto[] | undefined;
    beneficiaries: BeneficiaryDto[] | undefined;
    policyEnrollments: PolicyEnrollmentDto[] | undefined;
}

export class MemberOnboardingDataDto implements IMemberOnboardingDataDto {
    memberId!: string;
    tenantId!: string;
    fieldValues!: { [key: string]: string; } | undefined;
    submittedAt!: DateTime | undefined;

    constructor(data?: IMemberOnboardingDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.tenantId = _data["tenantId"];
            if (_data["fieldValues"]) {
                this.fieldValues = {} as any;
                for (let key in _data["fieldValues"]) {
                    if (_data["fieldValues"].hasOwnProperty(key))
                        (this.fieldValues as any)![key] = _data["fieldValues"][key];
                }
            }
            this.submittedAt = _data["submittedAt"] ? DateTime.fromISO(_data["submittedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): MemberOnboardingDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberOnboardingDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["tenantId"] = this.tenantId;
        if (this.fieldValues) {
            data["fieldValues"] = {};
            for (let key in this.fieldValues) {
                if (this.fieldValues.hasOwnProperty(key))
                    (data["fieldValues"] as any)[key] = (this.fieldValues as any)[key];
            }
        }
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toString() : undefined as any;
        return data;
    }
}

export interface IMemberOnboardingDataDto {
    memberId: string;
    tenantId: string;
    fieldValues: { [key: string]: string; } | undefined;
    submittedAt: DateTime | undefined;
}

export class MemberProfileCompletionDto implements IMemberProfileCompletionDto {
    id!: string;
    memberId!: string;
    hasDependents!: boolean;
    hasBeneficiaries!: boolean;
    hasUploadedIdDocument!: boolean;
    hasAcceptedTerms!: boolean;
    hasCompletedCustomForms!: boolean;
    hasUploadedRequiredDocuments!: boolean;
    isProfileComplete!: boolean;
    profileCompletedAt!: DateTime | undefined;
    completionPercentage!: number;
    nextStepRecommendation!: string | undefined;

    constructor(data?: IMemberProfileCompletionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.hasDependents = _data["hasDependents"];
            this.hasBeneficiaries = _data["hasBeneficiaries"];
            this.hasUploadedIdDocument = _data["hasUploadedIdDocument"];
            this.hasAcceptedTerms = _data["hasAcceptedTerms"];
            this.hasCompletedCustomForms = _data["hasCompletedCustomForms"];
            this.hasUploadedRequiredDocuments = _data["hasUploadedRequiredDocuments"];
            this.isProfileComplete = _data["isProfileComplete"];
            this.profileCompletedAt = _data["profileCompletedAt"] ? DateTime.fromISO(_data["profileCompletedAt"].toString()) : undefined as any;
            this.completionPercentage = _data["completionPercentage"];
            this.nextStepRecommendation = _data["nextStepRecommendation"];
        }
    }

    static fromJS(data: any): MemberProfileCompletionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberProfileCompletionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["hasDependents"] = this.hasDependents;
        data["hasBeneficiaries"] = this.hasBeneficiaries;
        data["hasUploadedIdDocument"] = this.hasUploadedIdDocument;
        data["hasAcceptedTerms"] = this.hasAcceptedTerms;
        data["hasCompletedCustomForms"] = this.hasCompletedCustomForms;
        data["hasUploadedRequiredDocuments"] = this.hasUploadedRequiredDocuments;
        data["isProfileComplete"] = this.isProfileComplete;
        data["profileCompletedAt"] = this.profileCompletedAt ? this.profileCompletedAt.toString() : undefined as any;
        data["completionPercentage"] = this.completionPercentage;
        data["nextStepRecommendation"] = this.nextStepRecommendation;
        return data;
    }
}

export interface IMemberProfileCompletionDto {
    id: string;
    memberId: string;
    hasDependents: boolean;
    hasBeneficiaries: boolean;
    hasUploadedIdDocument: boolean;
    hasAcceptedTerms: boolean;
    hasCompletedCustomForms: boolean;
    hasUploadedRequiredDocuments: boolean;
    isProfileComplete: boolean;
    profileCompletedAt: DateTime | undefined;
    completionPercentage: number;
    nextStepRecommendation: string | undefined;
}

export enum MemberStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class NgoBlogPost implements INgoBlogPost {
    id!: number;
    title!: string;
    content!: string;
    excerpt!: string | undefined;
    author!: string;
    publishDate!: DateTime;
    category!: string;
    tags!: string | undefined;
    featuredImage!: string | undefined;
    status!: string;
    viewCount!: number;
    seoTitle!: string | undefined;
    seoDescription!: string | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: INgoBlogPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.excerpt = _data["excerpt"];
            this.author = _data["author"];
            this.publishDate = _data["publishDate"] ? DateTime.fromISO(_data["publishDate"].toString()) : undefined as any;
            this.category = _data["category"];
            this.tags = _data["tags"];
            this.featuredImage = _data["featuredImage"];
            this.status = _data["status"];
            this.viewCount = _data["viewCount"];
            this.seoTitle = _data["seoTitle"];
            this.seoDescription = _data["seoDescription"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): NgoBlogPost {
        data = typeof data === 'object' ? data : {};
        let result = new NgoBlogPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["excerpt"] = this.excerpt;
        data["author"] = this.author;
        data["publishDate"] = this.publishDate ? this.publishDate.toString() : undefined as any;
        data["category"] = this.category;
        data["tags"] = this.tags;
        data["featuredImage"] = this.featuredImage;
        data["status"] = this.status;
        data["viewCount"] = this.viewCount;
        data["seoTitle"] = this.seoTitle;
        data["seoDescription"] = this.seoDescription;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface INgoBlogPost {
    id: number;
    title: string;
    content: string;
    excerpt: string | undefined;
    author: string;
    publishDate: DateTime;
    category: string;
    tags: string | undefined;
    featuredImage: string | undefined;
    status: string;
    viewCount: number;
    seoTitle: string | undefined;
    seoDescription: string | undefined;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class NgoEvent implements INgoEvent {
    id!: number;
    title!: string;
    description!: string;
    startDate!: DateTime;
    endDate!: DateTime;
    location!: string;
    category!: string;
    maxAttendees!: number;
    currentAttendees!: number;
    registrationRequired!: boolean;
    registrationDeadline!: DateTime | undefined;
    imageUrl!: string | undefined;
    status!: string;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: INgoEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : undefined as any;
            this.location = _data["location"];
            this.category = _data["category"];
            this.maxAttendees = _data["maxAttendees"];
            this.currentAttendees = _data["currentAttendees"];
            this.registrationRequired = _data["registrationRequired"];
            this.registrationDeadline = _data["registrationDeadline"] ? DateTime.fromISO(_data["registrationDeadline"].toString()) : undefined as any;
            this.imageUrl = _data["imageUrl"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): NgoEvent {
        data = typeof data === 'object' ? data : {};
        let result = new NgoEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toString() : undefined as any;
        data["location"] = this.location;
        data["category"] = this.category;
        data["maxAttendees"] = this.maxAttendees;
        data["currentAttendees"] = this.currentAttendees;
        data["registrationRequired"] = this.registrationRequired;
        data["registrationDeadline"] = this.registrationDeadline ? this.registrationDeadline.toString() : undefined as any;
        data["imageUrl"] = this.imageUrl;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface INgoEvent {
    id: number;
    title: string;
    description: string;
    startDate: DateTime;
    endDate: DateTime;
    location: string;
    category: string;
    maxAttendees: number;
    currentAttendees: number;
    registrationRequired: boolean;
    registrationDeadline: DateTime | undefined;
    imageUrl: string | undefined;
    status: string;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class OnboardingContractDto implements IOnboardingContractDto {
    id!: string;
    tenantId!: string;
    memberId!: string;
    templateFileId!: string | undefined;
    generatedPdfPath!: string | undefined;
    signedPdfPath!: string | undefined;
    signatureImagePath!: string | undefined;
    ipAddress!: string | undefined;
    signedAt!: DateTime | undefined;
    isLegallyBinding!: boolean;
    documentHash!: string | undefined;
    signedDocumentHash!: string | undefined;

    constructor(data?: IOnboardingContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.memberId = _data["memberId"];
            this.templateFileId = _data["templateFileId"];
            this.generatedPdfPath = _data["generatedPdfPath"];
            this.signedPdfPath = _data["signedPdfPath"];
            this.signatureImagePath = _data["signatureImagePath"];
            this.ipAddress = _data["ipAddress"];
            this.signedAt = _data["signedAt"] ? DateTime.fromISO(_data["signedAt"].toString()) : undefined as any;
            this.isLegallyBinding = _data["isLegallyBinding"];
            this.documentHash = _data["documentHash"];
            this.signedDocumentHash = _data["signedDocumentHash"];
        }
    }

    static fromJS(data: any): OnboardingContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["memberId"] = this.memberId;
        data["templateFileId"] = this.templateFileId;
        data["generatedPdfPath"] = this.generatedPdfPath;
        data["signedPdfPath"] = this.signedPdfPath;
        data["signatureImagePath"] = this.signatureImagePath;
        data["ipAddress"] = this.ipAddress;
        data["signedAt"] = this.signedAt ? this.signedAt.toString() : undefined as any;
        data["isLegallyBinding"] = this.isLegallyBinding;
        data["documentHash"] = this.documentHash;
        data["signedDocumentHash"] = this.signedDocumentHash;
        return data;
    }
}

export interface IOnboardingContractDto {
    id: string;
    tenantId: string;
    memberId: string;
    templateFileId: string | undefined;
    generatedPdfPath: string | undefined;
    signedPdfPath: string | undefined;
    signatureImagePath: string | undefined;
    ipAddress: string | undefined;
    signedAt: DateTime | undefined;
    isLegallyBinding: boolean;
    documentHash: string | undefined;
    signedDocumentHash: string | undefined;
}

export class OnboardingFieldConfigurationDto implements IOnboardingFieldConfigurationDto {
    id!: string;
    tenantId!: string;
    fieldContext!: string | undefined;
    fieldKey!: string | undefined;
    fieldLabel!: string | undefined;
    fieldType!: string | undefined;
    category!: string | undefined;
    isRequired!: boolean;
    isEnabled!: boolean;
    displayOrder!: number;
    placeholder!: string | undefined;
    helpText!: string | undefined;
    optionsJson!: string | undefined;
    validationRulesJson!: string | undefined;
    defaultValue!: string | undefined;
    maxLength!: number | undefined;
    minLength!: number | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime | undefined;

    constructor(data?: IOnboardingFieldConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fieldContext = _data["fieldContext"];
            this.fieldKey = _data["fieldKey"];
            this.fieldLabel = _data["fieldLabel"];
            this.fieldType = _data["fieldType"];
            this.category = _data["category"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.placeholder = _data["placeholder"];
            this.helpText = _data["helpText"];
            this.optionsJson = _data["optionsJson"];
            this.validationRulesJson = _data["validationRulesJson"];
            this.defaultValue = _data["defaultValue"];
            this.maxLength = _data["maxLength"];
            this.minLength = _data["minLength"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): OnboardingFieldConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingFieldConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fieldContext"] = this.fieldContext;
        data["fieldKey"] = this.fieldKey;
        data["fieldLabel"] = this.fieldLabel;
        data["fieldType"] = this.fieldType;
        data["category"] = this.category;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["placeholder"] = this.placeholder;
        data["helpText"] = this.helpText;
        data["optionsJson"] = this.optionsJson;
        data["validationRulesJson"] = this.validationRulesJson;
        data["defaultValue"] = this.defaultValue;
        data["maxLength"] = this.maxLength;
        data["minLength"] = this.minLength;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IOnboardingFieldConfigurationDto {
    id: string;
    tenantId: string;
    fieldContext: string | undefined;
    fieldKey: string | undefined;
    fieldLabel: string | undefined;
    fieldType: string | undefined;
    category: string | undefined;
    isRequired: boolean;
    isEnabled: boolean;
    displayOrder: number;
    placeholder: string | undefined;
    helpText: string | undefined;
    optionsJson: string | undefined;
    validationRulesJson: string | undefined;
    defaultValue: string | undefined;
    maxLength: number | undefined;
    minLength: number | undefined;
    createdAt: DateTime;
    updatedAt: DateTime | undefined;
}

export class OnboardingFieldData implements IOnboardingFieldData {
    fieldKey!: string | undefined;
    fieldLabel!: string | undefined;
    fieldValue!: string | undefined;
    fieldType!: string | undefined;

    constructor(data?: IOnboardingFieldData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldKey = _data["fieldKey"];
            this.fieldLabel = _data["fieldLabel"];
            this.fieldValue = _data["fieldValue"];
            this.fieldType = _data["fieldType"];
        }
    }

    static fromJS(data: any): OnboardingFieldData {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingFieldData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldKey"] = this.fieldKey;
        data["fieldLabel"] = this.fieldLabel;
        data["fieldValue"] = this.fieldValue;
        data["fieldType"] = this.fieldType;
        return data;
    }
}

export interface IOnboardingFieldData {
    fieldKey: string | undefined;
    fieldLabel: string | undefined;
    fieldValue: string | undefined;
    fieldType: string | undefined;
}

export enum OnboardingStepType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class OrderDto implements IOrderDto {
    id!: string;
    orderNumber!: string | undefined;
    customerId!: string;
    customerName!: string | undefined;
    customerEmail!: string | undefined;
    orderDate!: DateTime;
    status!: OrderStatus;
    paymentStatus!: OrderPaymentStatus;
    fulfillmentStatus!: FulfillmentStatus;
    subtotal!: number;
    taxAmount!: number;
    shippingAmount!: number;
    discountAmount!: number;
    totalAmount!: number;
    customerNote!: string | undefined;
    internalNote!: string | undefined;
    shippingAddress!: AddressDto;
    billingAddress!: AddressDto;
    paymentMethod!: string | undefined;
    transactionId!: string | undefined;
    paidAt!: DateTime | undefined;
    shippedAt!: DateTime | undefined;
    deliveredAt!: DateTime | undefined;
    cancelledAt!: DateTime | undefined;
    cancellationReason!: string | undefined;
    orderItems!: OrderItemDto[] | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.customerEmail = _data["customerEmail"];
            this.orderDate = _data["orderDate"] ? DateTime.fromISO(_data["orderDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.paymentStatus = _data["paymentStatus"];
            this.fulfillmentStatus = _data["fulfillmentStatus"];
            this.subtotal = _data["subtotal"];
            this.taxAmount = _data["taxAmount"];
            this.shippingAmount = _data["shippingAmount"];
            this.discountAmount = _data["discountAmount"];
            this.totalAmount = _data["totalAmount"];
            this.customerNote = _data["customerNote"];
            this.internalNote = _data["internalNote"];
            this.shippingAddress = _data["shippingAddress"] ? AddressDto.fromJS(_data["shippingAddress"]) : undefined as any;
            this.billingAddress = _data["billingAddress"] ? AddressDto.fromJS(_data["billingAddress"]) : undefined as any;
            this.paymentMethod = _data["paymentMethod"];
            this.transactionId = _data["transactionId"];
            this.paidAt = _data["paidAt"] ? DateTime.fromISO(_data["paidAt"].toString()) : undefined as any;
            this.shippedAt = _data["shippedAt"] ? DateTime.fromISO(_data["shippedAt"].toString()) : undefined as any;
            this.deliveredAt = _data["deliveredAt"] ? DateTime.fromISO(_data["deliveredAt"].toString()) : undefined as any;
            this.cancelledAt = _data["cancelledAt"] ? DateTime.fromISO(_data["cancelledAt"].toString()) : undefined as any;
            this.cancellationReason = _data["cancellationReason"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItemDto.fromJS(item));
            }
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["customerEmail"] = this.customerEmail;
        data["orderDate"] = this.orderDate ? this.orderDate.toString() : undefined as any;
        data["status"] = this.status;
        data["paymentStatus"] = this.paymentStatus;
        data["fulfillmentStatus"] = this.fulfillmentStatus;
        data["subtotal"] = this.subtotal;
        data["taxAmount"] = this.taxAmount;
        data["shippingAmount"] = this.shippingAmount;
        data["discountAmount"] = this.discountAmount;
        data["totalAmount"] = this.totalAmount;
        data["customerNote"] = this.customerNote;
        data["internalNote"] = this.internalNote;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : undefined as any;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : undefined as any;
        data["paymentMethod"] = this.paymentMethod;
        data["transactionId"] = this.transactionId;
        data["paidAt"] = this.paidAt ? this.paidAt.toString() : undefined as any;
        data["shippedAt"] = this.shippedAt ? this.shippedAt.toString() : undefined as any;
        data["deliveredAt"] = this.deliveredAt ? this.deliveredAt.toString() : undefined as any;
        data["cancelledAt"] = this.cancelledAt ? this.cancelledAt.toString() : undefined as any;
        data["cancellationReason"] = this.cancellationReason;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item ? item.toJSON() : undefined as any);
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IOrderDto {
    id: string;
    orderNumber: string | undefined;
    customerId: string;
    customerName: string | undefined;
    customerEmail: string | undefined;
    orderDate: DateTime;
    status: OrderStatus;
    paymentStatus: OrderPaymentStatus;
    fulfillmentStatus: FulfillmentStatus;
    subtotal: number;
    taxAmount: number;
    shippingAmount: number;
    discountAmount: number;
    totalAmount: number;
    customerNote: string | undefined;
    internalNote: string | undefined;
    shippingAddress: AddressDto;
    billingAddress: AddressDto;
    paymentMethod: string | undefined;
    transactionId: string | undefined;
    paidAt: DateTime | undefined;
    shippedAt: DateTime | undefined;
    deliveredAt: DateTime | undefined;
    cancelledAt: DateTime | undefined;
    cancellationReason: string | undefined;
    orderItems: OrderItemDto[] | undefined;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class OrderItemDto implements IOrderItemDto {
    id!: string;
    orderId!: string;
    productId!: string;
    productVariantId!: string | undefined;
    productName!: string | undefined;
    variantName!: string | undefined;
    sku!: string | undefined;
    quantity!: number;
    unitPrice!: number;
    totalPrice!: number;
    discountAmount!: number | undefined;

    constructor(data?: IOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderId = _data["orderId"];
            this.productId = _data["productId"];
            this.productVariantId = _data["productVariantId"];
            this.productName = _data["productName"];
            this.variantName = _data["variantName"];
            this.sku = _data["sku"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.totalPrice = _data["totalPrice"];
            this.discountAmount = _data["discountAmount"];
        }
    }

    static fromJS(data: any): OrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderId"] = this.orderId;
        data["productId"] = this.productId;
        data["productVariantId"] = this.productVariantId;
        data["productName"] = this.productName;
        data["variantName"] = this.variantName;
        data["sku"] = this.sku;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["totalPrice"] = this.totalPrice;
        data["discountAmount"] = this.discountAmount;
        return data;
    }
}

export interface IOrderItemDto {
    id: string;
    orderId: string;
    productId: string;
    productVariantId: string | undefined;
    productName: string | undefined;
    variantName: string | undefined;
    sku: string | undefined;
    quantity: number;
    unitPrice: number;
    totalPrice: number;
    discountAmount: number | undefined;
}

export enum OrderPaymentStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class OrderStatsDto implements IOrderStatsDto {
    totalOrders!: number;
    pendingOrders!: number;
    processingOrders!: number;
    completedOrders!: number;
    totalRevenue!: number;
    averageOrderValue!: number;
    todayRevenue!: number;
    todayOrders!: number;

    constructor(data?: IOrderStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalOrders = _data["totalOrders"];
            this.pendingOrders = _data["pendingOrders"];
            this.processingOrders = _data["processingOrders"];
            this.completedOrders = _data["completedOrders"];
            this.totalRevenue = _data["totalRevenue"];
            this.averageOrderValue = _data["averageOrderValue"];
            this.todayRevenue = _data["todayRevenue"];
            this.todayOrders = _data["todayOrders"];
        }
    }

    static fromJS(data: any): OrderStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrders"] = this.totalOrders;
        data["pendingOrders"] = this.pendingOrders;
        data["processingOrders"] = this.processingOrders;
        data["completedOrders"] = this.completedOrders;
        data["totalRevenue"] = this.totalRevenue;
        data["averageOrderValue"] = this.averageOrderValue;
        data["todayRevenue"] = this.todayRevenue;
        data["todayOrders"] = this.todayOrders;
        return data;
    }
}

export interface IOrderStatsDto {
    totalOrders: number;
    pendingOrders: number;
    processingOrders: number;
    completedOrders: number;
    totalRevenue: number;
    averageOrderValue: number;
    todayRevenue: number;
    todayOrders: number;
}

export enum OrderStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class PageLimitsDto implements IPageLimitsDto {
    maxPages!: number;
    currentPages!: number;
    canCreateMore!: boolean;

    constructor(data?: IPageLimitsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxPages = _data["maxPages"];
            this.currentPages = _data["currentPages"];
            this.canCreateMore = _data["canCreateMore"];
        }
    }

    static fromJS(data: any): PageLimitsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageLimitsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxPages"] = this.maxPages;
        data["currentPages"] = this.currentPages;
        data["canCreateMore"] = this.canCreateMore;
        return data;
    }
}

export interface IPageLimitsDto {
    maxPages: number;
    currentPages: number;
    canCreateMore: boolean;
}

export class PageListItemDto implements IPageListItemDto {
    id!: string;
    name!: string | undefined;
    slug!: string | undefined;
    isPublic!: boolean;
    requiresAuth!: boolean;
    isActive!: boolean;
    showInNavbar!: boolean;
    showInFooter!: boolean;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: IPageListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.isPublic = _data["isPublic"];
            this.requiresAuth = _data["requiresAuth"];
            this.isActive = _data["isActive"];
            this.showInNavbar = _data["showInNavbar"];
            this.showInFooter = _data["showInFooter"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): PageListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["isPublic"] = this.isPublic;
        data["requiresAuth"] = this.requiresAuth;
        data["isActive"] = this.isActive;
        data["showInNavbar"] = this.showInNavbar;
        data["showInFooter"] = this.showInFooter;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IPageListItemDto {
    id: string;
    name: string | undefined;
    slug: string | undefined;
    isPublic: boolean;
    requiresAuth: boolean;
    isActive: boolean;
    showInNavbar: boolean;
    showInFooter: boolean;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class PageMetaTagsDto implements IPageMetaTagsDto {
    keywords!: string | undefined;
    ogTitle!: string | undefined;
    ogDescription!: string | undefined;
    ogImage!: string | undefined;

    constructor(data?: IPageMetaTagsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keywords = _data["keywords"];
            this.ogTitle = _data["ogTitle"];
            this.ogDescription = _data["ogDescription"];
            this.ogImage = _data["ogImage"];
        }
    }

    static fromJS(data: any): PageMetaTagsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageMetaTagsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywords"] = this.keywords;
        data["ogTitle"] = this.ogTitle;
        data["ogDescription"] = this.ogDescription;
        data["ogImage"] = this.ogImage;
        return data;
    }
}

export interface IPageMetaTagsDto {
    keywords: string | undefined;
    ogTitle: string | undefined;
    ogDescription: string | undefined;
    ogImage: string | undefined;
}

export class PageWidgetDto implements IPageWidgetDto {
    id!: string | undefined;
    type!: string | undefined;
    config!: any | undefined;
    order!: number;

    constructor(data?: IPageWidgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.config = _data["config"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): PageWidgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageWidgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["config"] = this.config;
        data["order"] = this.order;
        return data;
    }
}

export interface IPageWidgetDto {
    id: string | undefined;
    type: string | undefined;
    config: any | undefined;
    order: number;
}

export class Payment implements IPayment {
    id!: string;
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    memberId!: string | undefined;
    member!: Member;
    invoiceId!: string | undefined;
    invoice!: Invoice;
    amount!: number;
    paymentDate!: DateTime;
    paymentMethod!: PaymentMethodType;
    transactionId!: string | undefined;
    reference!: string | undefined;
    status!: PaymentProcessingStatus;
    failureReason!: string | undefined;
    gatewayProvider!: PaymentGatewayProvider;
    tenantId!: string;
    tenant!: Tenant;
    subscriptionPlanId!: string | undefined;
    subscriptionPlan!: SubscriptionPlan;
    couponId!: string | undefined;
    coupon!: Coupon;
    currency!: string | undefined;
    paymentType!: string | undefined;
    paymentGateway!: string | undefined;
    isRecurring!: boolean | undefined;
    metadata!: string | undefined;
    paymentGatewayTransactionId!: string | undefined;
    refundAmount!: number | undefined;
    refundedAt!: DateTime | undefined;
    refundReason!: string | undefined;
    refundedBy!: string | undefined;
    billingPeriodStart!: DateTime | undefined;
    billingPeriodEnd!: DateTime | undefined;

    constructor(data?: IPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.memberId = _data["memberId"];
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : undefined as any;
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : undefined as any;
            this.amount = _data["amount"];
            this.paymentDate = _data["paymentDate"] ? DateTime.fromISO(_data["paymentDate"].toString()) : undefined as any;
            this.paymentMethod = _data["paymentMethod"];
            this.transactionId = _data["transactionId"];
            this.reference = _data["reference"];
            this.status = _data["status"];
            this.failureReason = _data["failureReason"];
            this.gatewayProvider = _data["gatewayProvider"];
            this.tenantId = _data["tenantId"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : undefined as any;
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.subscriptionPlan = _data["subscriptionPlan"] ? SubscriptionPlan.fromJS(_data["subscriptionPlan"]) : undefined as any;
            this.couponId = _data["couponId"];
            this.coupon = _data["coupon"] ? Coupon.fromJS(_data["coupon"]) : undefined as any;
            this.currency = _data["currency"];
            this.paymentType = _data["paymentType"];
            this.paymentGateway = _data["paymentGateway"];
            this.isRecurring = _data["isRecurring"];
            this.metadata = _data["metadata"];
            this.paymentGatewayTransactionId = _data["paymentGatewayTransactionId"];
            this.refundAmount = _data["refundAmount"];
            this.refundedAt = _data["refundedAt"] ? DateTime.fromISO(_data["refundedAt"].toString()) : undefined as any;
            this.refundReason = _data["refundReason"];
            this.refundedBy = _data["refundedBy"];
            this.billingPeriodStart = _data["billingPeriodStart"] ? DateTime.fromISO(_data["billingPeriodStart"].toString()) : undefined as any;
            this.billingPeriodEnd = _data["billingPeriodEnd"] ? DateTime.fromISO(_data["billingPeriodEnd"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): Payment {
        data = typeof data === 'object' ? data : {};
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["memberId"] = this.memberId;
        data["member"] = this.member ? this.member.toJSON() : undefined as any;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : undefined as any;
        data["amount"] = this.amount;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toString() : undefined as any;
        data["paymentMethod"] = this.paymentMethod;
        data["transactionId"] = this.transactionId;
        data["reference"] = this.reference;
        data["status"] = this.status;
        data["failureReason"] = this.failureReason;
        data["gatewayProvider"] = this.gatewayProvider;
        data["tenantId"] = this.tenantId;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : undefined as any;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["subscriptionPlan"] = this.subscriptionPlan ? this.subscriptionPlan.toJSON() : undefined as any;
        data["couponId"] = this.couponId;
        data["coupon"] = this.coupon ? this.coupon.toJSON() : undefined as any;
        data["currency"] = this.currency;
        data["paymentType"] = this.paymentType;
        data["paymentGateway"] = this.paymentGateway;
        data["isRecurring"] = this.isRecurring;
        data["metadata"] = this.metadata;
        data["paymentGatewayTransactionId"] = this.paymentGatewayTransactionId;
        data["refundAmount"] = this.refundAmount;
        data["refundedAt"] = this.refundedAt ? this.refundedAt.toString() : undefined as any;
        data["refundReason"] = this.refundReason;
        data["refundedBy"] = this.refundedBy;
        data["billingPeriodStart"] = this.billingPeriodStart ? this.billingPeriodStart.toString() : undefined as any;
        data["billingPeriodEnd"] = this.billingPeriodEnd ? this.billingPeriodEnd.toString() : undefined as any;
        return data;
    }
}

export interface IPayment {
    id: string;
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    memberId: string | undefined;
    member: Member;
    invoiceId: string | undefined;
    invoice: Invoice;
    amount: number;
    paymentDate: DateTime;
    paymentMethod: PaymentMethodType;
    transactionId: string | undefined;
    reference: string | undefined;
    status: PaymentProcessingStatus;
    failureReason: string | undefined;
    gatewayProvider: PaymentGatewayProvider;
    tenantId: string;
    tenant: Tenant;
    subscriptionPlanId: string | undefined;
    subscriptionPlan: SubscriptionPlan;
    couponId: string | undefined;
    coupon: Coupon;
    currency: string | undefined;
    paymentType: string | undefined;
    paymentGateway: string | undefined;
    isRecurring: boolean | undefined;
    metadata: string | undefined;
    paymentGatewayTransactionId: string | undefined;
    refundAmount: number | undefined;
    refundedAt: DateTime | undefined;
    refundReason: string | undefined;
    refundedBy: string | undefined;
    billingPeriodStart: DateTime | undefined;
    billingPeriodEnd: DateTime | undefined;
}

export class PaymentGatewayConfig implements IPaymentGatewayConfig {
    id!: string;
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    tenantId!: string;
    tenant!: Tenant;
    provider!: PaymentGatewayProvider;
    apiKey!: string | undefined;
    merchantId!: string | undefined;
    secretKey!: string | undefined;
    siteCode!: string | undefined;
    passPhrase!: string | undefined;
    isActive!: boolean;
    isTestMode!: boolean;
    webhookUrl!: string | undefined;
    returnUrl!: string | undefined;
    cancelUrl!: string | undefined;

    constructor(data?: IPaymentGatewayConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.tenantId = _data["tenantId"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : undefined as any;
            this.provider = _data["provider"];
            this.apiKey = _data["apiKey"];
            this.merchantId = _data["merchantId"];
            this.secretKey = _data["secretKey"];
            this.siteCode = _data["siteCode"];
            this.passPhrase = _data["passPhrase"];
            this.isActive = _data["isActive"];
            this.isTestMode = _data["isTestMode"];
            this.webhookUrl = _data["webhookUrl"];
            this.returnUrl = _data["returnUrl"];
            this.cancelUrl = _data["cancelUrl"];
        }
    }

    static fromJS(data: any): PaymentGatewayConfig {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["tenantId"] = this.tenantId;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : undefined as any;
        data["provider"] = this.provider;
        data["apiKey"] = this.apiKey;
        data["merchantId"] = this.merchantId;
        data["secretKey"] = this.secretKey;
        data["siteCode"] = this.siteCode;
        data["passPhrase"] = this.passPhrase;
        data["isActive"] = this.isActive;
        data["isTestMode"] = this.isTestMode;
        data["webhookUrl"] = this.webhookUrl;
        data["returnUrl"] = this.returnUrl;
        data["cancelUrl"] = this.cancelUrl;
        return data;
    }
}

export interface IPaymentGatewayConfig {
    id: string;
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    tenantId: string;
    tenant: Tenant;
    provider: PaymentGatewayProvider;
    apiKey: string | undefined;
    merchantId: string | undefined;
    secretKey: string | undefined;
    siteCode: string | undefined;
    passPhrase: string | undefined;
    isActive: boolean;
    isTestMode: boolean;
    webhookUrl: string | undefined;
    returnUrl: string | undefined;
    cancelUrl: string | undefined;
}

export class PaymentGatewayConfigDto implements IPaymentGatewayConfigDto {
    id!: string;
    tenantId!: string;
    provider!: PaymentGatewayProvider;
    merchantId!: string | undefined;
    siteCode!: string | undefined;
    isActive!: boolean;
    isTestMode!: boolean;
    webhookUrl!: string | undefined;
    returnUrl!: string | undefined;
    cancelUrl!: string | undefined;
    apiKey!: string | undefined;
    secretKey!: string | undefined;
    passPhrase!: string | undefined;

    constructor(data?: IPaymentGatewayConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.provider = _data["provider"];
            this.merchantId = _data["merchantId"];
            this.siteCode = _data["siteCode"];
            this.isActive = _data["isActive"];
            this.isTestMode = _data["isTestMode"];
            this.webhookUrl = _data["webhookUrl"];
            this.returnUrl = _data["returnUrl"];
            this.cancelUrl = _data["cancelUrl"];
            this.apiKey = _data["apiKey"];
            this.secretKey = _data["secretKey"];
            this.passPhrase = _data["passPhrase"];
        }
    }

    static fromJS(data: any): PaymentGatewayConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["provider"] = this.provider;
        data["merchantId"] = this.merchantId;
        data["siteCode"] = this.siteCode;
        data["isActive"] = this.isActive;
        data["isTestMode"] = this.isTestMode;
        data["webhookUrl"] = this.webhookUrl;
        data["returnUrl"] = this.returnUrl;
        data["cancelUrl"] = this.cancelUrl;
        data["apiKey"] = this.apiKey;
        data["secretKey"] = this.secretKey;
        data["passPhrase"] = this.passPhrase;
        return data;
    }
}

export interface IPaymentGatewayConfigDto {
    id: string;
    tenantId: string;
    provider: PaymentGatewayProvider;
    merchantId: string | undefined;
    siteCode: string | undefined;
    isActive: boolean;
    isTestMode: boolean;
    webhookUrl: string | undefined;
    returnUrl: string | undefined;
    cancelUrl: string | undefined;
    apiKey: string | undefined;
    secretKey: string | undefined;
    passPhrase: string | undefined;
}

export enum PaymentGatewayProvider {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class PaymentInitiationResultDto implements IPaymentInitiationResultDto {
    success!: boolean;
    paymentUrl!: string | undefined;
    transactionId!: string | undefined;
    errorMessage!: string | undefined;

    constructor(data?: IPaymentInitiationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.paymentUrl = _data["paymentUrl"];
            this.transactionId = _data["transactionId"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PaymentInitiationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInitiationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["paymentUrl"] = this.paymentUrl;
        data["transactionId"] = this.transactionId;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IPaymentInitiationResultDto {
    success: boolean;
    paymentUrl: string | undefined;
    transactionId: string | undefined;
    errorMessage: string | undefined;
}

export enum PaymentMethodType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum PaymentProcessingStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class PaymentSessionDto implements IPaymentSessionDto {
    sessionId!: string | undefined;
    paymentUrl!: string | undefined;
    expiresAt!: DateTime;
    paymentId!: string;
    paymentData!: { [key: string]: string; } | undefined;

    constructor(data?: IPaymentSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            this.paymentUrl = _data["paymentUrl"];
            this.expiresAt = _data["expiresAt"] ? DateTime.fromISO(_data["expiresAt"].toString()) : undefined as any;
            this.paymentId = _data["paymentId"];
            if (_data["paymentData"]) {
                this.paymentData = {} as any;
                for (let key in _data["paymentData"]) {
                    if (_data["paymentData"].hasOwnProperty(key))
                        (this.paymentData as any)![key] = _data["paymentData"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaymentSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        data["paymentUrl"] = this.paymentUrl;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toString() : undefined as any;
        data["paymentId"] = this.paymentId;
        if (this.paymentData) {
            data["paymentData"] = {};
            for (let key in this.paymentData) {
                if (this.paymentData.hasOwnProperty(key))
                    (data["paymentData"] as any)[key] = (this.paymentData as any)[key];
            }
        }
        return data;
    }
}

export interface IPaymentSessionDto {
    sessionId: string | undefined;
    paymentUrl: string | undefined;
    expiresAt: DateTime;
    paymentId: string;
    paymentData: { [key: string]: string; } | undefined;
}

export enum PaymentStatus {
    _0 = 0,
    _1 = 1,
}

export class PaymentVerificationResultDto implements IPaymentVerificationResultDto {
    isVerified!: boolean;
    paymentStatus!: string | undefined;
    amount!: number;
    paymentDate!: DateTime | undefined;
    message!: string | undefined;

    constructor(data?: IPaymentVerificationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVerified = _data["isVerified"];
            this.paymentStatus = _data["paymentStatus"];
            this.amount = _data["amount"];
            this.paymentDate = _data["paymentDate"] ? DateTime.fromISO(_data["paymentDate"].toString()) : undefined as any;
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): PaymentVerificationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentVerificationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVerified"] = this.isVerified;
        data["paymentStatus"] = this.paymentStatus;
        data["amount"] = this.amount;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toString() : undefined as any;
        data["message"] = this.message;
        return data;
    }
}

export interface IPaymentVerificationResultDto {
    isVerified: boolean;
    paymentStatus: string | undefined;
    amount: number;
    paymentDate: DateTime | undefined;
    message: string | undefined;
}

export class PdfFieldMappingDto implements IPdfFieldMappingDto {
    id!: string;
    tenantId!: string;
    sourceField!: string | undefined;
    pdfFieldName!: string | undefined;
    mappingType!: string | undefined;
    isEnabled!: boolean;
    displayOrder!: number;
    description!: string | undefined;
    conditionalRulesJson!: string | undefined;
    transformRule!: string | undefined;
    defaultValue!: string | undefined;
    checkedValue!: string | undefined;
    uncheckedValue!: string | undefined;
    category!: string | undefined;
    isArrayField!: boolean;
    arrayName!: string | undefined;
    arrayFieldPattern!: string | undefined;
    arrayMaxItems!: number | undefined;
    sourceArrayPath!: string | undefined;
    fieldNamePrefix!: string | undefined;
    usePrefixInPdfFieldName!: boolean;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: IPdfFieldMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.sourceField = _data["sourceField"];
            this.pdfFieldName = _data["pdfFieldName"];
            this.mappingType = _data["mappingType"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.description = _data["description"];
            this.conditionalRulesJson = _data["conditionalRulesJson"];
            this.transformRule = _data["transformRule"];
            this.defaultValue = _data["defaultValue"];
            this.checkedValue = _data["checkedValue"];
            this.uncheckedValue = _data["uncheckedValue"];
            this.category = _data["category"];
            this.isArrayField = _data["isArrayField"];
            this.arrayName = _data["arrayName"];
            this.arrayFieldPattern = _data["arrayFieldPattern"];
            this.arrayMaxItems = _data["arrayMaxItems"];
            this.sourceArrayPath = _data["sourceArrayPath"];
            this.fieldNamePrefix = _data["fieldNamePrefix"];
            this.usePrefixInPdfFieldName = _data["usePrefixInPdfFieldName"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): PdfFieldMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfFieldMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["sourceField"] = this.sourceField;
        data["pdfFieldName"] = this.pdfFieldName;
        data["mappingType"] = this.mappingType;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["description"] = this.description;
        data["conditionalRulesJson"] = this.conditionalRulesJson;
        data["transformRule"] = this.transformRule;
        data["defaultValue"] = this.defaultValue;
        data["checkedValue"] = this.checkedValue;
        data["uncheckedValue"] = this.uncheckedValue;
        data["category"] = this.category;
        data["isArrayField"] = this.isArrayField;
        data["arrayName"] = this.arrayName;
        data["arrayFieldPattern"] = this.arrayFieldPattern;
        data["arrayMaxItems"] = this.arrayMaxItems;
        data["sourceArrayPath"] = this.sourceArrayPath;
        data["fieldNamePrefix"] = this.fieldNamePrefix;
        data["usePrefixInPdfFieldName"] = this.usePrefixInPdfFieldName;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IPdfFieldMappingDto {
    id: string;
    tenantId: string;
    sourceField: string | undefined;
    pdfFieldName: string | undefined;
    mappingType: string | undefined;
    isEnabled: boolean;
    displayOrder: number;
    description: string | undefined;
    conditionalRulesJson: string | undefined;
    transformRule: string | undefined;
    defaultValue: string | undefined;
    checkedValue: string | undefined;
    uncheckedValue: string | undefined;
    category: string | undefined;
    isArrayField: boolean;
    arrayName: string | undefined;
    arrayFieldPattern: string | undefined;
    arrayMaxItems: number | undefined;
    sourceArrayPath: string | undefined;
    fieldNamePrefix: string | undefined;
    usePrefixInPdfFieldName: boolean;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class PdfTemplateAnalysisResult implements IPdfTemplateAnalysisResult {
    templateFileId!: string;
    totalFields!: number;
    mappedFields!: number;
    unmappedFields!: number;
    fields!: PdfTemplateFieldInfo[] | undefined;
    suggestedSourceFields!: string[] | undefined;

    constructor(data?: IPdfTemplateAnalysisResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateFileId = _data["templateFileId"];
            this.totalFields = _data["totalFields"];
            this.mappedFields = _data["mappedFields"];
            this.unmappedFields = _data["unmappedFields"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(PdfTemplateFieldInfo.fromJS(item));
            }
            if (Array.isArray(_data["suggestedSourceFields"])) {
                this.suggestedSourceFields = [] as any;
                for (let item of _data["suggestedSourceFields"])
                    this.suggestedSourceFields!.push(item);
            }
        }
    }

    static fromJS(data: any): PdfTemplateAnalysisResult {
        data = typeof data === 'object' ? data : {};
        let result = new PdfTemplateAnalysisResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateFileId"] = this.templateFileId;
        data["totalFields"] = this.totalFields;
        data["mappedFields"] = this.mappedFields;
        data["unmappedFields"] = this.unmappedFields;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.suggestedSourceFields)) {
            data["suggestedSourceFields"] = [];
            for (let item of this.suggestedSourceFields)
                data["suggestedSourceFields"].push(item);
        }
        return data;
    }
}

export interface IPdfTemplateAnalysisResult {
    templateFileId: string;
    totalFields: number;
    mappedFields: number;
    unmappedFields: number;
    fields: PdfTemplateFieldInfo[] | undefined;
    suggestedSourceFields: string[] | undefined;
}

export class PdfTemplateFieldInfo implements IPdfTemplateFieldInfo {
    fieldName!: string | undefined;
    fieldType!: string | undefined;
    isMapped!: boolean;
    mappedSourceField!: string | undefined;
    mappingType!: string | undefined;

    constructor(data?: IPdfTemplateFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.fieldType = _data["fieldType"];
            this.isMapped = _data["isMapped"];
            this.mappedSourceField = _data["mappedSourceField"];
            this.mappingType = _data["mappingType"];
        }
    }

    static fromJS(data: any): PdfTemplateFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PdfTemplateFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["fieldType"] = this.fieldType;
        data["isMapped"] = this.isMapped;
        data["mappedSourceField"] = this.mappedSourceField;
        data["mappingType"] = this.mappingType;
        return data;
    }
}

export interface IPdfTemplateFieldInfo {
    fieldName: string | undefined;
    fieldType: string | undefined;
    isMapped: boolean;
    mappedSourceField: string | undefined;
    mappingType: string | undefined;
}

export class PendingMemberDto implements IPendingMemberDto {
    id!: string;
    title!: string | undefined;
    firstNames!: string | undefined;
    surname!: string | undefined;
    identificationNumber!: string | undefined;
    email!: string | undefined;
    phone1!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    city!: string | undefined;
    province!: string | undefined;
    createdDate!: DateTime | undefined;
    status!: string | undefined;
    isIdVerified!: boolean;
    daysWaiting!: number;
    policyNames!: string[] | undefined;

    constructor(data?: IPendingMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.firstNames = _data["firstNames"];
            this.surname = _data["surname"];
            this.identificationNumber = _data["identificationNumber"];
            this.email = _data["email"];
            this.phone1 = _data["phone1"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.city = _data["city"];
            this.province = _data["province"];
            this.createdDate = _data["createdDate"] ? DateTime.fromISO(_data["createdDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.isIdVerified = _data["isIdVerified"];
            this.daysWaiting = _data["daysWaiting"];
            if (Array.isArray(_data["policyNames"])) {
                this.policyNames = [] as any;
                for (let item of _data["policyNames"])
                    this.policyNames!.push(item);
            }
        }
    }

    static fromJS(data: any): PendingMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new PendingMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["firstNames"] = this.firstNames;
        data["surname"] = this.surname;
        data["identificationNumber"] = this.identificationNumber;
        data["email"] = this.email;
        data["phone1"] = this.phone1;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["city"] = this.city;
        data["province"] = this.province;
        data["createdDate"] = this.createdDate ? this.createdDate.toString() : undefined as any;
        data["status"] = this.status;
        data["isIdVerified"] = this.isIdVerified;
        data["daysWaiting"] = this.daysWaiting;
        if (Array.isArray(this.policyNames)) {
            data["policyNames"] = [];
            for (let item of this.policyNames)
                data["policyNames"].push(item);
        }
        return data;
    }
}

export interface IPendingMemberDto {
    id: string;
    title: string | undefined;
    firstNames: string | undefined;
    surname: string | undefined;
    identificationNumber: string | undefined;
    email: string | undefined;
    phone1: string | undefined;
    dateOfBirth: DateTime | undefined;
    city: string | undefined;
    province: string | undefined;
    createdDate: DateTime | undefined;
    status: string | undefined;
    isIdVerified: boolean;
    daysWaiting: number;
    policyNames: string[] | undefined;
}

export class Permission implements IPermission {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    name!: string;
    tenantId!: string;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IPermission {
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    name: string;
    tenantId: string;
}

export class PermissionDto implements IPermissionDto {
    id!: string;
    name!: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IPermissionDto {
    id: string;
    name: string | undefined;
}

export class PermissionInput implements IPermissionInput {
    name!: string | undefined;
    id!: string;

    constructor(data?: IPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IPermissionInput {
    name: string | undefined;
    id: string;
}

export class Policy implements IPolicy {
    id!: string;
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    name!: string | undefined;
    policyNumber!: string | undefined;
    description!: string | undefined;
    tenantId!: string;
    tenant!: Tenant;
    payoutAmount!: number;
    coverageAmount!: number | undefined;
    price!: number;
    waitingPeriodDays!: number | undefined;
    maxClaimAmount!: number | undefined;
    isActive!: boolean;
    status!: PolicyStatus;
    startDate!: DateTime;
    endDate!: DateTime | undefined;
    premiumAmount!: number;
    policyAttributes!: PolicyAttribute[] | undefined;
    policyEnrollments!: PolicyEnrollment[] | undefined;
    claims!: Claim[] | undefined;

    constructor(data?: IPolicy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.name = _data["name"];
            this.policyNumber = _data["policyNumber"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : undefined as any;
            this.payoutAmount = _data["payoutAmount"];
            this.coverageAmount = _data["coverageAmount"];
            this.price = _data["price"];
            this.waitingPeriodDays = _data["waitingPeriodDays"];
            this.maxClaimAmount = _data["maxClaimAmount"];
            this.isActive = _data["isActive"];
            this.status = _data["status"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : undefined as any;
            this.premiumAmount = _data["premiumAmount"];
            if (Array.isArray(_data["policyAttributes"])) {
                this.policyAttributes = [] as any;
                for (let item of _data["policyAttributes"])
                    this.policyAttributes!.push(PolicyAttribute.fromJS(item));
            }
            if (Array.isArray(_data["policyEnrollments"])) {
                this.policyEnrollments = [] as any;
                for (let item of _data["policyEnrollments"])
                    this.policyEnrollments!.push(PolicyEnrollment.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Policy {
        data = typeof data === 'object' ? data : {};
        let result = new Policy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["name"] = this.name;
        data["policyNumber"] = this.policyNumber;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : undefined as any;
        data["payoutAmount"] = this.payoutAmount;
        data["coverageAmount"] = this.coverageAmount;
        data["price"] = this.price;
        data["waitingPeriodDays"] = this.waitingPeriodDays;
        data["maxClaimAmount"] = this.maxClaimAmount;
        data["isActive"] = this.isActive;
        data["status"] = this.status;
        data["startDate"] = this.startDate ? this.startDate.toString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toString() : undefined as any;
        data["premiumAmount"] = this.premiumAmount;
        if (Array.isArray(this.policyAttributes)) {
            data["policyAttributes"] = [];
            for (let item of this.policyAttributes)
                data["policyAttributes"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.policyEnrollments)) {
            data["policyEnrollments"] = [];
            for (let item of this.policyEnrollments)
                data["policyEnrollments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IPolicy {
    id: string;
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    name: string | undefined;
    policyNumber: string | undefined;
    description: string | undefined;
    tenantId: string;
    tenant: Tenant;
    payoutAmount: number;
    coverageAmount: number | undefined;
    price: number;
    waitingPeriodDays: number | undefined;
    maxClaimAmount: number | undefined;
    isActive: boolean;
    status: PolicyStatus;
    startDate: DateTime;
    endDate: DateTime | undefined;
    premiumAmount: number;
    policyAttributes: PolicyAttribute[] | undefined;
    policyEnrollments: PolicyEnrollment[] | undefined;
    claims: Claim[] | undefined;
}

export class PolicyAttribute implements IPolicyAttribute {
    id!: string;
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    property!: string | undefined;
    value!: string | undefined;
    dataType!: string | undefined;
    description!: string | undefined;
    isIncluded!: boolean;
    policyId!: string;
    tenantId!: string;

    constructor(data?: IPolicyAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.property = _data["property"];
            this.value = _data["value"];
            this.dataType = _data["dataType"];
            this.description = _data["description"];
            this.isIncluded = _data["isIncluded"];
            this.policyId = _data["policyId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): PolicyAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["property"] = this.property;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["description"] = this.description;
        data["isIncluded"] = this.isIncluded;
        data["policyId"] = this.policyId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IPolicyAttribute {
    id: string;
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    property: string | undefined;
    value: string | undefined;
    dataType: string | undefined;
    description: string | undefined;
    isIncluded: boolean;
    policyId: string;
    tenantId: string;
}

export class PolicyAttributeDto implements IPolicyAttributeDto {
    id!: string;
    property!: string | undefined;
    value!: string | undefined;
    dataType!: string | undefined;
    description!: string | undefined;
    isIncluded!: boolean;
    policyId!: string;

    constructor(data?: IPolicyAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.property = _data["property"];
            this.value = _data["value"];
            this.dataType = _data["dataType"];
            this.description = _data["description"];
            this.isIncluded = _data["isIncluded"];
            this.policyId = _data["policyId"];
        }
    }

    static fromJS(data: any): PolicyAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["property"] = this.property;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["description"] = this.description;
        data["isIncluded"] = this.isIncluded;
        data["policyId"] = this.policyId;
        return data;
    }
}

export interface IPolicyAttributeDto {
    id: string;
    property: string | undefined;
    value: string | undefined;
    dataType: string | undefined;
    description: string | undefined;
    isIncluded: boolean;
    policyId: string;
}

export class PolicyCoverAgeBracketDto implements IPolicyCoverAgeBracketDto {
    maxAge!: number;
    label!: string | undefined;
    premium!: number;

    constructor(data?: IPolicyCoverAgeBracketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxAge = _data["maxAge"];
            this.label = _data["label"];
            this.premium = _data["premium"];
        }
    }

    static fromJS(data: any): PolicyCoverAgeBracketDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyCoverAgeBracketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxAge"] = this.maxAge;
        data["label"] = this.label;
        data["premium"] = this.premium;
        return data;
    }
}

export interface IPolicyCoverAgeBracketDto {
    maxAge: number;
    label: string | undefined;
    premium: number;
}

export class PolicyCoverPremiumTableDto implements IPolicyCoverPremiumTableDto {
    rows!: PolicyCoverRowDto[] | undefined;

    constructor(data?: IPolicyCoverPremiumTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(PolicyCoverRowDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PolicyCoverPremiumTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyCoverPremiumTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IPolicyCoverPremiumTableDto {
    rows: PolicyCoverRowDto[] | undefined;
}

export class PolicyCoverRowDto implements IPolicyCoverRowDto {
    coverAmount!: number;
    dependentCountTiers!: DependentCountTierDto[] | undefined;
    ageBrackets!: { [key: string]: PolicyCoverAgeBracketDto; } | undefined;
    premium_1To5Dependents_Under65!: number;
    premium_1To5Dependents_Under70!: number;
    premium_1To5Dependents_Under75!: number;
    premium_1To5Dependents_75Plus!: number;

    constructor(data?: IPolicyCoverRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coverAmount = _data["coverAmount"];
            if (Array.isArray(_data["dependentCountTiers"])) {
                this.dependentCountTiers = [] as any;
                for (let item of _data["dependentCountTiers"])
                    this.dependentCountTiers!.push(DependentCountTierDto.fromJS(item));
            }
            if (_data["ageBrackets"]) {
                this.ageBrackets = {} as any;
                for (let key in _data["ageBrackets"]) {
                    if (_data["ageBrackets"].hasOwnProperty(key))
                        (this.ageBrackets as any)![key] = _data["ageBrackets"][key] ? PolicyCoverAgeBracketDto.fromJS(_data["ageBrackets"][key]) : new PolicyCoverAgeBracketDto();
                }
            }
            this.premium_1To5Dependents_Under65 = _data["premium_1To5Dependents_Under65"];
            this.premium_1To5Dependents_Under70 = _data["premium_1To5Dependents_Under70"];
            this.premium_1To5Dependents_Under75 = _data["premium_1To5Dependents_Under75"];
            this.premium_1To5Dependents_75Plus = _data["premium_1To5Dependents_75Plus"];
        }
    }

    static fromJS(data: any): PolicyCoverRowDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyCoverRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coverAmount"] = this.coverAmount;
        if (Array.isArray(this.dependentCountTiers)) {
            data["dependentCountTiers"] = [];
            for (let item of this.dependentCountTiers)
                data["dependentCountTiers"].push(item ? item.toJSON() : undefined as any);
        }
        if (this.ageBrackets) {
            data["ageBrackets"] = {};
            for (let key in this.ageBrackets) {
                if (this.ageBrackets.hasOwnProperty(key))
                    (data["ageBrackets"] as any)[key] = this.ageBrackets[key] ? this.ageBrackets[key].toJSON() : undefined as any;
            }
        }
        data["premium_1To5Dependents_Under65"] = this.premium_1To5Dependents_Under65;
        data["premium_1To5Dependents_Under70"] = this.premium_1To5Dependents_Under70;
        data["premium_1To5Dependents_Under75"] = this.premium_1To5Dependents_Under75;
        data["premium_1To5Dependents_75Plus"] = this.premium_1To5Dependents_75Plus;
        return data;
    }
}

export interface IPolicyCoverRowDto {
    coverAmount: number;
    dependentCountTiers: DependentCountTierDto[] | undefined;
    ageBrackets: { [key: string]: PolicyCoverAgeBracketDto; } | undefined;
    premium_1To5Dependents_Under65: number;
    premium_1To5Dependents_Under70: number;
    premium_1To5Dependents_Under75: number;
    premium_1To5Dependents_75Plus: number;
}

export class PolicyDto implements IPolicyDto {
    id!: string;
    name!: string | undefined;
    price!: number;
    payoutAmount!: number;
    policyAttributes!: PolicyAttributeDto[] | undefined;

    constructor(data?: IPolicyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.payoutAmount = _data["payoutAmount"];
            if (Array.isArray(_data["policyAttributes"])) {
                this.policyAttributes = [] as any;
                for (let item of _data["policyAttributes"])
                    this.policyAttributes!.push(PolicyAttributeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PolicyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        data["payoutAmount"] = this.payoutAmount;
        if (Array.isArray(this.policyAttributes)) {
            data["policyAttributes"] = [];
            for (let item of this.policyAttributes)
                data["policyAttributes"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IPolicyDto {
    id: string;
    name: string | undefined;
    price: number;
    payoutAmount: number;
    policyAttributes: PolicyAttributeDto[] | undefined;
}

export class PolicyEnrollment implements IPolicyEnrollment {
    id!: string;
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    memberId!: string;
    member!: Member;
    policyId!: string;
    policy!: Policy;
    enrollmentDate!: DateTime;
    endDate!: DateTime | undefined;
    status!: PolicyEnrollmentStatus;
    tenantId!: string;
    referenceNumber!: string | undefined;
    onboardingContractId!: string | undefined;
    policyNumber!: string | undefined;
    approvedDate!: DateTime | undefined;
    approvedBy!: string | undefined;
    rejectionReason!: string | undefined;
    statusChangedDate!: DateTime | undefined;

    constructor(data?: IPolicyEnrollment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.memberId = _data["memberId"];
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : undefined as any;
            this.policyId = _data["policyId"];
            this.policy = _data["policy"] ? Policy.fromJS(_data["policy"]) : undefined as any;
            this.enrollmentDate = _data["enrollmentDate"] ? DateTime.fromISO(_data["enrollmentDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.tenantId = _data["tenantId"];
            this.referenceNumber = _data["referenceNumber"];
            this.onboardingContractId = _data["onboardingContractId"];
            this.policyNumber = _data["policyNumber"];
            this.approvedDate = _data["approvedDate"] ? DateTime.fromISO(_data["approvedDate"].toString()) : undefined as any;
            this.approvedBy = _data["approvedBy"];
            this.rejectionReason = _data["rejectionReason"];
            this.statusChangedDate = _data["statusChangedDate"] ? DateTime.fromISO(_data["statusChangedDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): PolicyEnrollment {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyEnrollment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["memberId"] = this.memberId;
        data["member"] = this.member ? this.member.toJSON() : undefined as any;
        data["policyId"] = this.policyId;
        data["policy"] = this.policy ? this.policy.toJSON() : undefined as any;
        data["enrollmentDate"] = this.enrollmentDate ? this.enrollmentDate.toString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toString() : undefined as any;
        data["status"] = this.status;
        data["tenantId"] = this.tenantId;
        data["referenceNumber"] = this.referenceNumber;
        data["onboardingContractId"] = this.onboardingContractId;
        data["policyNumber"] = this.policyNumber;
        data["approvedDate"] = this.approvedDate ? this.approvedDate.toString() : undefined as any;
        data["approvedBy"] = this.approvedBy;
        data["rejectionReason"] = this.rejectionReason;
        data["statusChangedDate"] = this.statusChangedDate ? this.statusChangedDate.toString() : undefined as any;
        return data;
    }
}

export interface IPolicyEnrollment {
    id: string;
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    memberId: string;
    member: Member;
    policyId: string;
    policy: Policy;
    enrollmentDate: DateTime;
    endDate: DateTime | undefined;
    status: PolicyEnrollmentStatus;
    tenantId: string;
    referenceNumber: string | undefined;
    onboardingContractId: string | undefined;
    policyNumber: string | undefined;
    approvedDate: DateTime | undefined;
    approvedBy: string | undefined;
    rejectionReason: string | undefined;
    statusChangedDate: DateTime | undefined;
}

export class PolicyEnrollmentDto implements IPolicyEnrollmentDto {
    id!: string;
    memberId!: string;
    policyId!: string;
    enrollmentDate!: DateTime;
    endDate!: DateTime | undefined;
    status!: PolicyEnrollmentStatus;
    referenceNumber!: string | undefined;
    policyNumber!: string | undefined;
    approvedDate!: DateTime | undefined;
    rejectionReason!: string | undefined;
    statusChangedDate!: DateTime | undefined;

    constructor(data?: IPolicyEnrollmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.policyId = _data["policyId"];
            this.enrollmentDate = _data["enrollmentDate"] ? DateTime.fromISO(_data["enrollmentDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.referenceNumber = _data["referenceNumber"];
            this.policyNumber = _data["policyNumber"];
            this.approvedDate = _data["approvedDate"] ? DateTime.fromISO(_data["approvedDate"].toString()) : undefined as any;
            this.rejectionReason = _data["rejectionReason"];
            this.statusChangedDate = _data["statusChangedDate"] ? DateTime.fromISO(_data["statusChangedDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): PolicyEnrollmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyEnrollmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["policyId"] = this.policyId;
        data["enrollmentDate"] = this.enrollmentDate ? this.enrollmentDate.toString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toString() : undefined as any;
        data["status"] = this.status;
        data["referenceNumber"] = this.referenceNumber;
        data["policyNumber"] = this.policyNumber;
        data["approvedDate"] = this.approvedDate ? this.approvedDate.toString() : undefined as any;
        data["rejectionReason"] = this.rejectionReason;
        data["statusChangedDate"] = this.statusChangedDate ? this.statusChangedDate.toString() : undefined as any;
        return data;
    }
}

export interface IPolicyEnrollmentDto {
    id: string;
    memberId: string;
    policyId: string;
    enrollmentDate: DateTime;
    endDate: DateTime | undefined;
    status: PolicyEnrollmentStatus;
    referenceNumber: string | undefined;
    policyNumber: string | undefined;
    approvedDate: DateTime | undefined;
    rejectionReason: string | undefined;
    statusChangedDate: DateTime | undefined;
}

export enum PolicyEnrollmentStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class PolicyEnrollmentSummary implements IPolicyEnrollmentSummary {
    id!: string;
    policyName!: string | undefined;
    monthlyPremium!: number | undefined;
    status!: string | undefined;
    enrollmentDate!: DateTime | undefined;

    constructor(data?: IPolicyEnrollmentSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.policyName = _data["policyName"];
            this.monthlyPremium = _data["monthlyPremium"];
            this.status = _data["status"];
            this.enrollmentDate = _data["enrollmentDate"] ? DateTime.fromISO(_data["enrollmentDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): PolicyEnrollmentSummary {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyEnrollmentSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["policyName"] = this.policyName;
        data["monthlyPremium"] = this.monthlyPremium;
        data["status"] = this.status;
        data["enrollmentDate"] = this.enrollmentDate ? this.enrollmentDate.toString() : undefined as any;
        return data;
    }
}

export interface IPolicyEnrollmentSummary {
    id: string;
    policyName: string | undefined;
    monthlyPremium: number | undefined;
    status: string | undefined;
    enrollmentDate: DateTime | undefined;
}

export class PolicyNumberConfigDto implements IPolicyNumberConfigDto {
    generationStrategy!: string;
    prefix!: string | undefined;
    separator!: string | undefined;
    startingNumber!: number;
    currentNumber!: number;
    sequentialDigits!: number;
    randomLength!: number;
    includeLetters!: boolean;
    uppercase!: boolean;
    maxRetryAttempts!: number;
    exampleFormat!: string | undefined;

    constructor(data?: IPolicyNumberConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.generationStrategy = _data["generationStrategy"];
            this.prefix = _data["prefix"];
            this.separator = _data["separator"];
            this.startingNumber = _data["startingNumber"];
            this.currentNumber = _data["currentNumber"];
            this.sequentialDigits = _data["sequentialDigits"];
            this.randomLength = _data["randomLength"];
            this.includeLetters = _data["includeLetters"];
            this.uppercase = _data["uppercase"];
            this.maxRetryAttempts = _data["maxRetryAttempts"];
            this.exampleFormat = _data["exampleFormat"];
        }
    }

    static fromJS(data: any): PolicyNumberConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyNumberConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generationStrategy"] = this.generationStrategy;
        data["prefix"] = this.prefix;
        data["separator"] = this.separator;
        data["startingNumber"] = this.startingNumber;
        data["currentNumber"] = this.currentNumber;
        data["sequentialDigits"] = this.sequentialDigits;
        data["randomLength"] = this.randomLength;
        data["includeLetters"] = this.includeLetters;
        data["uppercase"] = this.uppercase;
        data["maxRetryAttempts"] = this.maxRetryAttempts;
        data["exampleFormat"] = this.exampleFormat;
        return data;
    }
}

export interface IPolicyNumberConfigDto {
    generationStrategy: string;
    prefix: string | undefined;
    separator: string | undefined;
    startingNumber: number;
    currentNumber: number;
    sequentialDigits: number;
    randomLength: number;
    includeLetters: boolean;
    uppercase: boolean;
    maxRetryAttempts: number;
    exampleFormat: string | undefined;
}

export class PolicyOptionDto implements IPolicyOptionDto {
    coverAmount!: number;
    monthlyPremium!: number;
    description!: string | undefined;
    isRecommended!: boolean;

    constructor(data?: IPolicyOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coverAmount = _data["coverAmount"];
            this.monthlyPremium = _data["monthlyPremium"];
            this.description = _data["description"];
            this.isRecommended = _data["isRecommended"];
        }
    }

    static fromJS(data: any): PolicyOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coverAmount"] = this.coverAmount;
        data["monthlyPremium"] = this.monthlyPremium;
        data["description"] = this.description;
        data["isRecommended"] = this.isRecommended;
        return data;
    }
}

export interface IPolicyOptionDto {
    coverAmount: number;
    monthlyPremium: number;
    description: string | undefined;
    isRecommended: boolean;
}

export enum PolicyStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class PremiumBreakdownItemDto implements IPremiumBreakdownItemDto {
    description!: string | undefined;
    amount!: number;
    category!: string | undefined;
    details!: string | undefined;

    constructor(data?: IPremiumBreakdownItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.category = _data["category"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): PremiumBreakdownItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PremiumBreakdownItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["category"] = this.category;
        data["details"] = this.details;
        return data;
    }
}

export interface IPremiumBreakdownItemDto {
    description: string | undefined;
    amount: number;
    category: string | undefined;
    details: string | undefined;
}

export class PremiumCalculationResultDto implements IPremiumCalculationResultDto {
    basePremium!: number;
    extendedFamilyPremium!: number;
    totalMonthlyPremium!: number;
    breakdown!: PremiumBreakdownItemDto[] | undefined;
    message!: string | undefined;

    constructor(data?: IPremiumCalculationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basePremium = _data["basePremium"];
            this.extendedFamilyPremium = _data["extendedFamilyPremium"];
            this.totalMonthlyPremium = _data["totalMonthlyPremium"];
            if (Array.isArray(_data["breakdown"])) {
                this.breakdown = [] as any;
                for (let item of _data["breakdown"])
                    this.breakdown!.push(PremiumBreakdownItemDto.fromJS(item));
            }
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): PremiumCalculationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PremiumCalculationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basePremium"] = this.basePremium;
        data["extendedFamilyPremium"] = this.extendedFamilyPremium;
        data["totalMonthlyPremium"] = this.totalMonthlyPremium;
        if (Array.isArray(this.breakdown)) {
            data["breakdown"] = [];
            for (let item of this.breakdown)
                data["breakdown"].push(item ? item.toJSON() : undefined as any);
        }
        data["message"] = this.message;
        return data;
    }
}

export interface IPremiumCalculationResultDto {
    basePremium: number;
    extendedFamilyPremium: number;
    totalMonthlyPremium: number;
    breakdown: PremiumBreakdownItemDto[] | undefined;
    message: string | undefined;
}

export class PremiumCalculationSettingsDto implements IPremiumCalculationSettingsDto {
    policyCoverTable!: PolicyCoverPremiumTableDto;
    extendedFamilyTable!: ExtendedFamilyBenefitTableDto;
    maxExtendedFamilyMembers!: number;

    constructor(data?: IPremiumCalculationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.policyCoverTable = _data["policyCoverTable"] ? PolicyCoverPremiumTableDto.fromJS(_data["policyCoverTable"]) : undefined as any;
            this.extendedFamilyTable = _data["extendedFamilyTable"] ? ExtendedFamilyBenefitTableDto.fromJS(_data["extendedFamilyTable"]) : undefined as any;
            this.maxExtendedFamilyMembers = _data["maxExtendedFamilyMembers"];
        }
    }

    static fromJS(data: any): PremiumCalculationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PremiumCalculationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyCoverTable"] = this.policyCoverTable ? this.policyCoverTable.toJSON() : undefined as any;
        data["extendedFamilyTable"] = this.extendedFamilyTable ? this.extendedFamilyTable.toJSON() : undefined as any;
        data["maxExtendedFamilyMembers"] = this.maxExtendedFamilyMembers;
        return data;
    }
}

export interface IPremiumCalculationSettingsDto {
    policyCoverTable: PolicyCoverPremiumTableDto;
    extendedFamilyTable: ExtendedFamilyBenefitTableDto;
    maxExtendedFamilyMembers: number;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | undefined;
    title!: string | undefined;
    status!: number | undefined;
    detail!: string | undefined;
    instance!: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type: string | undefined;
    title: string | undefined;
    status: number | undefined;
    detail: string | undefined;
    instance: string | undefined;

    [key: string]: any;
}

export class ProductDto implements IProductDto {
    id!: string;
    name!: string | undefined;
    sku!: string | undefined;
    description!: string | undefined;
    price!: number;
    compareAtPrice!: number | undefined;
    cost!: number | undefined;
    stockQuantity!: number;
    lowStockThreshold!: number | undefined;
    trackInventory!: boolean;
    isActive!: boolean;
    isFeatured!: boolean;
    categoryId!: string | undefined;
    categoryName!: string | undefined;
    metaTitle!: string | undefined;
    metaDescription!: string | undefined;
    metaKeywords!: string | undefined;
    weight!: number | undefined;
    length!: number | undefined;
    width!: number | undefined;
    height!: number | undefined;
    weightUnit!: string | undefined;
    dimensionUnit!: string | undefined;
    images!: ProductImageDto[] | undefined;
    variants!: ProductVariantDto[] | undefined;
    createdAt!: DateTime;
    updatedAt!: DateTime;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sku = _data["sku"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.compareAtPrice = _data["compareAtPrice"];
            this.cost = _data["cost"];
            this.stockQuantity = _data["stockQuantity"];
            this.lowStockThreshold = _data["lowStockThreshold"];
            this.trackInventory = _data["trackInventory"];
            this.isActive = _data["isActive"];
            this.isFeatured = _data["isFeatured"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.metaKeywords = _data["metaKeywords"];
            this.weight = _data["weight"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.weightUnit = _data["weightUnit"];
            this.dimensionUnit = _data["dimensionUnit"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ProductImageDto.fromJS(item));
            }
            if (Array.isArray(_data["variants"])) {
                this.variants = [] as any;
                for (let item of _data["variants"])
                    this.variants!.push(ProductVariantDto.fromJS(item));
            }
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sku"] = this.sku;
        data["description"] = this.description;
        data["price"] = this.price;
        data["compareAtPrice"] = this.compareAtPrice;
        data["cost"] = this.cost;
        data["stockQuantity"] = this.stockQuantity;
        data["lowStockThreshold"] = this.lowStockThreshold;
        data["trackInventory"] = this.trackInventory;
        data["isActive"] = this.isActive;
        data["isFeatured"] = this.isFeatured;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["metaKeywords"] = this.metaKeywords;
        data["weight"] = this.weight;
        data["length"] = this.length;
        data["width"] = this.width;
        data["height"] = this.height;
        data["weightUnit"] = this.weightUnit;
        data["dimensionUnit"] = this.dimensionUnit;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.variants)) {
            data["variants"] = [];
            for (let item of this.variants)
                data["variants"].push(item ? item.toJSON() : undefined as any);
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface IProductDto {
    id: string;
    name: string | undefined;
    sku: string | undefined;
    description: string | undefined;
    price: number;
    compareAtPrice: number | undefined;
    cost: number | undefined;
    stockQuantity: number;
    lowStockThreshold: number | undefined;
    trackInventory: boolean;
    isActive: boolean;
    isFeatured: boolean;
    categoryId: string | undefined;
    categoryName: string | undefined;
    metaTitle: string | undefined;
    metaDescription: string | undefined;
    metaKeywords: string | undefined;
    weight: number | undefined;
    length: number | undefined;
    width: number | undefined;
    height: number | undefined;
    weightUnit: string | undefined;
    dimensionUnit: string | undefined;
    images: ProductImageDto[] | undefined;
    variants: ProductVariantDto[] | undefined;
    createdAt: DateTime;
    updatedAt: DateTime;
}

export class ProductImageDto implements IProductImageDto {
    id!: string;
    productId!: string;
    imageUrl!: string | undefined;
    altText!: string | undefined;
    displayOrder!: number;
    isPrimary!: boolean;

    constructor(data?: IProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.imageUrl = _data["imageUrl"];
            this.altText = _data["altText"];
            this.displayOrder = _data["displayOrder"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): ProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["imageUrl"] = this.imageUrl;
        data["altText"] = this.altText;
        data["displayOrder"] = this.displayOrder;
        data["isPrimary"] = this.isPrimary;
        return data;
    }
}

export interface IProductImageDto {
    id: string;
    productId: string;
    imageUrl: string | undefined;
    altText: string | undefined;
    displayOrder: number;
    isPrimary: boolean;
}

export class ProductStatsDto implements IProductStatsDto {
    totalProducts!: number;
    activeProducts!: number;
    lowStockProducts!: number;
    totalInventoryValue!: number;
    featuredProducts!: number;
    totalCategories!: number;

    constructor(data?: IProductStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProducts = _data["totalProducts"];
            this.activeProducts = _data["activeProducts"];
            this.lowStockProducts = _data["lowStockProducts"];
            this.totalInventoryValue = _data["totalInventoryValue"];
            this.featuredProducts = _data["featuredProducts"];
            this.totalCategories = _data["totalCategories"];
        }
    }

    static fromJS(data: any): ProductStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProducts"] = this.totalProducts;
        data["activeProducts"] = this.activeProducts;
        data["lowStockProducts"] = this.lowStockProducts;
        data["totalInventoryValue"] = this.totalInventoryValue;
        data["featuredProducts"] = this.featuredProducts;
        data["totalCategories"] = this.totalCategories;
        return data;
    }
}

export interface IProductStatsDto {
    totalProducts: number;
    activeProducts: number;
    lowStockProducts: number;
    totalInventoryValue: number;
    featuredProducts: number;
    totalCategories: number;
}

export class ProductVariantDto implements IProductVariantDto {
    id!: string;
    productId!: string;
    name!: string | undefined;
    variantType!: string | undefined;
    sku!: string | undefined;
    priceAdjustment!: number | undefined;
    stockQuantity!: number;
    isActive!: boolean;

    constructor(data?: IProductVariantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.variantType = _data["variantType"];
            this.sku = _data["sku"];
            this.priceAdjustment = _data["priceAdjustment"];
            this.stockQuantity = _data["stockQuantity"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductVariantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductVariantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["variantType"] = this.variantType;
        data["sku"] = this.sku;
        data["priceAdjustment"] = this.priceAdjustment;
        data["stockQuantity"] = this.stockQuantity;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductVariantDto {
    id: string;
    productId: string;
    name: string | undefined;
    variantType: string | undefined;
    sku: string | undefined;
    priceAdjustment: number | undefined;
    stockQuantity: number;
    isActive: boolean;
}

export class ProfileCompletionStatusDto implements IProfileCompletionStatusDto {
    isComplete!: boolean;
    completionPercentage!: number;
    completedSteps!: string[] | undefined;
    remainingSteps!: string[] | undefined;
    nextStepRecommendation!: string | undefined;
    profileCompletion!: MemberProfileCompletionDto;
    dependentsCount!: number;
    beneficiariesCount!: number;
    uploadedDocumentsCount!: number;
    requiredDocumentsCount!: number;
    hasAcceptedLatestTerms!: boolean;
    memberStatus!: string | undefined;

    constructor(data?: IProfileCompletionStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isComplete = _data["isComplete"];
            this.completionPercentage = _data["completionPercentage"];
            if (Array.isArray(_data["completedSteps"])) {
                this.completedSteps = [] as any;
                for (let item of _data["completedSteps"])
                    this.completedSteps!.push(item);
            }
            if (Array.isArray(_data["remainingSteps"])) {
                this.remainingSteps = [] as any;
                for (let item of _data["remainingSteps"])
                    this.remainingSteps!.push(item);
            }
            this.nextStepRecommendation = _data["nextStepRecommendation"];
            this.profileCompletion = _data["profileCompletion"] ? MemberProfileCompletionDto.fromJS(_data["profileCompletion"]) : undefined as any;
            this.dependentsCount = _data["dependentsCount"];
            this.beneficiariesCount = _data["beneficiariesCount"];
            this.uploadedDocumentsCount = _data["uploadedDocumentsCount"];
            this.requiredDocumentsCount = _data["requiredDocumentsCount"];
            this.hasAcceptedLatestTerms = _data["hasAcceptedLatestTerms"];
            this.memberStatus = _data["memberStatus"];
        }
    }

    static fromJS(data: any): ProfileCompletionStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileCompletionStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isComplete"] = this.isComplete;
        data["completionPercentage"] = this.completionPercentage;
        if (Array.isArray(this.completedSteps)) {
            data["completedSteps"] = [];
            for (let item of this.completedSteps)
                data["completedSteps"].push(item);
        }
        if (Array.isArray(this.remainingSteps)) {
            data["remainingSteps"] = [];
            for (let item of this.remainingSteps)
                data["remainingSteps"].push(item);
        }
        data["nextStepRecommendation"] = this.nextStepRecommendation;
        data["profileCompletion"] = this.profileCompletion ? this.profileCompletion.toJSON() : undefined as any;
        data["dependentsCount"] = this.dependentsCount;
        data["beneficiariesCount"] = this.beneficiariesCount;
        data["uploadedDocumentsCount"] = this.uploadedDocumentsCount;
        data["requiredDocumentsCount"] = this.requiredDocumentsCount;
        data["hasAcceptedLatestTerms"] = this.hasAcceptedLatestTerms;
        data["memberStatus"] = this.memberStatus;
        return data;
    }
}

export interface IProfileCompletionStatusDto {
    isComplete: boolean;
    completionPercentage: number;
    completedSteps: string[] | undefined;
    remainingSteps: string[] | undefined;
    nextStepRecommendation: string | undefined;
    profileCompletion: MemberProfileCompletionDto;
    dependentsCount: number;
    beneficiariesCount: number;
    uploadedDocumentsCount: number;
    requiredDocumentsCount: number;
    hasAcceptedLatestTerms: boolean;
    memberStatus: string | undefined;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    refreshToken!: string | undefined;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenRequest {
    refreshToken: string | undefined;
}

export class RefundPaymentRequest implements IRefundPaymentRequest {
    amount!: number;
    reason!: string | undefined;

    constructor(data?: IRefundPaymentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): RefundPaymentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefundPaymentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IRefundPaymentRequest {
    amount: number;
    reason: string | undefined;
}

export class RefundResult implements IRefundResult {
    success!: boolean;
    message!: string | undefined;
    amount!: number;
    refundAmount!: number;
    refundId!: string | undefined;

    constructor(data?: IRefundResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.amount = _data["amount"];
            this.refundAmount = _data["refundAmount"];
            this.refundId = _data["refundId"];
        }
    }

    static fromJS(data: any): RefundResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefundResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["amount"] = this.amount;
        data["refundAmount"] = this.refundAmount;
        data["refundId"] = this.refundId;
        return data;
    }
}

export interface IRefundResult {
    success: boolean;
    message: string | undefined;
    amount: number;
    refundAmount: number;
    refundId: string | undefined;
}

export class RegisterNewMemberDto implements IRegisterNewMemberDto {
    idNumber!: string;
    email!: string;
    password!: string;
    firstNames!: string;
    surname!: string;
    phoneNumber!: string;
    selectedCoverAmount!: number;
    dateOfBirth!: DateTime | undefined;

    constructor(data?: IRegisterNewMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstNames = _data["firstNames"];
            this.surname = _data["surname"];
            this.phoneNumber = _data["phoneNumber"];
            this.selectedCoverAmount = _data["selectedCoverAmount"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): RegisterNewMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterNewMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstNames"] = this.firstNames;
        data["surname"] = this.surname;
        data["phoneNumber"] = this.phoneNumber;
        data["selectedCoverAmount"] = this.selectedCoverAmount;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        return data;
    }
}

export interface IRegisterNewMemberDto {
    idNumber: string;
    email: string;
    password: string;
    firstNames: string;
    surname: string;
    phoneNumber: string;
    selectedCoverAmount: number;
    dateOfBirth: DateTime | undefined;
}

export class RegisterRequest implements IRegisterRequest {
    email!: string;
    password!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    identificationNumber!: string | undefined;
    policyId!: string | undefined;
    customFields!: { [key: string]: string; } | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.identificationNumber = _data["identificationNumber"];
            this.policyId = _data["policyId"];
            if (_data["customFields"]) {
                this.customFields = {} as any;
                for (let key in _data["customFields"]) {
                    if (_data["customFields"].hasOwnProperty(key))
                        (this.customFields as any)![key] = _data["customFields"][key];
                }
            }
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["identificationNumber"] = this.identificationNumber;
        data["policyId"] = this.policyId;
        if (this.customFields) {
            data["customFields"] = {};
            for (let key in this.customFields) {
                if (this.customFields.hasOwnProperty(key))
                    (data["customFields"] as any)[key] = (this.customFields as any)[key];
            }
        }
        return data;
    }
}

export interface IRegisterRequest {
    email: string;
    password: string;
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    identificationNumber: string | undefined;
    policyId: string | undefined;
    customFields: { [key: string]: string; } | undefined;
}

export class RejectEnrollmentDto implements IRejectEnrollmentDto {
    reason!: string | undefined;

    constructor(data?: IRejectEnrollmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): RejectEnrollmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RejectEnrollmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        return data;
    }
}

export interface IRejectEnrollmentDto {
    reason: string | undefined;
}

export class RejectMemberRequest implements IRejectMemberRequest {
    memberId!: string;
    rejectionReason!: string | undefined;

    constructor(data?: IRejectMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.rejectionReason = _data["rejectionReason"];
        }
    }

    static fromJS(data: any): RejectMemberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RejectMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["rejectionReason"] = this.rejectionReason;
        return data;
    }
}

export interface IRejectMemberRequest {
    memberId: string;
    rejectionReason: string | undefined;
}

export class RejectTenantDto implements IRejectTenantDto {
    tenantId!: string;
    rejectionReason!: string | undefined;

    constructor(data?: IRejectTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.rejectionReason = _data["rejectionReason"];
        }
    }

    static fromJS(data: any): RejectTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new RejectTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["rejectionReason"] = this.rejectionReason;
        return data;
    }
}

export interface IRejectTenantDto {
    tenantId: string;
    rejectionReason: string | undefined;
}

export class RemovePermissionDto implements IRemovePermissionDto {
    tenantType!: TenantType;
    permissionName!: string | undefined;

    constructor(data?: IRemovePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantType = _data["tenantType"];
            this.permissionName = _data["permissionName"];
        }
    }

    static fromJS(data: any): RemovePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RemovePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantType"] = this.tenantType;
        data["permissionName"] = this.permissionName;
        return data;
    }
}

export interface IRemovePermissionDto {
    tenantType: TenantType;
    permissionName: string | undefined;
}

export class ReorderOnboardingStepsDto implements IReorderOnboardingStepsDto {
    stepOrders!: StepOrderDto[] | undefined;

    constructor(data?: IReorderOnboardingStepsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stepOrders"])) {
                this.stepOrders = [] as any;
                for (let item of _data["stepOrders"])
                    this.stepOrders!.push(StepOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReorderOnboardingStepsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReorderOnboardingStepsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stepOrders)) {
            data["stepOrders"] = [];
            for (let item of this.stepOrders)
                data["stepOrders"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IReorderOnboardingStepsDto {
    stepOrders: StepOrderDto[] | undefined;
}

export class ReorderStepFieldsDto implements IReorderStepFieldsDto {
    stepId!: string;
    stepFieldIds!: string[] | undefined;

    constructor(data?: IReorderStepFieldsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepId = _data["stepId"];
            if (Array.isArray(_data["stepFieldIds"])) {
                this.stepFieldIds = [] as any;
                for (let item of _data["stepFieldIds"])
                    this.stepFieldIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ReorderStepFieldsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReorderStepFieldsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stepId"] = this.stepId;
        if (Array.isArray(this.stepFieldIds)) {
            data["stepFieldIds"] = [];
            for (let item of this.stepFieldIds)
                data["stepFieldIds"].push(item);
        }
        return data;
    }
}

export interface IReorderStepFieldsDto {
    stepId: string;
    stepFieldIds: string[] | undefined;
}

export class RequestChangesDto implements IRequestChangesDto {
    reason!: string | undefined;

    constructor(data?: IRequestChangesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): RequestChangesDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestChangesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        return data;
    }
}

export interface IRequestChangesDto {
    reason: string | undefined;
}

export class RequestDependentOtpDto implements IRequestDependentOtpDto {
    idNumber!: string;
    contactMethod!: string;

    constructor(data?: IRequestDependentOtpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
            this.contactMethod = _data["contactMethod"];
        }
    }

    static fromJS(data: any): RequestDependentOtpDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDependentOtpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        data["contactMethod"] = this.contactMethod;
        return data;
    }
}

export interface IRequestDependentOtpDto {
    idNumber: string;
    contactMethod: string;
}

export class RequestMemberUpdatesRequest implements IRequestMemberUpdatesRequest {
    memberId!: string;
    updatesRequired!: string | undefined;
    requiredFields!: string[] | undefined;

    constructor(data?: IRequestMemberUpdatesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.updatesRequired = _data["updatesRequired"];
            if (Array.isArray(_data["requiredFields"])) {
                this.requiredFields = [] as any;
                for (let item of _data["requiredFields"])
                    this.requiredFields!.push(item);
            }
        }
    }

    static fromJS(data: any): RequestMemberUpdatesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RequestMemberUpdatesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["updatesRequired"] = this.updatesRequired;
        if (Array.isArray(this.requiredFields)) {
            data["requiredFields"] = [];
            for (let item of this.requiredFields)
                data["requiredFields"].push(item);
        }
        return data;
    }
}

export interface IRequestMemberUpdatesRequest {
    memberId: string;
    updatesRequired: string | undefined;
    requiredFields: string[] | undefined;
}

export class RequestTenantChangeDto implements IRequestTenantChangeDto {
    tenantId!: string;
    changeRequestReason!: string | undefined;

    constructor(data?: IRequestTenantChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.changeRequestReason = _data["changeRequestReason"];
        }
    }

    static fromJS(data: any): RequestTenantChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTenantChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["changeRequestReason"] = this.changeRequestReason;
        return data;
    }
}

export interface IRequestTenantChangeDto {
    tenantId: string;
    changeRequestReason: string | undefined;
}

export class RequiredDocumentDto implements IRequiredDocumentDto {
    id!: string;
    documentName!: string | undefined;
    description!: string | undefined;
    documentType!: RequiredDocumentType;
    entityType!: RequiredDocumentEntityType;
    isRequired!: boolean;
    allowedFileTypes!: string | undefined;
    maxFileSizeBytes!: number | undefined;

    constructor(data?: IRequiredDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentName = _data["documentName"];
            this.description = _data["description"];
            this.documentType = _data["documentType"];
            this.entityType = _data["entityType"];
            this.isRequired = _data["isRequired"];
            this.allowedFileTypes = _data["allowedFileTypes"];
            this.maxFileSizeBytes = _data["maxFileSizeBytes"];
        }
    }

    static fromJS(data: any): RequiredDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequiredDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentName"] = this.documentName;
        data["description"] = this.description;
        data["documentType"] = this.documentType;
        data["entityType"] = this.entityType;
        data["isRequired"] = this.isRequired;
        data["allowedFileTypes"] = this.allowedFileTypes;
        data["maxFileSizeBytes"] = this.maxFileSizeBytes;
        return data;
    }
}

export interface IRequiredDocumentDto {
    id: string;
    documentName: string | undefined;
    description: string | undefined;
    documentType: RequiredDocumentType;
    entityType: RequiredDocumentEntityType;
    isRequired: boolean;
    allowedFileTypes: string | undefined;
    maxFileSizeBytes: number | undefined;
}

export enum RequiredDocumentEntityType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum RequiredDocumentType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email!: string | undefined;
    code!: string | undefined;
    newPassword!: string | undefined;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.code = _data["code"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["code"] = this.code;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email: string | undefined;
    code: string | undefined;
    newPassword: string | undefined;
}

export class ResourceBookingDto implements IResourceBookingDto {
    id!: string;
    funeralEventId!: string;
    resourceId!: string;
    startTime!: DateTime;
    endTime!: DateTime;

    constructor(data?: IResourceBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.funeralEventId = _data["funeralEventId"];
            this.resourceId = _data["resourceId"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : undefined as any;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ResourceBookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceBookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["funeralEventId"] = this.funeralEventId;
        data["resourceId"] = this.resourceId;
        data["startTime"] = this.startTime ? this.startTime.toString() : undefined as any;
        data["endTime"] = this.endTime ? this.endTime.toString() : undefined as any;
        return data;
    }
}

export interface IResourceBookingDto {
    id: string;
    funeralEventId: string;
    resourceId: string;
    startTime: DateTime;
    endTime: DateTime;
}

export class ResourceDto implements IResourceDto {
    id!: string;
    name!: string | undefined;
    type!: string | undefined;
    description!: string | undefined;
    isAvailable!: boolean;

    constructor(data?: IResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["description"] = this.description;
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IResourceDto {
    id: string;
    name: string | undefined;
    type: string | undefined;
    description: string | undefined;
    isAvailable: boolean;
}

export class RevokeTokenRequest implements IRevokeTokenRequest {
    refreshToken!: string | undefined;

    constructor(data?: IRevokeTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RevokeTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RevokeTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRevokeTokenRequest {
    refreshToken: string | undefined;
}

export class Role implements IRole {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    tenantId!: string;
    name!: string;
    rolePermissions!: RolePermission[] | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            if (Array.isArray(_data["rolePermissions"])) {
                this.rolePermissions = [] as any;
                for (let item of _data["rolePermissions"])
                    this.rolePermissions!.push(RolePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        if (Array.isArray(this.rolePermissions)) {
            data["rolePermissions"] = [];
            for (let item of this.rolePermissions)
                data["rolePermissions"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRole {
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    tenantId: string;
    name: string;
    rolePermissions: RolePermission[] | undefined;
}

export class RoleDto implements IRoleDto {
    id!: string;
    name!: string | undefined;
    permissions!: PermissionDto[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRoleDto {
    id: string;
    name: string | undefined;
    permissions: PermissionDto[] | undefined;
}

export class RoleInput implements IRoleInput {
    name!: string;

    constructor(data?: IRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new RoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IRoleInput {
    name: string;
}

export class RolePermission implements IRolePermission {
    id!: string;
    roleId!: string;
    permissionId!: string;
    role!: Role;
    permission!: Permission;

    constructor(data?: IRolePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.permissionId = _data["permissionId"];
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : undefined as any;
            this.permission = _data["permission"] ? Permission.fromJS(_data["permission"]) : undefined as any;
        }
    }

    static fromJS(data: any): RolePermission {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["permissionId"] = this.permissionId;
        data["role"] = this.role ? this.role.toJSON() : undefined as any;
        data["permission"] = this.permission ? this.permission.toJSON() : undefined as any;
        return data;
    }
}

export interface IRolePermission {
    id: string;
    roleId: string;
    permissionId: string;
    role: Role;
    permission: Permission;
}

export class SaveMemberOnboardingDataDto implements ISaveMemberOnboardingDataDto {
    fieldValues!: { [key: string]: string; };

    constructor(data?: ISaveMemberOnboardingDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.fieldValues = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["fieldValues"]) {
                this.fieldValues = {} as any;
                for (let key in _data["fieldValues"]) {
                    if (_data["fieldValues"].hasOwnProperty(key))
                        (this.fieldValues as any)![key] = _data["fieldValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): SaveMemberOnboardingDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveMemberOnboardingDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fieldValues) {
            data["fieldValues"] = {};
            for (let key in this.fieldValues) {
                if (this.fieldValues.hasOwnProperty(key))
                    (data["fieldValues"] as any)[key] = (this.fieldValues as any)[key];
            }
        }
        return data;
    }
}

export interface ISaveMemberOnboardingDataDto {
    fieldValues: { [key: string]: string; };
}

export class SaveSignatureDto implements ISaveSignatureDto {
    signatureDataUrl!: string;

    constructor(data?: ISaveSignatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signatureDataUrl = _data["signatureDataUrl"];
        }
    }

    static fromJS(data: any): SaveSignatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveSignatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signatureDataUrl"] = this.signatureDataUrl;
        return data;
    }
}

export interface ISaveSignatureDto {
    signatureDataUrl: string;
}

export class ScheduleMaintenanceDto implements IScheduleMaintenanceDto {
    assetId!: string;
    maintenanceDate!: DateTime;
    notes!: string | undefined;

    constructor(data?: IScheduleMaintenanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetId = _data["assetId"];
            this.maintenanceDate = _data["maintenanceDate"] ? DateTime.fromISO(_data["maintenanceDate"].toString()) : undefined as any;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ScheduleMaintenanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleMaintenanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetId"] = this.assetId;
        data["maintenanceDate"] = this.maintenanceDate ? this.maintenanceDate.toString() : undefined as any;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IScheduleMaintenanceDto {
    assetId: string;
    maintenanceDate: DateTime;
    notes: string | undefined;
}

export class SendBookingNotificationDto implements ISendBookingNotificationDto {
    booking!: BookingDto;
    config!: BookingNotificationConfigDto;

    constructor(data?: ISendBookingNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.booking = _data["booking"] ? BookingDto.fromJS(_data["booking"]) : undefined as any;
            this.config = _data["config"] ? BookingNotificationConfigDto.fromJS(_data["config"]) : undefined as any;
        }
    }

    static fromJS(data: any): SendBookingNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendBookingNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["booking"] = this.booking ? this.booking.toJSON() : undefined as any;
        data["config"] = this.config ? this.config.toJSON() : undefined as any;
        return data;
    }
}

export interface ISendBookingNotificationDto {
    booking: BookingDto;
    config: BookingNotificationConfigDto;
}

export class SignContractRequest implements ISignContractRequest {
    contractId!: string;
    signatureBase64!: string | undefined;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;
    geoLocation!: string | undefined;
    signatureX!: number;
    signatureY!: number;
    signatureWidth!: number;
    signatureHeight!: number;

    constructor(data?: ISignContractRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.signatureBase64 = _data["signatureBase64"];
            this.ipAddress = _data["ipAddress"];
            this.userAgent = _data["userAgent"];
            this.geoLocation = _data["geoLocation"];
            this.signatureX = _data["signatureX"];
            this.signatureY = _data["signatureY"];
            this.signatureWidth = _data["signatureWidth"];
            this.signatureHeight = _data["signatureHeight"];
        }
    }

    static fromJS(data: any): SignContractRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignContractRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["signatureBase64"] = this.signatureBase64;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["geoLocation"] = this.geoLocation;
        data["signatureX"] = this.signatureX;
        data["signatureY"] = this.signatureY;
        data["signatureWidth"] = this.signatureWidth;
        data["signatureHeight"] = this.signatureHeight;
        return data;
    }
}

export interface ISignContractRequest {
    contractId: string;
    signatureBase64: string | undefined;
    ipAddress: string | undefined;
    userAgent: string | undefined;
    geoLocation: string | undefined;
    signatureX: number;
    signatureY: number;
    signatureWidth: number;
    signatureHeight: number;
}

export enum SourceOfIncome {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum SouthAfricanProvince {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
}

export class StepOrderDto implements IStepOrderDto {
    id!: string;
    displayOrder!: number;

    constructor(data?: IStepOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): StepOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new StepOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IStepOrderDto {
    id: string;
    displayOrder: number;
}

export class SubscriptionPlan implements ISubscriptionPlan {
    id!: string;
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    monthlyPrice!: number;
    yearlyPrice!: number;
    allowedTenantType!: TenantType;
    readonly price!: number;
    readonly durationMonths!: number;
    features!: string | undefined;
    readonly supportsIdentityVerification!: boolean;
    readonly maxVerificationsPerMonth!: number;

    constructor(data?: ISubscriptionPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.yearlyPrice = _data["yearlyPrice"];
            this.allowedTenantType = _data["allowedTenantType"];
            (this as any).price = _data["price"];
            (this as any).durationMonths = _data["durationMonths"];
            this.features = _data["features"];
            (this as any).supportsIdentityVerification = _data["supportsIdentityVerification"];
            (this as any).maxVerificationsPerMonth = _data["maxVerificationsPerMonth"];
        }
    }

    static fromJS(data: any): SubscriptionPlan {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["name"] = this.name;
        data["description"] = this.description;
        data["monthlyPrice"] = this.monthlyPrice;
        data["yearlyPrice"] = this.yearlyPrice;
        data["allowedTenantType"] = this.allowedTenantType;
        data["price"] = this.price;
        data["durationMonths"] = this.durationMonths;
        data["features"] = this.features;
        data["supportsIdentityVerification"] = this.supportsIdentityVerification;
        data["maxVerificationsPerMonth"] = this.maxVerificationsPerMonth;
        return data;
    }
}

export interface ISubscriptionPlan {
    id: string;
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    name: string | undefined;
    description: string | undefined;
    monthlyPrice: number;
    yearlyPrice: number;
    allowedTenantType: TenantType;
    price: number;
    durationMonths: number;
    features: string | undefined;
    supportsIdentityVerification: boolean;
    maxVerificationsPerMonth: number;
}

export class SubscriptionPlanConfigurationDto implements ISubscriptionPlanConfigurationDto {
    id!: string;
    subscriptionPlanId!: string | undefined;
    tenantType!: number;
    tenantTypeName!: string | undefined;
    planName!: string | undefined;
    description!: string | undefined;
    isActive!: boolean;
    monthlyPrice!: number;
    yearlyPrice!: number;
    displayOrder!: number;
    maxUsers!: number;
    maxStorageMB!: number;
    maxProducts!: number | undefined;
    maxMembers!: number | undefined;
    maxProductImagesPerProduct!: number | undefined;
    maxActiveOrders!: number | undefined;
    apiRateLimitPerMinute!: number;
    apiRateLimitPerDay!: number;
    overageUserPrice!: number;
    overageStoragePricePerGB!: number;
    overageProductPricePer100!: number | undefined;
    overageMemberPricePer100!: number | undefined;
    canUploadFiles!: boolean;
    canCreateSubAccounts!: boolean;
    canExportData!: boolean;
    canUseAPI!: boolean;
    canUseLandingPageBuilder!: boolean;
    canUseCustomDomain!: boolean;
    canAccessAdvancedReports!: boolean;
    canUseWhiteLabel!: boolean;
    hasPrioritySupport!: boolean;
    allowOverage!: boolean;
    sendUsageAlerts!: boolean;
    usageAlertThresholdPercent!: number;
    trialDays!: number;
    requiresCreditCard!: boolean;
    canDowngrade!: boolean;
    canUpgrade!: boolean;
    maxLandingPages!: number;
    maxEmailTemplates!: number;
    maxCustomForms!: number;
    createdAt!: DateTime | undefined;
    updatedAt!: DateTime | undefined;

    constructor(data?: ISubscriptionPlanConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.tenantType = _data["tenantType"];
            this.tenantTypeName = _data["tenantTypeName"];
            this.planName = _data["planName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.yearlyPrice = _data["yearlyPrice"];
            this.displayOrder = _data["displayOrder"];
            this.maxUsers = _data["maxUsers"];
            this.maxStorageMB = _data["maxStorageMB"];
            this.maxProducts = _data["maxProducts"];
            this.maxMembers = _data["maxMembers"];
            this.maxProductImagesPerProduct = _data["maxProductImagesPerProduct"];
            this.maxActiveOrders = _data["maxActiveOrders"];
            this.apiRateLimitPerMinute = _data["apiRateLimitPerMinute"];
            this.apiRateLimitPerDay = _data["apiRateLimitPerDay"];
            this.overageUserPrice = _data["overageUserPrice"];
            this.overageStoragePricePerGB = _data["overageStoragePricePerGB"];
            this.overageProductPricePer100 = _data["overageProductPricePer100"];
            this.overageMemberPricePer100 = _data["overageMemberPricePer100"];
            this.canUploadFiles = _data["canUploadFiles"];
            this.canCreateSubAccounts = _data["canCreateSubAccounts"];
            this.canExportData = _data["canExportData"];
            this.canUseAPI = _data["canUseAPI"];
            this.canUseLandingPageBuilder = _data["canUseLandingPageBuilder"];
            this.canUseCustomDomain = _data["canUseCustomDomain"];
            this.canAccessAdvancedReports = _data["canAccessAdvancedReports"];
            this.canUseWhiteLabel = _data["canUseWhiteLabel"];
            this.hasPrioritySupport = _data["hasPrioritySupport"];
            this.allowOverage = _data["allowOverage"];
            this.sendUsageAlerts = _data["sendUsageAlerts"];
            this.usageAlertThresholdPercent = _data["usageAlertThresholdPercent"];
            this.trialDays = _data["trialDays"];
            this.requiresCreditCard = _data["requiresCreditCard"];
            this.canDowngrade = _data["canDowngrade"];
            this.canUpgrade = _data["canUpgrade"];
            this.maxLandingPages = _data["maxLandingPages"];
            this.maxEmailTemplates = _data["maxEmailTemplates"];
            this.maxCustomForms = _data["maxCustomForms"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SubscriptionPlanConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["tenantType"] = this.tenantType;
        data["tenantTypeName"] = this.tenantTypeName;
        data["planName"] = this.planName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["monthlyPrice"] = this.monthlyPrice;
        data["yearlyPrice"] = this.yearlyPrice;
        data["displayOrder"] = this.displayOrder;
        data["maxUsers"] = this.maxUsers;
        data["maxStorageMB"] = this.maxStorageMB;
        data["maxProducts"] = this.maxProducts;
        data["maxMembers"] = this.maxMembers;
        data["maxProductImagesPerProduct"] = this.maxProductImagesPerProduct;
        data["maxActiveOrders"] = this.maxActiveOrders;
        data["apiRateLimitPerMinute"] = this.apiRateLimitPerMinute;
        data["apiRateLimitPerDay"] = this.apiRateLimitPerDay;
        data["overageUserPrice"] = this.overageUserPrice;
        data["overageStoragePricePerGB"] = this.overageStoragePricePerGB;
        data["overageProductPricePer100"] = this.overageProductPricePer100;
        data["overageMemberPricePer100"] = this.overageMemberPricePer100;
        data["canUploadFiles"] = this.canUploadFiles;
        data["canCreateSubAccounts"] = this.canCreateSubAccounts;
        data["canExportData"] = this.canExportData;
        data["canUseAPI"] = this.canUseAPI;
        data["canUseLandingPageBuilder"] = this.canUseLandingPageBuilder;
        data["canUseCustomDomain"] = this.canUseCustomDomain;
        data["canAccessAdvancedReports"] = this.canAccessAdvancedReports;
        data["canUseWhiteLabel"] = this.canUseWhiteLabel;
        data["hasPrioritySupport"] = this.hasPrioritySupport;
        data["allowOverage"] = this.allowOverage;
        data["sendUsageAlerts"] = this.sendUsageAlerts;
        data["usageAlertThresholdPercent"] = this.usageAlertThresholdPercent;
        data["trialDays"] = this.trialDays;
        data["requiresCreditCard"] = this.requiresCreditCard;
        data["canDowngrade"] = this.canDowngrade;
        data["canUpgrade"] = this.canUpgrade;
        data["maxLandingPages"] = this.maxLandingPages;
        data["maxEmailTemplates"] = this.maxEmailTemplates;
        data["maxCustomForms"] = this.maxCustomForms;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        return data;
    }
}

export interface ISubscriptionPlanConfigurationDto {
    id: string;
    subscriptionPlanId: string | undefined;
    tenantType: number;
    tenantTypeName: string | undefined;
    planName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    monthlyPrice: number;
    yearlyPrice: number;
    displayOrder: number;
    maxUsers: number;
    maxStorageMB: number;
    maxProducts: number | undefined;
    maxMembers: number | undefined;
    maxProductImagesPerProduct: number | undefined;
    maxActiveOrders: number | undefined;
    apiRateLimitPerMinute: number;
    apiRateLimitPerDay: number;
    overageUserPrice: number;
    overageStoragePricePerGB: number;
    overageProductPricePer100: number | undefined;
    overageMemberPricePer100: number | undefined;
    canUploadFiles: boolean;
    canCreateSubAccounts: boolean;
    canExportData: boolean;
    canUseAPI: boolean;
    canUseLandingPageBuilder: boolean;
    canUseCustomDomain: boolean;
    canAccessAdvancedReports: boolean;
    canUseWhiteLabel: boolean;
    hasPrioritySupport: boolean;
    allowOverage: boolean;
    sendUsageAlerts: boolean;
    usageAlertThresholdPercent: number;
    trialDays: number;
    requiresCreditCard: boolean;
    canDowngrade: boolean;
    canUpgrade: boolean;
    maxLandingPages: number;
    maxEmailTemplates: number;
    maxCustomForms: number;
    createdAt: DateTime | undefined;
    updatedAt: DateTime | undefined;
}

export class SubscriptionPlanDto implements ISubscriptionPlanDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    monthlyPrice!: number;
    yearlyPrice!: number;
    allowedTenantType!: TenantType;
    features!: string | undefined;
    supportsIdentityVerification!: boolean;
    maxVerificationsPerMonth!: number;
    enhancedVerification!: boolean;
    quickIdCheck!: boolean;
    bulkVerification!: boolean;
    verificationHistory!: boolean;

    constructor(data?: ISubscriptionPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.yearlyPrice = _data["yearlyPrice"];
            this.allowedTenantType = _data["allowedTenantType"];
            this.features = _data["features"];
            this.supportsIdentityVerification = _data["supportsIdentityVerification"];
            this.maxVerificationsPerMonth = _data["maxVerificationsPerMonth"];
            this.enhancedVerification = _data["enhancedVerification"];
            this.quickIdCheck = _data["quickIdCheck"];
            this.bulkVerification = _data["bulkVerification"];
            this.verificationHistory = _data["verificationHistory"];
        }
    }

    static fromJS(data: any): SubscriptionPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["monthlyPrice"] = this.monthlyPrice;
        data["yearlyPrice"] = this.yearlyPrice;
        data["allowedTenantType"] = this.allowedTenantType;
        data["features"] = this.features;
        data["supportsIdentityVerification"] = this.supportsIdentityVerification;
        data["maxVerificationsPerMonth"] = this.maxVerificationsPerMonth;
        data["enhancedVerification"] = this.enhancedVerification;
        data["quickIdCheck"] = this.quickIdCheck;
        data["bulkVerification"] = this.bulkVerification;
        data["verificationHistory"] = this.verificationHistory;
        return data;
    }
}

export interface ISubscriptionPlanDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    monthlyPrice: number;
    yearlyPrice: number;
    allowedTenantType: TenantType;
    features: string | undefined;
    supportsIdentityVerification: boolean;
    maxVerificationsPerMonth: number;
    enhancedVerification: boolean;
    quickIdCheck: boolean;
    bulkVerification: boolean;
    verificationHistory: boolean;
}

export enum SubscriptionStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class SuspendSubscriptionDto implements ISuspendSubscriptionDto {
    subscriptionId!: string;
    tenantId!: string;
    reason!: string | undefined;
    suspendedBy!: string;

    constructor(data?: ISuspendSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.tenantId = _data["tenantId"];
            this.reason = _data["reason"];
            this.suspendedBy = _data["suspendedBy"];
        }
    }

    static fromJS(data: any): SuspendSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SuspendSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["tenantId"] = this.tenantId;
        data["reason"] = this.reason;
        data["suspendedBy"] = this.suspendedBy;
        return data;
    }
}

export interface ISuspendSubscriptionDto {
    subscriptionId: string;
    tenantId: string;
    reason: string | undefined;
    suspendedBy: string;
}

export class Tenant implements ITenant {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    name!: string | undefined;
    domain!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    registrationNumber!: string | undefined;
    users!: User[] | undefined;
    type!: TenantType;
    subscriptionPlanId!: string | undefined;
    subscriptionPlan!: SubscriptionPlan;
    subscriptionStartDate!: DateTime | undefined;
    lastInvoiceDate!: DateTime | undefined;
    approvalStatus!: TenantApprovalStatus;
    rejectionReason!: string | undefined;
    changeRequestReason!: string | undefined;
    reviewedBy!: string | undefined;
    reviewedAt!: DateTime | undefined;

    constructor(data?: ITenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.domain = _data["domain"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.registrationNumber = _data["registrationNumber"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
            this.type = _data["type"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.subscriptionPlan = _data["subscriptionPlan"] ? SubscriptionPlan.fromJS(_data["subscriptionPlan"]) : undefined as any;
            this.subscriptionStartDate = _data["subscriptionStartDate"] ? DateTime.fromISO(_data["subscriptionStartDate"].toString()) : undefined as any;
            this.lastInvoiceDate = _data["lastInvoiceDate"] ? DateTime.fromISO(_data["lastInvoiceDate"].toString()) : undefined as any;
            this.approvalStatus = _data["approvalStatus"];
            this.rejectionReason = _data["rejectionReason"];
            this.changeRequestReason = _data["changeRequestReason"];
            this.reviewedBy = _data["reviewedBy"];
            this.reviewedAt = _data["reviewedAt"] ? DateTime.fromISO(_data["reviewedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): Tenant {
        data = typeof data === 'object' ? data : {};
        let result = new Tenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["name"] = this.name;
        data["domain"] = this.domain;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["registrationNumber"] = this.registrationNumber;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item ? item.toJSON() : undefined as any);
        }
        data["type"] = this.type;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["subscriptionPlan"] = this.subscriptionPlan ? this.subscriptionPlan.toJSON() : undefined as any;
        data["subscriptionStartDate"] = this.subscriptionStartDate ? this.subscriptionStartDate.toString() : undefined as any;
        data["lastInvoiceDate"] = this.lastInvoiceDate ? this.lastInvoiceDate.toString() : undefined as any;
        data["approvalStatus"] = this.approvalStatus;
        data["rejectionReason"] = this.rejectionReason;
        data["changeRequestReason"] = this.changeRequestReason;
        data["reviewedBy"] = this.reviewedBy;
        data["reviewedAt"] = this.reviewedAt ? this.reviewedAt.toString() : undefined as any;
        return data;
    }
}

export interface ITenant {
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    name: string | undefined;
    domain: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    registrationNumber: string | undefined;
    users: User[] | undefined;
    type: TenantType;
    subscriptionPlanId: string | undefined;
    subscriptionPlan: SubscriptionPlan;
    subscriptionStartDate: DateTime | undefined;
    lastInvoiceDate: DateTime | undefined;
    approvalStatus: TenantApprovalStatus;
    rejectionReason: string | undefined;
    changeRequestReason: string | undefined;
    reviewedBy: string | undefined;
    reviewedAt: DateTime | undefined;
}

export class TenantApprovalDetailDto implements ITenantApprovalDetailDto {
    id!: string;
    name!: string | undefined;
    domain!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    registrationNumber!: string | undefined;
    type!: TenantType;
    approvalStatus!: TenantApprovalStatus;
    rejectionReason!: string | undefined;
    changeRequestReason!: string | undefined;
    createdAt!: DateTime | undefined;
    reviewedAt!: DateTime | undefined;
    reviewedByName!: string | undefined;

    constructor(data?: ITenantApprovalDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.domain = _data["domain"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.registrationNumber = _data["registrationNumber"];
            this.type = _data["type"];
            this.approvalStatus = _data["approvalStatus"];
            this.rejectionReason = _data["rejectionReason"];
            this.changeRequestReason = _data["changeRequestReason"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.reviewedAt = _data["reviewedAt"] ? DateTime.fromISO(_data["reviewedAt"].toString()) : undefined as any;
            this.reviewedByName = _data["reviewedByName"];
        }
    }

    static fromJS(data: any): TenantApprovalDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantApprovalDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["domain"] = this.domain;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["registrationNumber"] = this.registrationNumber;
        data["type"] = this.type;
        data["approvalStatus"] = this.approvalStatus;
        data["rejectionReason"] = this.rejectionReason;
        data["changeRequestReason"] = this.changeRequestReason;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["reviewedAt"] = this.reviewedAt ? this.reviewedAt.toString() : undefined as any;
        data["reviewedByName"] = this.reviewedByName;
        return data;
    }
}

export interface ITenantApprovalDetailDto {
    id: string;
    name: string | undefined;
    domain: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    registrationNumber: string | undefined;
    type: TenantType;
    approvalStatus: TenantApprovalStatus;
    rejectionReason: string | undefined;
    changeRequestReason: string | undefined;
    createdAt: DateTime | undefined;
    reviewedAt: DateTime | undefined;
    reviewedByName: string | undefined;
}

export class TenantApprovalListDto implements ITenantApprovalListDto {
    id!: string;
    name!: string | undefined;
    domain!: string | undefined;
    email!: string | undefined;
    phone1!: string | undefined;
    registrationNumber!: string | undefined;
    address!: string | undefined;
    approvalStatus!: TenantApprovalStatus;
    createdAt!: DateTime | undefined;
    rejectionReason!: string | undefined;
    changeRequestReason!: string | undefined;

    constructor(data?: ITenantApprovalListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.domain = _data["domain"];
            this.email = _data["email"];
            this.phone1 = _data["phone1"];
            this.registrationNumber = _data["registrationNumber"];
            this.address = _data["address"];
            this.approvalStatus = _data["approvalStatus"];
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.rejectionReason = _data["rejectionReason"];
            this.changeRequestReason = _data["changeRequestReason"];
        }
    }

    static fromJS(data: any): TenantApprovalListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantApprovalListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["domain"] = this.domain;
        data["email"] = this.email;
        data["phone1"] = this.phone1;
        data["registrationNumber"] = this.registrationNumber;
        data["address"] = this.address;
        data["approvalStatus"] = this.approvalStatus;
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["rejectionReason"] = this.rejectionReason;
        data["changeRequestReason"] = this.changeRequestReason;
        return data;
    }
}

export interface ITenantApprovalListDto {
    id: string;
    name: string | undefined;
    domain: string | undefined;
    email: string | undefined;
    phone1: string | undefined;
    registrationNumber: string | undefined;
    address: string | undefined;
    approvalStatus: TenantApprovalStatus;
    createdAt: DateTime | undefined;
    rejectionReason: string | undefined;
    changeRequestReason: string | undefined;
}

export enum TenantApprovalStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantBankingDetailDto implements ITenantBankingDetailDto {
    id!: string;
    tenantId!: string;
    bankName!: string | undefined;
    accountNumber!: string | undefined;
    accountType!: string | undefined;
    branchCode!: string | undefined;
    branchName!: string | undefined;
    accountHolderName!: string | undefined;
    debitDay!: number | undefined;
    paymentMethod!: PaymentMethodType;
    mandateReference!: string | undefined;
    mandateSignedDate!: DateTime | undefined;
    isVerified!: boolean;
    isActive!: boolean;

    constructor(data?: ITenantBankingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.accountType = _data["accountType"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.accountHolderName = _data["accountHolderName"];
            this.debitDay = _data["debitDay"];
            this.paymentMethod = _data["paymentMethod"];
            this.mandateReference = _data["mandateReference"];
            this.mandateSignedDate = _data["mandateSignedDate"] ? DateTime.fromISO(_data["mandateSignedDate"].toString()) : undefined as any;
            this.isVerified = _data["isVerified"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantBankingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBankingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["accountType"] = this.accountType;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["accountHolderName"] = this.accountHolderName;
        data["debitDay"] = this.debitDay;
        data["paymentMethod"] = this.paymentMethod;
        data["mandateReference"] = this.mandateReference;
        data["mandateSignedDate"] = this.mandateSignedDate ? this.mandateSignedDate.toString() : undefined as any;
        data["isVerified"] = this.isVerified;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITenantBankingDetailDto {
    id: string;
    tenantId: string;
    bankName: string | undefined;
    accountNumber: string | undefined;
    accountType: string | undefined;
    branchCode: string | undefined;
    branchName: string | undefined;
    accountHolderName: string | undefined;
    debitDay: number | undefined;
    paymentMethod: PaymentMethodType;
    mandateReference: string | undefined;
    mandateSignedDate: DateTime | undefined;
    isVerified: boolean;
    isActive: boolean;
}

export class TenantCreateUpdateDto implements ITenantCreateUpdateDto {
    id!: string;
    email!: string;
    password!: string | undefined;
    name!: string;
    domain!: string;
    address!: string | undefined;
    phone1!: string | undefined;
    phone2!: string | undefined;
    registrationNumber!: string | undefined;
    type!: TenantType;
    subscriptionPlanId!: string | undefined;
    selectedPlanConfigurationId!: string | undefined;
    couponCode!: string | undefined;
    billingCycle!: number;
    isStaticSite!: boolean;
    organizationFeatures!: { [key: string]: any; } | undefined;

    constructor(data?: ITenantCreateUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.name = _data["name"];
            this.domain = _data["domain"];
            this.address = _data["address"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
            this.registrationNumber = _data["registrationNumber"];
            this.type = _data["type"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.selectedPlanConfigurationId = _data["selectedPlanConfigurationId"];
            this.couponCode = _data["couponCode"];
            this.billingCycle = _data["billingCycle"];
            this.isStaticSite = _data["isStaticSite"];
            if (_data["organizationFeatures"]) {
                this.organizationFeatures = {} as any;
                for (let key in _data["organizationFeatures"]) {
                    if (_data["organizationFeatures"].hasOwnProperty(key))
                        (this.organizationFeatures as any)![key] = _data["organizationFeatures"][key];
                }
            }
        }
    }

    static fromJS(data: any): TenantCreateUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantCreateUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["password"] = this.password;
        data["name"] = this.name;
        data["domain"] = this.domain;
        data["address"] = this.address;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["registrationNumber"] = this.registrationNumber;
        data["type"] = this.type;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["selectedPlanConfigurationId"] = this.selectedPlanConfigurationId;
        data["couponCode"] = this.couponCode;
        data["billingCycle"] = this.billingCycle;
        data["isStaticSite"] = this.isStaticSite;
        if (this.organizationFeatures) {
            data["organizationFeatures"] = {};
            for (let key in this.organizationFeatures) {
                if (this.organizationFeatures.hasOwnProperty(key))
                    (data["organizationFeatures"] as any)[key] = (this.organizationFeatures as any)[key];
            }
        }
        return data;
    }
}

export interface ITenantCreateUpdateDto {
    id: string;
    email: string;
    password: string | undefined;
    name: string;
    domain: string;
    address: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
    registrationNumber: string | undefined;
    type: TenantType;
    subscriptionPlanId: string | undefined;
    selectedPlanConfigurationId: string | undefined;
    couponCode: string | undefined;
    billingCycle: number;
    isStaticSite: boolean;
    organizationFeatures: { [key: string]: any; } | undefined;
}

export class TenantSettingDto implements ITenantSettingDto {
    id!: string;
    settings!: string | undefined;
    logo!: string | undefined;
    favicon!: string | undefined;
    tenantName!: string | undefined;
    contractTemplateFileId!: string | undefined;
    enableIdVerification!: boolean;
    requireIdVerificationForRegistration!: boolean;
    hasEmailCredentials!: boolean;
    hasPaymentCredentials!: boolean;

    constructor(data?: ITenantSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.settings = _data["settings"];
            this.logo = _data["logo"];
            this.favicon = _data["favicon"];
            this.tenantName = _data["tenantName"];
            this.contractTemplateFileId = _data["contractTemplateFileId"];
            this.enableIdVerification = _data["enableIdVerification"];
            this.requireIdVerificationForRegistration = _data["requireIdVerificationForRegistration"];
            this.hasEmailCredentials = _data["hasEmailCredentials"];
            this.hasPaymentCredentials = _data["hasPaymentCredentials"];
        }
    }

    static fromJS(data: any): TenantSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["settings"] = this.settings;
        data["logo"] = this.logo;
        data["favicon"] = this.favicon;
        data["tenantName"] = this.tenantName;
        data["contractTemplateFileId"] = this.contractTemplateFileId;
        data["enableIdVerification"] = this.enableIdVerification;
        data["requireIdVerificationForRegistration"] = this.requireIdVerificationForRegistration;
        data["hasEmailCredentials"] = this.hasEmailCredentials;
        data["hasPaymentCredentials"] = this.hasPaymentCredentials;
        return data;
    }
}

export interface ITenantSettingDto {
    id: string;
    settings: string | undefined;
    logo: string | undefined;
    favicon: string | undefined;
    tenantName: string | undefined;
    contractTemplateFileId: string | undefined;
    enableIdVerification: boolean;
    requireIdVerificationForRegistration: boolean;
    hasEmailCredentials: boolean;
    hasPaymentCredentials: boolean;
}

export class TenantSubscription implements ITenantSubscription {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    tenantId!: string;
    tenant!: Tenant;
    subscriptionPlanId!: string;
    subscriptionPlan!: SubscriptionPlan;
    status!: SubscriptionStatus;
    currentPeriodStart!: DateTime;
    currentPeriodEnd!: DateTime;
    nextBillingDate!: DateTime | undefined;
    cancelAtPeriodEnd!: boolean;
    cancelledAt!: DateTime | undefined;
    cancellationReason!: string | undefined;
    suspendedAt!: DateTime | undefined;
    suspensionReason!: string | undefined;
    suspendedBy!: string | undefined;
    trialEndsAt!: DateTime | undefined;
    isInTrial!: boolean;
    autoRenew!: boolean;
    failedPaymentAttempts!: number;
    lastFailedPaymentDate!: DateTime | undefined;
    appliedCouponCode!: string | undefined;
    couponMonthsRemaining!: number | undefined;
    paymentGatewaySubscriptionId!: string | undefined;

    constructor(data?: ITenantSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : undefined as any;
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.subscriptionPlan = _data["subscriptionPlan"] ? SubscriptionPlan.fromJS(_data["subscriptionPlan"]) : undefined as any;
            this.status = _data["status"];
            this.currentPeriodStart = _data["currentPeriodStart"] ? DateTime.fromISO(_data["currentPeriodStart"].toString()) : undefined as any;
            this.currentPeriodEnd = _data["currentPeriodEnd"] ? DateTime.fromISO(_data["currentPeriodEnd"].toString()) : undefined as any;
            this.nextBillingDate = _data["nextBillingDate"] ? DateTime.fromISO(_data["nextBillingDate"].toString()) : undefined as any;
            this.cancelAtPeriodEnd = _data["cancelAtPeriodEnd"];
            this.cancelledAt = _data["cancelledAt"] ? DateTime.fromISO(_data["cancelledAt"].toString()) : undefined as any;
            this.cancellationReason = _data["cancellationReason"];
            this.suspendedAt = _data["suspendedAt"] ? DateTime.fromISO(_data["suspendedAt"].toString()) : undefined as any;
            this.suspensionReason = _data["suspensionReason"];
            this.suspendedBy = _data["suspendedBy"];
            this.trialEndsAt = _data["trialEndsAt"] ? DateTime.fromISO(_data["trialEndsAt"].toString()) : undefined as any;
            this.isInTrial = _data["isInTrial"];
            this.autoRenew = _data["autoRenew"];
            this.failedPaymentAttempts = _data["failedPaymentAttempts"];
            this.lastFailedPaymentDate = _data["lastFailedPaymentDate"] ? DateTime.fromISO(_data["lastFailedPaymentDate"].toString()) : undefined as any;
            this.appliedCouponCode = _data["appliedCouponCode"];
            this.couponMonthsRemaining = _data["couponMonthsRemaining"];
            this.paymentGatewaySubscriptionId = _data["paymentGatewaySubscriptionId"];
        }
    }

    static fromJS(data: any): TenantSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : undefined as any;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["subscriptionPlan"] = this.subscriptionPlan ? this.subscriptionPlan.toJSON() : undefined as any;
        data["status"] = this.status;
        data["currentPeriodStart"] = this.currentPeriodStart ? this.currentPeriodStart.toString() : undefined as any;
        data["currentPeriodEnd"] = this.currentPeriodEnd ? this.currentPeriodEnd.toString() : undefined as any;
        data["nextBillingDate"] = this.nextBillingDate ? this.nextBillingDate.toString() : undefined as any;
        data["cancelAtPeriodEnd"] = this.cancelAtPeriodEnd;
        data["cancelledAt"] = this.cancelledAt ? this.cancelledAt.toString() : undefined as any;
        data["cancellationReason"] = this.cancellationReason;
        data["suspendedAt"] = this.suspendedAt ? this.suspendedAt.toString() : undefined as any;
        data["suspensionReason"] = this.suspensionReason;
        data["suspendedBy"] = this.suspendedBy;
        data["trialEndsAt"] = this.trialEndsAt ? this.trialEndsAt.toString() : undefined as any;
        data["isInTrial"] = this.isInTrial;
        data["autoRenew"] = this.autoRenew;
        data["failedPaymentAttempts"] = this.failedPaymentAttempts;
        data["lastFailedPaymentDate"] = this.lastFailedPaymentDate ? this.lastFailedPaymentDate.toString() : undefined as any;
        data["appliedCouponCode"] = this.appliedCouponCode;
        data["couponMonthsRemaining"] = this.couponMonthsRemaining;
        data["paymentGatewaySubscriptionId"] = this.paymentGatewaySubscriptionId;
        return data;
    }
}

export interface ITenantSubscription {
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    tenantId: string;
    tenant: Tenant;
    subscriptionPlanId: string;
    subscriptionPlan: SubscriptionPlan;
    status: SubscriptionStatus;
    currentPeriodStart: DateTime;
    currentPeriodEnd: DateTime;
    nextBillingDate: DateTime | undefined;
    cancelAtPeriodEnd: boolean;
    cancelledAt: DateTime | undefined;
    cancellationReason: string | undefined;
    suspendedAt: DateTime | undefined;
    suspensionReason: string | undefined;
    suspendedBy: string | undefined;
    trialEndsAt: DateTime | undefined;
    isInTrial: boolean;
    autoRenew: boolean;
    failedPaymentAttempts: number;
    lastFailedPaymentDate: DateTime | undefined;
    appliedCouponCode: string | undefined;
    couponMonthsRemaining: number | undefined;
    paymentGatewaySubscriptionId: string | undefined;
}

export enum TenantType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _20 = 20,
    _21 = 21,
    _22 = 22,
    _23 = 23,
    _100 = 100,
    _101 = 101,
    _102 = 102,
}

export class TenantTypeDto implements ITenantTypeDto {
    value!: number;
    name!: string | undefined;
    label!: string | undefined;
    description!: string | undefined;

    constructor(data?: ITenantTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
            this.label = _data["label"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TenantTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        data["label"] = this.label;
        data["description"] = this.description;
        return data;
    }
}

export interface ITenantTypeDto {
    value: number;
    name: string | undefined;
    label: string | undefined;
    description: string | undefined;
}

export class TenantTypePermission implements ITenantTypePermission {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    tenantType!: TenantType;
    permissionName!: string;
    description!: string;

    constructor(data?: ITenantTypePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.tenantType = _data["tenantType"];
            this.permissionName = _data["permissionName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TenantTypePermission {
        data = typeof data === 'object' ? data : {};
        let result = new TenantTypePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["tenantType"] = this.tenantType;
        data["permissionName"] = this.permissionName;
        data["description"] = this.description;
        return data;
    }
}

export interface ITenantTypePermission {
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    tenantType: TenantType;
    permissionName: string;
    description: string;
}

export class TermsAcceptanceDto implements ITermsAcceptanceDto {
    id!: string;
    memberId!: string;
    termsAndConditionsId!: string;
    acceptedAt!: DateTime;
    acceptedVersion!: string | undefined;
    ipAddress!: string | undefined;

    constructor(data?: ITermsAcceptanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.termsAndConditionsId = _data["termsAndConditionsId"];
            this.acceptedAt = _data["acceptedAt"] ? DateTime.fromISO(_data["acceptedAt"].toString()) : undefined as any;
            this.acceptedVersion = _data["acceptedVersion"];
            this.ipAddress = _data["ipAddress"];
        }
    }

    static fromJS(data: any): TermsAcceptanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TermsAcceptanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["termsAndConditionsId"] = this.termsAndConditionsId;
        data["acceptedAt"] = this.acceptedAt ? this.acceptedAt.toString() : undefined as any;
        data["acceptedVersion"] = this.acceptedVersion;
        data["ipAddress"] = this.ipAddress;
        return data;
    }
}

export interface ITermsAcceptanceDto {
    id: string;
    memberId: string;
    termsAndConditionsId: string;
    acceptedAt: DateTime;
    acceptedVersion: string | undefined;
    ipAddress: string | undefined;
}

export class TermsAndConditionsDto implements ITermsAndConditionsDto {
    id!: string;
    title!: string | undefined;
    content!: string | undefined;
    version!: string | undefined;
    isActive!: boolean;
    effectiveDate!: DateTime;
    expiryDate!: DateTime | undefined;

    constructor(data?: ITermsAndConditionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.version = _data["version"];
            this.isActive = _data["isActive"];
            this.effectiveDate = _data["effectiveDate"] ? DateTime.fromISO(_data["effectiveDate"].toString()) : undefined as any;
            this.expiryDate = _data["expiryDate"] ? DateTime.fromISO(_data["expiryDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): TermsAndConditionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TermsAndConditionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["version"] = this.version;
        data["isActive"] = this.isActive;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toString() : undefined as any;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toString() : undefined as any;
        return data;
    }
}

export interface ITermsAndConditionsDto {
    id: string;
    title: string | undefined;
    content: string | undefined;
    version: string | undefined;
    isActive: boolean;
    effectiveDate: DateTime;
    expiryDate: DateTime | undefined;
}

export class TimesheetEntryDto implements ITimesheetEntryDto {
    id!: string;
    userId!: string;
    date!: DateTime;
    hoursWorked!: string;
    description!: string | undefined;

    constructor(data?: ITimesheetEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : undefined as any;
            this.hoursWorked = _data["hoursWorked"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TimesheetEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimesheetEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["date"] = this.date ? this.date.toString() : undefined as any;
        data["hoursWorked"] = this.hoursWorked;
        data["description"] = this.description;
        return data;
    }
}

export interface ITimesheetEntryDto {
    id: string;
    userId: string;
    date: DateTime;
    hoursWorked: string;
    description: string | undefined;
}

export class ToggleStatusDto implements IToggleStatusDto {
    isActive!: boolean;

    constructor(data?: IToggleStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ToggleStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ToggleStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IToggleStatusDto {
    isActive: boolean;
}

export class TopCouponDto implements ITopCouponDto {
    code!: string | undefined;
    name!: string | undefined;
    redemptions!: number;
    totalDiscount!: number;

    constructor(data?: ITopCouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.redemptions = _data["redemptions"];
            this.totalDiscount = _data["totalDiscount"];
        }
    }

    static fromJS(data: any): TopCouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopCouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["redemptions"] = this.redemptions;
        data["totalDiscount"] = this.totalDiscount;
        return data;
    }
}

export interface ITopCouponDto {
    code: string | undefined;
    name: string | undefined;
    redemptions: number;
    totalDiscount: number;
}

export class UpdateAssetDto implements IUpdateAssetDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    assetType!: AssetType;
    status!: AssetStatus;
    identificationNumber!: string | undefined;
    make!: string | undefined;
    model!: string | undefined;
    year!: number | undefined;
    quantity!: number;
    currentLocation!: string | undefined;
    requiresInspection!: boolean;
    inspectionCheckpoints!: string[] | undefined;
    lastMaintenanceDate!: DateTime | undefined;
    nextMaintenanceDate!: DateTime | undefined;
    conditionNotes!: string | undefined;

    constructor(data?: IUpdateAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.assetType = _data["assetType"];
            this.status = _data["status"];
            this.identificationNumber = _data["identificationNumber"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.year = _data["year"];
            this.quantity = _data["quantity"];
            this.currentLocation = _data["currentLocation"];
            this.requiresInspection = _data["requiresInspection"];
            if (Array.isArray(_data["inspectionCheckpoints"])) {
                this.inspectionCheckpoints = [] as any;
                for (let item of _data["inspectionCheckpoints"])
                    this.inspectionCheckpoints!.push(item);
            }
            this.lastMaintenanceDate = _data["lastMaintenanceDate"] ? DateTime.fromISO(_data["lastMaintenanceDate"].toString()) : undefined as any;
            this.nextMaintenanceDate = _data["nextMaintenanceDate"] ? DateTime.fromISO(_data["nextMaintenanceDate"].toString()) : undefined as any;
            this.conditionNotes = _data["conditionNotes"];
        }
    }

    static fromJS(data: any): UpdateAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["assetType"] = this.assetType;
        data["status"] = this.status;
        data["identificationNumber"] = this.identificationNumber;
        data["make"] = this.make;
        data["model"] = this.model;
        data["year"] = this.year;
        data["quantity"] = this.quantity;
        data["currentLocation"] = this.currentLocation;
        data["requiresInspection"] = this.requiresInspection;
        if (Array.isArray(this.inspectionCheckpoints)) {
            data["inspectionCheckpoints"] = [];
            for (let item of this.inspectionCheckpoints)
                data["inspectionCheckpoints"].push(item);
        }
        data["lastMaintenanceDate"] = this.lastMaintenanceDate ? this.lastMaintenanceDate.toString() : undefined as any;
        data["nextMaintenanceDate"] = this.nextMaintenanceDate ? this.nextMaintenanceDate.toString() : undefined as any;
        data["conditionNotes"] = this.conditionNotes;
        return data;
    }
}

export interface IUpdateAssetDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    assetType: AssetType;
    status: AssetStatus;
    identificationNumber: string | undefined;
    make: string | undefined;
    model: string | undefined;
    year: number | undefined;
    quantity: number;
    currentLocation: string | undefined;
    requiresInspection: boolean;
    inspectionCheckpoints: string[] | undefined;
    lastMaintenanceDate: DateTime | undefined;
    nextMaintenanceDate: DateTime | undefined;
    conditionNotes: string | undefined;
}

export class UpdateBookingStatusDto implements IUpdateBookingStatusDto {
    status!: string | undefined;

    constructor(data?: IUpdateBookingStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateBookingStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBookingStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateBookingStatusDto {
    status: string | undefined;
}

export class UpdateCouponDto implements IUpdateCouponDto {
    name!: string | undefined;
    description!: string | undefined;
    validUntil!: DateTime | undefined;
    maxRedemptions!: number | undefined;
    isActive!: boolean | undefined;
    internalNotes!: string | undefined;

    constructor(data?: IUpdateCouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.validUntil = _data["validUntil"] ? DateTime.fromISO(_data["validUntil"].toString()) : undefined as any;
            this.maxRedemptions = _data["maxRedemptions"];
            this.isActive = _data["isActive"];
            this.internalNotes = _data["internalNotes"];
        }
    }

    static fromJS(data: any): UpdateCouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["validUntil"] = this.validUntil ? this.validUntil.toString() : undefined as any;
        data["maxRedemptions"] = this.maxRedemptions;
        data["isActive"] = this.isActive;
        data["internalNotes"] = this.internalNotes;
        return data;
    }
}

export interface IUpdateCouponDto {
    name: string | undefined;
    description: string | undefined;
    validUntil: DateTime | undefined;
    maxRedemptions: number | undefined;
    isActive: boolean | undefined;
    internalNotes: string | undefined;
}

export class UpdateCustomerDto implements IUpdateCustomerDto {
    firstName!: string;
    lastName!: string;
    email!: string;
    phone!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    isActive!: boolean;
    acceptsMarketing!: boolean;
    notes!: string | undefined;
    addresses!: CreateCustomerAddressDto[] | undefined;
    id!: string;

    constructor(data?: IUpdateCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.isActive = _data["isActive"];
            this.acceptsMarketing = _data["acceptsMarketing"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CreateCustomerAddressDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["isActive"] = this.isActive;
        data["acceptsMarketing"] = this.acceptsMarketing;
        data["notes"] = this.notes;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateCustomerDto {
    firstName: string;
    lastName: string;
    email: string;
    phone: string | undefined;
    dateOfBirth: DateTime | undefined;
    isActive: boolean;
    acceptsMarketing: boolean;
    notes: string | undefined;
    addresses: CreateCustomerAddressDto[] | undefined;
    id: string;
}

export class UpdateDashboardWidgetSettingDto implements IUpdateDashboardWidgetSettingDto {
    id!: string;
    isVisible!: boolean;
    allowedRoles!: string[] | undefined;
    displayOrder!: number;

    constructor(data?: IUpdateDashboardWidgetSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isVisible = _data["isVisible"];
            if (Array.isArray(_data["allowedRoles"])) {
                this.allowedRoles = [] as any;
                for (let item of _data["allowedRoles"])
                    this.allowedRoles!.push(item);
            }
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): UpdateDashboardWidgetSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDashboardWidgetSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isVisible"] = this.isVisible;
        if (Array.isArray(this.allowedRoles)) {
            data["allowedRoles"] = [];
            for (let item of this.allowedRoles)
                data["allowedRoles"].push(item);
        }
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IUpdateDashboardWidgetSettingDto {
    id: string;
    isVisible: boolean;
    allowedRoles: string[] | undefined;
    displayOrder: number;
}

export class UpdateFieldOrderDto implements IUpdateFieldOrderDto {
    fieldId!: string;
    displayOrder!: number;

    constructor(data?: IUpdateFieldOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): UpdateFieldOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFieldOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IUpdateFieldOrderDto {
    fieldId: string;
    displayOrder: number;
}

export class UpdateMemberBankingDetailDto implements IUpdateMemberBankingDetailDto {
    bankName!: string | undefined;
    accountNumber!: string | undefined;
    accountType!: string | undefined;
    branchCode!: string | undefined;
    branchName!: string | undefined;
    accountHolderName!: string | undefined;
    debitDay!: number | undefined;
    paymentMethod!: PaymentMethodType;

    constructor(data?: IUpdateMemberBankingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.accountType = _data["accountType"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.accountHolderName = _data["accountHolderName"];
            this.debitDay = _data["debitDay"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): UpdateMemberBankingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMemberBankingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["accountType"] = this.accountType;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["accountHolderName"] = this.accountHolderName;
        data["debitDay"] = this.debitDay;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }
}

export interface IUpdateMemberBankingDetailDto {
    bankName: string | undefined;
    accountNumber: string | undefined;
    accountType: string | undefined;
    branchCode: string | undefined;
    branchName: string | undefined;
    accountHolderName: string | undefined;
    debitDay: number | undefined;
    paymentMethod: PaymentMethodType;
}

export class UpdateOnboardingFieldConfigurationDto implements IUpdateOnboardingFieldConfigurationDto {
    fieldContext!: string | undefined;
    id!: string;
    fieldKey!: string;
    fieldLabel!: string;
    fieldType!: string;
    category!: string | undefined;
    isRequired!: boolean;
    isEnabled!: boolean;
    displayOrder!: number;
    placeholder!: string | undefined;
    helpText!: string | undefined;
    optionsJson!: string | undefined;
    validationRulesJson!: string | undefined;
    defaultValue!: string | undefined;
    maxLength!: number | undefined;
    minLength!: number | undefined;

    constructor(data?: IUpdateOnboardingFieldConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldContext = _data["fieldContext"];
            this.id = _data["id"];
            this.fieldKey = _data["fieldKey"];
            this.fieldLabel = _data["fieldLabel"];
            this.fieldType = _data["fieldType"];
            this.category = _data["category"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.placeholder = _data["placeholder"];
            this.helpText = _data["helpText"];
            this.optionsJson = _data["optionsJson"];
            this.validationRulesJson = _data["validationRulesJson"];
            this.defaultValue = _data["defaultValue"];
            this.maxLength = _data["maxLength"];
            this.minLength = _data["minLength"];
        }
    }

    static fromJS(data: any): UpdateOnboardingFieldConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOnboardingFieldConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldContext"] = this.fieldContext;
        data["id"] = this.id;
        data["fieldKey"] = this.fieldKey;
        data["fieldLabel"] = this.fieldLabel;
        data["fieldType"] = this.fieldType;
        data["category"] = this.category;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["placeholder"] = this.placeholder;
        data["helpText"] = this.helpText;
        data["optionsJson"] = this.optionsJson;
        data["validationRulesJson"] = this.validationRulesJson;
        data["defaultValue"] = this.defaultValue;
        data["maxLength"] = this.maxLength;
        data["minLength"] = this.minLength;
        return data;
    }
}

export interface IUpdateOnboardingFieldConfigurationDto {
    fieldContext: string | undefined;
    id: string;
    fieldKey: string;
    fieldLabel: string;
    fieldType: string;
    category: string | undefined;
    isRequired: boolean;
    isEnabled: boolean;
    displayOrder: number;
    placeholder: string | undefined;
    helpText: string | undefined;
    optionsJson: string | undefined;
    validationRulesJson: string | undefined;
    defaultValue: string | undefined;
    maxLength: number | undefined;
    minLength: number | undefined;
}

export class UpdateOnboardingFieldDefinitionDto implements IUpdateOnboardingFieldDefinitionDto {
    id!: string;
    fieldKey!: string | undefined;
    fieldLabel!: string | undefined;
    placeholder!: string | undefined;
    helpText!: string | undefined;
    fieldType!: string | undefined;
    isRequired!: boolean;
    isEnabled!: boolean;
    validationRules!: string | undefined;
    options!: string | undefined;
    defaultValue!: string | undefined;
    displayOrder!: number;
    cssClass!: string | undefined;
    icon!: string | undefined;
    minValue!: number | undefined;
    maxValue!: number | undefined;
    maxLength!: number | undefined;
    isUnique!: boolean;
    conditionalDisplay!: string | undefined;

    constructor(data?: IUpdateOnboardingFieldDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldKey = _data["fieldKey"];
            this.fieldLabel = _data["fieldLabel"];
            this.placeholder = _data["placeholder"];
            this.helpText = _data["helpText"];
            this.fieldType = _data["fieldType"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.validationRules = _data["validationRules"];
            this.options = _data["options"];
            this.defaultValue = _data["defaultValue"];
            this.displayOrder = _data["displayOrder"];
            this.cssClass = _data["cssClass"];
            this.icon = _data["icon"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
            this.maxLength = _data["maxLength"];
            this.isUnique = _data["isUnique"];
            this.conditionalDisplay = _data["conditionalDisplay"];
        }
    }

    static fromJS(data: any): UpdateOnboardingFieldDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOnboardingFieldDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldKey"] = this.fieldKey;
        data["fieldLabel"] = this.fieldLabel;
        data["placeholder"] = this.placeholder;
        data["helpText"] = this.helpText;
        data["fieldType"] = this.fieldType;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["validationRules"] = this.validationRules;
        data["options"] = this.options;
        data["defaultValue"] = this.defaultValue;
        data["displayOrder"] = this.displayOrder;
        data["cssClass"] = this.cssClass;
        data["icon"] = this.icon;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        data["maxLength"] = this.maxLength;
        data["isUnique"] = this.isUnique;
        data["conditionalDisplay"] = this.conditionalDisplay;
        return data;
    }
}

export interface IUpdateOnboardingFieldDefinitionDto {
    id: string;
    fieldKey: string | undefined;
    fieldLabel: string | undefined;
    placeholder: string | undefined;
    helpText: string | undefined;
    fieldType: string | undefined;
    isRequired: boolean;
    isEnabled: boolean;
    validationRules: string | undefined;
    options: string | undefined;
    defaultValue: string | undefined;
    displayOrder: number;
    cssClass: string | undefined;
    icon: string | undefined;
    minValue: number | undefined;
    maxValue: number | undefined;
    maxLength: number | undefined;
    isUnique: boolean;
    conditionalDisplay: string | undefined;
}

export class UpdateOnboardingFieldGroupDto implements IUpdateOnboardingFieldGroupDto {
    id!: string;
    groupKey!: string | undefined;
    groupName!: string | undefined;
    description!: string | undefined;
    isEnabled!: boolean;
    displayOrder!: number;
    icon!: string | undefined;
    cssClass!: string | undefined;
    isCollapsible!: boolean;
    isCollapsedByDefault!: boolean;
    fieldIds!: string | undefined;

    constructor(data?: IUpdateOnboardingFieldGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupKey = _data["groupKey"];
            this.groupName = _data["groupName"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.icon = _data["icon"];
            this.cssClass = _data["cssClass"];
            this.isCollapsible = _data["isCollapsible"];
            this.isCollapsedByDefault = _data["isCollapsedByDefault"];
            this.fieldIds = _data["fieldIds"];
        }
    }

    static fromJS(data: any): UpdateOnboardingFieldGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOnboardingFieldGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupKey"] = this.groupKey;
        data["groupName"] = this.groupName;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["icon"] = this.icon;
        data["cssClass"] = this.cssClass;
        data["isCollapsible"] = this.isCollapsible;
        data["isCollapsedByDefault"] = this.isCollapsedByDefault;
        data["fieldIds"] = this.fieldIds;
        return data;
    }
}

export interface IUpdateOnboardingFieldGroupDto {
    id: string;
    groupKey: string | undefined;
    groupName: string | undefined;
    description: string | undefined;
    isEnabled: boolean;
    displayOrder: number;
    icon: string | undefined;
    cssClass: string | undefined;
    isCollapsible: boolean;
    isCollapsedByDefault: boolean;
    fieldIds: string | undefined;
}

export class UpdateOnboardingStepConfigurationDto implements IUpdateOnboardingStepConfigurationDto {
    id!: string;
    stepType!: OnboardingStepType;
    stepLabel!: string | undefined;
    tenantTypeFilter!: string | undefined;
    displayOrder!: number;
    isRequired!: boolean;
    isEnabled!: boolean;
    description!: string | undefined;
    icon!: string | undefined;
    isSkippable!: boolean;
    pdfTemplateFileId!: string | undefined;
    autoGeneratePdf!: boolean;
    includeStepDataKeys!: string | undefined;
    requireTypedSignature!: boolean;
    termsContentMode!: string | undefined;
    termsPdfFileId!: string | undefined;
    termsTextContent!: string | undefined;
    termsTitle!: string | undefined;
    termsAcceptanceLabel!: string | undefined;
    requireFullReview!: boolean;

    constructor(data?: IUpdateOnboardingStepConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.stepType = _data["stepType"];
            this.stepLabel = _data["stepLabel"];
            this.tenantTypeFilter = _data["tenantTypeFilter"];
            this.displayOrder = _data["displayOrder"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.description = _data["description"];
            this.icon = _data["icon"];
            this.isSkippable = _data["isSkippable"];
            this.pdfTemplateFileId = _data["pdfTemplateFileId"];
            this.autoGeneratePdf = _data["autoGeneratePdf"];
            this.includeStepDataKeys = _data["includeStepDataKeys"];
            this.requireTypedSignature = _data["requireTypedSignature"];
            this.termsContentMode = _data["termsContentMode"];
            this.termsPdfFileId = _data["termsPdfFileId"];
            this.termsTextContent = _data["termsTextContent"];
            this.termsTitle = _data["termsTitle"];
            this.termsAcceptanceLabel = _data["termsAcceptanceLabel"];
            this.requireFullReview = _data["requireFullReview"];
        }
    }

    static fromJS(data: any): UpdateOnboardingStepConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOnboardingStepConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stepType"] = this.stepType;
        data["stepLabel"] = this.stepLabel;
        data["tenantTypeFilter"] = this.tenantTypeFilter;
        data["displayOrder"] = this.displayOrder;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["description"] = this.description;
        data["icon"] = this.icon;
        data["isSkippable"] = this.isSkippable;
        data["pdfTemplateFileId"] = this.pdfTemplateFileId;
        data["autoGeneratePdf"] = this.autoGeneratePdf;
        data["includeStepDataKeys"] = this.includeStepDataKeys;
        data["requireTypedSignature"] = this.requireTypedSignature;
        data["termsContentMode"] = this.termsContentMode;
        data["termsPdfFileId"] = this.termsPdfFileId;
        data["termsTextContent"] = this.termsTextContent;
        data["termsTitle"] = this.termsTitle;
        data["termsAcceptanceLabel"] = this.termsAcceptanceLabel;
        data["requireFullReview"] = this.requireFullReview;
        return data;
    }
}

export interface IUpdateOnboardingStepConfigurationDto {
    id: string;
    stepType: OnboardingStepType;
    stepLabel: string | undefined;
    tenantTypeFilter: string | undefined;
    displayOrder: number;
    isRequired: boolean;
    isEnabled: boolean;
    description: string | undefined;
    icon: string | undefined;
    isSkippable: boolean;
    pdfTemplateFileId: string | undefined;
    autoGeneratePdf: boolean;
    includeStepDataKeys: string | undefined;
    requireTypedSignature: boolean;
    termsContentMode: string | undefined;
    termsPdfFileId: string | undefined;
    termsTextContent: string | undefined;
    termsTitle: string | undefined;
    termsAcceptanceLabel: string | undefined;
    requireFullReview: boolean;
}

export class UpdateOnboardingStepFieldDto implements IUpdateOnboardingStepFieldDto {
    id!: string;
    displayOrder!: number;
    isRequired!: boolean;
    isEnabled!: boolean;
    conditionalDisplay!: string | undefined;

    constructor(data?: IUpdateOnboardingStepFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayOrder = _data["displayOrder"];
            this.isRequired = _data["isRequired"];
            this.isEnabled = _data["isEnabled"];
            this.conditionalDisplay = _data["conditionalDisplay"];
        }
    }

    static fromJS(data: any): UpdateOnboardingStepFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOnboardingStepFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayOrder"] = this.displayOrder;
        data["isRequired"] = this.isRequired;
        data["isEnabled"] = this.isEnabled;
        data["conditionalDisplay"] = this.conditionalDisplay;
        return data;
    }
}

export interface IUpdateOnboardingStepFieldDto {
    id: string;
    displayOrder: number;
    isRequired: boolean;
    isEnabled: boolean;
    conditionalDisplay: string | undefined;
}

export class UpdateOrderDto implements IUpdateOrderDto {
    location!: string | undefined;
    order!: number;

    constructor(data?: IUpdateOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): UpdateOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["order"] = this.order;
        return data;
    }
}

export interface IUpdateOrderDto {
    location: string | undefined;
    order: number;
}

export class UpdateOrderStatusDto implements IUpdateOrderStatusDto {
    orderId!: string;
    status!: OrderStatus;
    note!: string | undefined;

    constructor(data?: IUpdateOrderStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.status = _data["status"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateOrderStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["status"] = this.status;
        data["note"] = this.note;
        return data;
    }
}

export interface IUpdateOrderStatusDto {
    orderId: string;
    status: OrderStatus;
    note: string | undefined;
}

export class UpdatePageDto implements IUpdatePageDto {
    name!: string | undefined;
    slug!: string | undefined;
    title!: string | undefined;
    description!: string | undefined;
    content!: PageWidgetDto[] | undefined;
    isPublic!: boolean;
    requiresAuth!: boolean;
    showInNavbar!: boolean;
    showInFooter!: boolean;
    isActive!: boolean;
    navbarOrder!: number | undefined;
    footerOrder!: number | undefined;
    metaTags!: PageMetaTagsDto;

    constructor(data?: IUpdatePageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["content"])) {
                this.content = [] as any;
                for (let item of _data["content"])
                    this.content!.push(PageWidgetDto.fromJS(item));
            }
            this.isPublic = _data["isPublic"];
            this.requiresAuth = _data["requiresAuth"];
            this.showInNavbar = _data["showInNavbar"];
            this.showInFooter = _data["showInFooter"];
            this.isActive = _data["isActive"];
            this.navbarOrder = _data["navbarOrder"];
            this.footerOrder = _data["footerOrder"];
            this.metaTags = _data["metaTags"] ? PageMetaTagsDto.fromJS(_data["metaTags"]) : undefined as any;
        }
    }

    static fromJS(data: any): UpdatePageDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item ? item.toJSON() : undefined as any);
        }
        data["isPublic"] = this.isPublic;
        data["requiresAuth"] = this.requiresAuth;
        data["showInNavbar"] = this.showInNavbar;
        data["showInFooter"] = this.showInFooter;
        data["isActive"] = this.isActive;
        data["navbarOrder"] = this.navbarOrder;
        data["footerOrder"] = this.footerOrder;
        data["metaTags"] = this.metaTags ? this.metaTags.toJSON() : undefined as any;
        return data;
    }
}

export interface IUpdatePageDto {
    name: string | undefined;
    slug: string | undefined;
    title: string | undefined;
    description: string | undefined;
    content: PageWidgetDto[] | undefined;
    isPublic: boolean;
    requiresAuth: boolean;
    showInNavbar: boolean;
    showInFooter: boolean;
    isActive: boolean;
    navbarOrder: number | undefined;
    footerOrder: number | undefined;
    metaTags: PageMetaTagsDto;
}

export class UpdatePdfFieldMappingRequest implements IUpdatePdfFieldMappingRequest {
    sourceField!: string | undefined;
    pdfFieldName!: string | undefined;
    mappingType!: string | undefined;
    isEnabled!: boolean | undefined;
    displayOrder!: number | undefined;
    description!: string | undefined;
    conditionalRulesJson!: string | undefined;
    transformRule!: string | undefined;
    defaultValue!: string | undefined;
    checkedValue!: string | undefined;
    uncheckedValue!: string | undefined;
    category!: string | undefined;
    isArrayField!: boolean | undefined;
    arrayName!: string | undefined;
    arrayFieldPattern!: string | undefined;
    arrayMaxItems!: number | undefined;
    sourceArrayPath!: string | undefined;
    fieldNamePrefix!: string | undefined;
    usePrefixInPdfFieldName!: boolean | undefined;

    constructor(data?: IUpdatePdfFieldMappingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceField = _data["sourceField"];
            this.pdfFieldName = _data["pdfFieldName"];
            this.mappingType = _data["mappingType"];
            this.isEnabled = _data["isEnabled"];
            this.displayOrder = _data["displayOrder"];
            this.description = _data["description"];
            this.conditionalRulesJson = _data["conditionalRulesJson"];
            this.transformRule = _data["transformRule"];
            this.defaultValue = _data["defaultValue"];
            this.checkedValue = _data["checkedValue"];
            this.uncheckedValue = _data["uncheckedValue"];
            this.category = _data["category"];
            this.isArrayField = _data["isArrayField"];
            this.arrayName = _data["arrayName"];
            this.arrayFieldPattern = _data["arrayFieldPattern"];
            this.arrayMaxItems = _data["arrayMaxItems"];
            this.sourceArrayPath = _data["sourceArrayPath"];
            this.fieldNamePrefix = _data["fieldNamePrefix"];
            this.usePrefixInPdfFieldName = _data["usePrefixInPdfFieldName"];
        }
    }

    static fromJS(data: any): UpdatePdfFieldMappingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePdfFieldMappingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceField"] = this.sourceField;
        data["pdfFieldName"] = this.pdfFieldName;
        data["mappingType"] = this.mappingType;
        data["isEnabled"] = this.isEnabled;
        data["displayOrder"] = this.displayOrder;
        data["description"] = this.description;
        data["conditionalRulesJson"] = this.conditionalRulesJson;
        data["transformRule"] = this.transformRule;
        data["defaultValue"] = this.defaultValue;
        data["checkedValue"] = this.checkedValue;
        data["uncheckedValue"] = this.uncheckedValue;
        data["category"] = this.category;
        data["isArrayField"] = this.isArrayField;
        data["arrayName"] = this.arrayName;
        data["arrayFieldPattern"] = this.arrayFieldPattern;
        data["arrayMaxItems"] = this.arrayMaxItems;
        data["sourceArrayPath"] = this.sourceArrayPath;
        data["fieldNamePrefix"] = this.fieldNamePrefix;
        data["usePrefixInPdfFieldName"] = this.usePrefixInPdfFieldName;
        return data;
    }
}

export interface IUpdatePdfFieldMappingRequest {
    sourceField: string | undefined;
    pdfFieldName: string | undefined;
    mappingType: string | undefined;
    isEnabled: boolean | undefined;
    displayOrder: number | undefined;
    description: string | undefined;
    conditionalRulesJson: string | undefined;
    transformRule: string | undefined;
    defaultValue: string | undefined;
    checkedValue: string | undefined;
    uncheckedValue: string | undefined;
    category: string | undefined;
    isArrayField: boolean | undefined;
    arrayName: string | undefined;
    arrayFieldPattern: string | undefined;
    arrayMaxItems: number | undefined;
    sourceArrayPath: string | undefined;
    fieldNamePrefix: string | undefined;
    usePrefixInPdfFieldName: boolean | undefined;
}

export class UpdatePlanConfigurationDto implements IUpdatePlanConfigurationDto {
    tenantType!: number;
    planName!: string;
    description!: string | undefined;
    monthlyPrice!: number;
    yearlyPrice!: number;
    maxUsers!: number;
    maxStorageMB!: number;
    maxProducts!: number | undefined;
    maxMembers!: number | undefined;
    maxProductImagesPerProduct!: number | undefined;
    maxActiveOrders!: number | undefined;
    apiRateLimitPerMinute!: number;
    apiRateLimitPerDay!: number;
    overageUserPrice!: number;
    overageStoragePricePerGB!: number;
    overageProductPricePer100!: number | undefined;
    overageMemberPricePer100!: number | undefined;
    canUploadFiles!: boolean;
    canCreateSubAccounts!: boolean;
    canExportData!: boolean;
    canUseAPI!: boolean;
    canUseLandingPageBuilder!: boolean;
    canUseCustomDomain!: boolean;
    canAccessAdvancedReports!: boolean;
    canUseWhiteLabel!: boolean;
    hasPrioritySupport!: boolean;
    allowOverage!: boolean;
    sendUsageAlerts!: boolean;
    usageAlertThresholdPercent!: number;
    trialDays!: number;
    requiresCreditCard!: boolean;
    canDowngrade!: boolean;
    canUpgrade!: boolean;
    maxLandingPages!: number;
    maxEmailTemplates!: number;
    maxCustomForms!: number;
    displayOrder!: number;
    isActive!: boolean;
    id!: string;

    constructor(data?: IUpdatePlanConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantType = _data["tenantType"];
            this.planName = _data["planName"];
            this.description = _data["description"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.yearlyPrice = _data["yearlyPrice"];
            this.maxUsers = _data["maxUsers"];
            this.maxStorageMB = _data["maxStorageMB"];
            this.maxProducts = _data["maxProducts"];
            this.maxMembers = _data["maxMembers"];
            this.maxProductImagesPerProduct = _data["maxProductImagesPerProduct"];
            this.maxActiveOrders = _data["maxActiveOrders"];
            this.apiRateLimitPerMinute = _data["apiRateLimitPerMinute"];
            this.apiRateLimitPerDay = _data["apiRateLimitPerDay"];
            this.overageUserPrice = _data["overageUserPrice"];
            this.overageStoragePricePerGB = _data["overageStoragePricePerGB"];
            this.overageProductPricePer100 = _data["overageProductPricePer100"];
            this.overageMemberPricePer100 = _data["overageMemberPricePer100"];
            this.canUploadFiles = _data["canUploadFiles"];
            this.canCreateSubAccounts = _data["canCreateSubAccounts"];
            this.canExportData = _data["canExportData"];
            this.canUseAPI = _data["canUseAPI"];
            this.canUseLandingPageBuilder = _data["canUseLandingPageBuilder"];
            this.canUseCustomDomain = _data["canUseCustomDomain"];
            this.canAccessAdvancedReports = _data["canAccessAdvancedReports"];
            this.canUseWhiteLabel = _data["canUseWhiteLabel"];
            this.hasPrioritySupport = _data["hasPrioritySupport"];
            this.allowOverage = _data["allowOverage"];
            this.sendUsageAlerts = _data["sendUsageAlerts"];
            this.usageAlertThresholdPercent = _data["usageAlertThresholdPercent"];
            this.trialDays = _data["trialDays"];
            this.requiresCreditCard = _data["requiresCreditCard"];
            this.canDowngrade = _data["canDowngrade"];
            this.canUpgrade = _data["canUpgrade"];
            this.maxLandingPages = _data["maxLandingPages"];
            this.maxEmailTemplates = _data["maxEmailTemplates"];
            this.maxCustomForms = _data["maxCustomForms"];
            this.displayOrder = _data["displayOrder"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePlanConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePlanConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantType"] = this.tenantType;
        data["planName"] = this.planName;
        data["description"] = this.description;
        data["monthlyPrice"] = this.monthlyPrice;
        data["yearlyPrice"] = this.yearlyPrice;
        data["maxUsers"] = this.maxUsers;
        data["maxStorageMB"] = this.maxStorageMB;
        data["maxProducts"] = this.maxProducts;
        data["maxMembers"] = this.maxMembers;
        data["maxProductImagesPerProduct"] = this.maxProductImagesPerProduct;
        data["maxActiveOrders"] = this.maxActiveOrders;
        data["apiRateLimitPerMinute"] = this.apiRateLimitPerMinute;
        data["apiRateLimitPerDay"] = this.apiRateLimitPerDay;
        data["overageUserPrice"] = this.overageUserPrice;
        data["overageStoragePricePerGB"] = this.overageStoragePricePerGB;
        data["overageProductPricePer100"] = this.overageProductPricePer100;
        data["overageMemberPricePer100"] = this.overageMemberPricePer100;
        data["canUploadFiles"] = this.canUploadFiles;
        data["canCreateSubAccounts"] = this.canCreateSubAccounts;
        data["canExportData"] = this.canExportData;
        data["canUseAPI"] = this.canUseAPI;
        data["canUseLandingPageBuilder"] = this.canUseLandingPageBuilder;
        data["canUseCustomDomain"] = this.canUseCustomDomain;
        data["canAccessAdvancedReports"] = this.canAccessAdvancedReports;
        data["canUseWhiteLabel"] = this.canUseWhiteLabel;
        data["hasPrioritySupport"] = this.hasPrioritySupport;
        data["allowOverage"] = this.allowOverage;
        data["sendUsageAlerts"] = this.sendUsageAlerts;
        data["usageAlertThresholdPercent"] = this.usageAlertThresholdPercent;
        data["trialDays"] = this.trialDays;
        data["requiresCreditCard"] = this.requiresCreditCard;
        data["canDowngrade"] = this.canDowngrade;
        data["canUpgrade"] = this.canUpgrade;
        data["maxLandingPages"] = this.maxLandingPages;
        data["maxEmailTemplates"] = this.maxEmailTemplates;
        data["maxCustomForms"] = this.maxCustomForms;
        data["displayOrder"] = this.displayOrder;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdatePlanConfigurationDto {
    tenantType: number;
    planName: string;
    description: string | undefined;
    monthlyPrice: number;
    yearlyPrice: number;
    maxUsers: number;
    maxStorageMB: number;
    maxProducts: number | undefined;
    maxMembers: number | undefined;
    maxProductImagesPerProduct: number | undefined;
    maxActiveOrders: number | undefined;
    apiRateLimitPerMinute: number;
    apiRateLimitPerDay: number;
    overageUserPrice: number;
    overageStoragePricePerGB: number;
    overageProductPricePer100: number | undefined;
    overageMemberPricePer100: number | undefined;
    canUploadFiles: boolean;
    canCreateSubAccounts: boolean;
    canExportData: boolean;
    canUseAPI: boolean;
    canUseLandingPageBuilder: boolean;
    canUseCustomDomain: boolean;
    canAccessAdvancedReports: boolean;
    canUseWhiteLabel: boolean;
    hasPrioritySupport: boolean;
    allowOverage: boolean;
    sendUsageAlerts: boolean;
    usageAlertThresholdPercent: number;
    trialDays: number;
    requiresCreditCard: boolean;
    canDowngrade: boolean;
    canUpgrade: boolean;
    maxLandingPages: number;
    maxEmailTemplates: number;
    maxCustomForms: number;
    displayOrder: number;
    isActive: boolean;
    id: string;
}

export class UpdateProductDto implements IUpdateProductDto {
    name!: string;
    sku!: string | undefined;
    description!: string | undefined;
    price!: number;
    compareAtPrice!: number | undefined;
    cost!: number | undefined;
    stockQuantity!: number;
    lowStockThreshold!: number | undefined;
    trackInventory!: boolean;
    isActive!: boolean;
    isFeatured!: boolean;
    categoryId!: string | undefined;
    metaTitle!: string | undefined;
    metaDescription!: string | undefined;
    metaKeywords!: string | undefined;
    weight!: number | undefined;
    length!: number | undefined;
    width!: number | undefined;
    height!: number | undefined;
    weightUnit!: string | undefined;
    dimensionUnit!: string | undefined;
    images!: CreateProductImageDto[] | undefined;
    variants!: CreateProductVariantDto[] | undefined;
    id!: string;

    constructor(data?: IUpdateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.sku = _data["sku"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.compareAtPrice = _data["compareAtPrice"];
            this.cost = _data["cost"];
            this.stockQuantity = _data["stockQuantity"];
            this.lowStockThreshold = _data["lowStockThreshold"];
            this.trackInventory = _data["trackInventory"];
            this.isActive = _data["isActive"];
            this.isFeatured = _data["isFeatured"];
            this.categoryId = _data["categoryId"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.metaKeywords = _data["metaKeywords"];
            this.weight = _data["weight"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.weightUnit = _data["weightUnit"];
            this.dimensionUnit = _data["dimensionUnit"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(CreateProductImageDto.fromJS(item));
            }
            if (Array.isArray(_data["variants"])) {
                this.variants = [] as any;
                for (let item of _data["variants"])
                    this.variants!.push(CreateProductVariantDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sku"] = this.sku;
        data["description"] = this.description;
        data["price"] = this.price;
        data["compareAtPrice"] = this.compareAtPrice;
        data["cost"] = this.cost;
        data["stockQuantity"] = this.stockQuantity;
        data["lowStockThreshold"] = this.lowStockThreshold;
        data["trackInventory"] = this.trackInventory;
        data["isActive"] = this.isActive;
        data["isFeatured"] = this.isFeatured;
        data["categoryId"] = this.categoryId;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["metaKeywords"] = this.metaKeywords;
        data["weight"] = this.weight;
        data["length"] = this.length;
        data["width"] = this.width;
        data["height"] = this.height;
        data["weightUnit"] = this.weightUnit;
        data["dimensionUnit"] = this.dimensionUnit;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.variants)) {
            data["variants"] = [];
            for (let item of this.variants)
                data["variants"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateProductDto {
    name: string;
    sku: string | undefined;
    description: string | undefined;
    price: number;
    compareAtPrice: number | undefined;
    cost: number | undefined;
    stockQuantity: number;
    lowStockThreshold: number | undefined;
    trackInventory: boolean;
    isActive: boolean;
    isFeatured: boolean;
    categoryId: string | undefined;
    metaTitle: string | undefined;
    metaDescription: string | undefined;
    metaKeywords: string | undefined;
    weight: number | undefined;
    length: number | undefined;
    width: number | undefined;
    height: number | undefined;
    weightUnit: string | undefined;
    dimensionUnit: string | undefined;
    images: CreateProductImageDto[] | undefined;
    variants: CreateProductVariantDto[] | undefined;
    id: string;
}

export class UpdateProfileCompletionStepDto implements IUpdateProfileCompletionStepDto {
    memberId!: string;
    stepName!: string | undefined;
    isCompleted!: boolean;

    constructor(data?: IUpdateProfileCompletionStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.stepName = _data["stepName"];
            this.isCompleted = _data["isCompleted"];
        }
    }

    static fromJS(data: any): UpdateProfileCompletionStepDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileCompletionStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["stepName"] = this.stepName;
        data["isCompleted"] = this.isCompleted;
        return data;
    }
}

export interface IUpdateProfileCompletionStepDto {
    memberId: string;
    stepName: string | undefined;
    isCompleted: boolean;
}

export class UpdateUserProfileDto implements IUpdateUserProfileDto {
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    address!: string | undefined;
    idNumber!: string | undefined;
    dateOfBirth!: DateTime | undefined;

    constructor(data?: IUpdateUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.idNumber = _data["idNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UpdateUserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["idNumber"] = this.idNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        return data;
    }
}

export interface IUpdateUserProfileDto {
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    idNumber: string | undefined;
    dateOfBirth: DateTime | undefined;
}

export class User implements IUser {
    createdAt!: DateTime;
    updatedAt!: DateTime;
    createdBy!: string;
    updatedBy!: string;
    isDeleted!: boolean;
    rowVersion!: string | undefined;
    id!: string;
    email!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    address!: string | undefined;
    idNumber!: string | undefined;
    passwordHash!: string | undefined;
    userRoles!: UserRole[] | undefined;
    userTenant!: Tenant;
    tenantId!: string;
    mustChangePassword!: boolean;
    isIdVerified!: boolean;
    idVerifiedAt!: DateTime | undefined;
    customFieldsJson!: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? DateTime.fromISO(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? DateTime.fromISO(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.rowVersion = _data["rowVersion"];
            this.id = _data["id"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.idNumber = _data["idNumber"];
            this.passwordHash = _data["passwordHash"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
            this.userTenant = _data["userTenant"] ? Tenant.fromJS(_data["userTenant"]) : undefined as any;
            this.tenantId = _data["tenantId"];
            this.mustChangePassword = _data["mustChangePassword"];
            this.isIdVerified = _data["isIdVerified"];
            this.idVerifiedAt = _data["idVerifiedAt"] ? DateTime.fromISO(_data["idVerifiedAt"].toString()) : undefined as any;
            this.customFieldsJson = _data["customFieldsJson"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["rowVersion"] = this.rowVersion;
        data["id"] = this.id;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["idNumber"] = this.idNumber;
        data["passwordHash"] = this.passwordHash;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item ? item.toJSON() : undefined as any);
        }
        data["userTenant"] = this.userTenant ? this.userTenant.toJSON() : undefined as any;
        data["tenantId"] = this.tenantId;
        data["mustChangePassword"] = this.mustChangePassword;
        data["isIdVerified"] = this.isIdVerified;
        data["idVerifiedAt"] = this.idVerifiedAt ? this.idVerifiedAt.toString() : undefined as any;
        data["customFieldsJson"] = this.customFieldsJson;
        return data;
    }
}

export interface IUser {
    createdAt: DateTime;
    updatedAt: DateTime;
    createdBy: string;
    updatedBy: string;
    isDeleted: boolean;
    rowVersion: string | undefined;
    id: string;
    email: string;
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    idNumber: string | undefined;
    passwordHash: string | undefined;
    userRoles: UserRole[] | undefined;
    userTenant: Tenant;
    tenantId: string;
    mustChangePassword: boolean;
    isIdVerified: boolean;
    idVerifiedAt: DateTime | undefined;
    customFieldsJson: string | undefined;
}

export class UserDto implements IUserDto {
    id!: string;
    email!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    address!: string | undefined;
    userRoles!: UserRoleDto[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IUserDto {
    id: string;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    userRoles: UserRoleDto[] | undefined;
}

export class UserProfileDto implements IUserProfileDto {
    id!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    address!: string | undefined;
    idNumber!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    isIdVerified!: boolean;
    idVerifiedAt!: DateTime | undefined;

    constructor(data?: IUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.idNumber = _data["idNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.isIdVerified = _data["isIdVerified"];
            this.idVerifiedAt = _data["idVerifiedAt"] ? DateTime.fromISO(_data["idVerifiedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["idNumber"] = this.idNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["isIdVerified"] = this.isIdVerified;
        data["idVerifiedAt"] = this.idVerifiedAt ? this.idVerifiedAt.toString() : undefined as any;
        return data;
    }
}

export interface IUserProfileDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    idNumber: string | undefined;
    dateOfBirth: DateTime | undefined;
    isIdVerified: boolean;
    idVerifiedAt: DateTime | undefined;
}

export class UserRole implements IUserRole {
    id!: string;
    userId!: string;
    roleId!: string;
    user!: User;
    role!: Role;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : undefined as any;
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        data["role"] = this.role ? this.role.toJSON() : undefined as any;
        return data;
    }
}

export interface IUserRole {
    id: string;
    userId: string;
    roleId: string;
    user: User;
    role: Role;
}

export class UserRoleDto implements IUserRoleDto {
    id!: string;
    userId!: string;
    userName!: string | undefined;
    roleId!: string;
    roleName!: string | undefined;
    permissions!: PermissionDto[] | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IUserRoleDto {
    id: string;
    userId: string;
    userName: string | undefined;
    roleId: string;
    roleName: string | undefined;
    permissions: PermissionDto[] | undefined;
}

export class UserRoleInputDto implements IUserRoleInputDto {
    userId!: string;
    roleId!: string;

    constructor(data?: IUserRoleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRoleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IUserRoleInputDto {
    userId: string;
    roleId: string;
}

export class ValidateCouponDto implements IValidateCouponDto {
    couponCode!: string | undefined;
    code!: string | undefined;
    tenantId!: string | undefined;
    subscriptionPlanId!: string;
    amount!: number;
    planAmount!: number;

    constructor(data?: IValidateCouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.couponCode = _data["couponCode"];
            this.code = _data["code"];
            this.tenantId = _data["tenantId"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.amount = _data["amount"];
            this.planAmount = _data["planAmount"];
        }
    }

    static fromJS(data: any): ValidateCouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateCouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["couponCode"] = this.couponCode;
        data["code"] = this.code;
        data["tenantId"] = this.tenantId;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["amount"] = this.amount;
        data["planAmount"] = this.planAmount;
        return data;
    }
}

export interface IValidateCouponDto {
    couponCode: string | undefined;
    code: string | undefined;
    tenantId: string | undefined;
    subscriptionPlanId: string;
    amount: number;
    planAmount: number;
}

export class ValidatePolicyNumberRequestDto implements IValidatePolicyNumberRequestDto {
    policyNumber!: string;

    constructor(data?: IValidatePolicyNumberRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.policyNumber = _data["policyNumber"];
        }
    }

    static fromJS(data: any): ValidatePolicyNumberRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidatePolicyNumberRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyNumber"] = this.policyNumber;
        return data;
    }
}

export interface IValidatePolicyNumberRequestDto {
    policyNumber: string;
}

export class ValidatePolicyNumberResponseDto implements IValidatePolicyNumberResponseDto {
    isAvailable!: boolean;
    message!: string | undefined;
    existingMemberId!: string | undefined;
    existingPolicyId!: string | undefined;

    constructor(data?: IValidatePolicyNumberResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
            this.message = _data["message"];
            this.existingMemberId = _data["existingMemberId"];
            this.existingPolicyId = _data["existingPolicyId"];
        }
    }

    static fromJS(data: any): ValidatePolicyNumberResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidatePolicyNumberResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        data["message"] = this.message;
        data["existingMemberId"] = this.existingMemberId;
        data["existingPolicyId"] = this.existingPolicyId;
        return data;
    }
}

export interface IValidatePolicyNumberResponseDto {
    isAvailable: boolean;
    message: string | undefined;
    existingMemberId: string | undefined;
    existingPolicyId: string | undefined;
}

export class VerificationRequestDto implements IVerificationRequestDto {
    id!: string;
    idNumber!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    verificationType!: string | undefined;
    status!: string | undefined;
    verifyIdTransactionId!: string | undefined;
    verifiedAt!: DateTime | undefined;
    userId!: string | undefined;
    memberId!: string | undefined;
    claimId!: string | undefined;

    constructor(data?: IVerificationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idNumber = _data["idNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : undefined as any;
            this.verificationType = _data["verificationType"];
            this.status = _data["status"];
            this.verifyIdTransactionId = _data["verifyIdTransactionId"];
            this.verifiedAt = _data["verifiedAt"] ? DateTime.fromISO(_data["verifiedAt"].toString()) : undefined as any;
            this.userId = _data["userId"];
            this.memberId = _data["memberId"];
            this.claimId = _data["claimId"];
        }
    }

    static fromJS(data: any): VerificationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idNumber"] = this.idNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : undefined as any;
        data["verificationType"] = this.verificationType;
        data["status"] = this.status;
        data["verifyIdTransactionId"] = this.verifyIdTransactionId;
        data["verifiedAt"] = this.verifiedAt ? this.verifiedAt.toString() : undefined as any;
        data["userId"] = this.userId;
        data["memberId"] = this.memberId;
        data["claimId"] = this.claimId;
        return data;
    }
}

export interface IVerificationRequestDto {
    id: string;
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    dateOfBirth: DateTime | undefined;
    verificationType: string | undefined;
    status: string | undefined;
    verifyIdTransactionId: string | undefined;
    verifiedAt: DateTime | undefined;
    userId: string | undefined;
    memberId: string | undefined;
    claimId: string | undefined;
}

export class VerifyDependentOtpDto implements IVerifyDependentOtpDto {
    idNumber!: string;
    otpCode!: string;
    email!: string;
    password!: string;

    constructor(data?: IVerifyDependentOtpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
            this.otpCode = _data["otpCode"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): VerifyDependentOtpDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyDependentOtpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        data["otpCode"] = this.otpCode;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IVerifyDependentOtpDto {
    idNumber: string;
    otpCode: string;
    email: string;
    password: string;
}

export class VoidInvoiceRequest implements IVoidInvoiceRequest {
    reason!: string | undefined;

    constructor(data?: IVoidInvoiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): VoidInvoiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VoidInvoiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        return data;
    }
}

export interface IVoidInvoiceRequest {
    reason: string | undefined;
}

export class WorkingHoursDto implements IWorkingHoursDto {
    closed!: boolean;
    start!: string | undefined;
    end!: string | undefined;

    constructor(data?: IWorkingHoursDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.closed = _data["closed"];
            this.start = _data["start"];
            this.end = _data["end"];
        }
    }

    static fromJS(data: any): WorkingHoursDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingHoursDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["closed"] = this.closed;
        data["start"] = this.start;
        data["end"] = this.end;
        return data;
    }
}

export interface IWorkingHoursDto {
    closed: boolean;
    start: string | undefined;
    end: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

